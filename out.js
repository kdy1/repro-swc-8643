/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let _canvas, A, I, B, _zstd, dracoDecoderLocation, ktx2TranscoderLocation, meshoptDecoderLocation, meshoptDecoder, _renderer, fullscreenQuadGeometry, fullscreenQuadMaterial, fullscreenQuad, _canReadPixelsResult, allowedNames;
let i$2 = (i, e) => "method" !== e.kind || !e.descriptor || "value" in e.descriptor ? {
		kind: "field",
		key: Symbol(),
		placement: "own",
		descriptor: {},
		originalKey: e.key,
		initializer() {
			"function" == typeof e.initializer && (this[e.key] = e.initializer.call(this))
		},
		finisher(n) {
			n.createProperty(e.key, i)
		}
	} : {
		...e,
		finisher(n) {
			n.createProperty(e.key, i)
		}
	},
	e$5 = (i, e, n) => {
		e.constructor.createProperty(n, i)
	};

function n$8(n) {
	return (t, o) => void 0 !== o ? e$5(n, t, o) : i$2(n, t)
}
null != (null === (n$7 = window.HTMLSlotElement) || void 0 === n$7 ? void 0 : n$7.prototype.assignedElements) || ((o, n) => o.assignedNodes(n).filter(o => o.nodeType === Node.ELEMENT_NODE));
let AttachedBindMode = "attached",
	NearestFilter = 1003,
	SRGBColorSpace = "srgb",
	LinearSRGBColorSpace = "srgb-linear",
	DisplayP3ColorSpace = "display-p3",
	LinearDisplayP3ColorSpace = "display-p3-linear",
	LinearTransfer = "linear",
	SRGBTransfer = "srgb",
	Rec709Primaries = "rec709",
	GLSL3 = "300 es";
class EventDispatcher {
	addEventListener(type, listener) {
		void 0 === this._listeners && (this._listeners = {});
		let listeners = this._listeners;
		void 0 === listeners[type] && (listeners[type] = []), -1 === listeners[type].indexOf(listener) && listeners[type].push(listener)
	}
	hasEventListener(type, listener) {
		if (void 0 === this._listeners) return !1;
		let listeners = this._listeners;
		return void 0 !== listeners[type] && -1 !== listeners[type].indexOf(listener)
	}
	removeEventListener(type, listener) {
		if (void 0 === this._listeners) return;
		let listenerArray = this._listeners[type];
		if (void 0 !== listenerArray) {
			let index = listenerArray.indexOf(listener); - 1 !== index && listenerArray.splice(index, 1)
		}
	}
	dispatchEvent(event) {
		if (void 0 === this._listeners) return;
		let listenerArray = this._listeners[event.type];
		if (void 0 !== listenerArray) {
			event.target = this;
			let array = listenerArray.slice(0);
			for (let i = 0, l = array.length; i < l; i++) array[i].call(this, event);
			event.target = null
		}
	}
}
let _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
	_seed = 1234567,
	DEG2RAD = Math.PI / 180,
	RAD2DEG = 180 / Math.PI;

function generateUUID() {
	let d0 = 4294967295 * Math.random() | 0,
		d1 = 4294967295 * Math.random() | 0,
		d2 = 4294967295 * Math.random() | 0,
		d3 = 4294967295 * Math.random() | 0;
	return (_lut[255 & d0] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[255 & d1] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[63 & d2 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[255 & d3] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255]).toLowerCase()
}

function clamp$1(value, min, max) {
	return Math.max(min, Math.min(max, value))
}

function euclideanModulo(n, m) {
	return (n % m + m) % m
}

function lerp$1(x, y, t) {
	return (1 - t) * x + t * y
}

function isPowerOfTwo(value) {
	return (value & value - 1) == 0 && 0 !== value
}

function floorPowerOfTwo(value) {
	return Math.pow(2, Math.floor(Math.log(value) / Math.LN2))
}

function denormalize(value, array) {
	switch (array.constructor) {
		case Float32Array:
			return value;
		case Uint32Array:
			return value / 4294967295;
		case Uint16Array:
			return value / 65535;
		case Uint8Array:
			return value / 255;
		case Int32Array:
			return Math.max(value / 2147483647, -1);
		case Int16Array:
			return Math.max(value / 32767, -1);
		case Int8Array:
			return Math.max(value / 127, -1);
		default:
			throw Error("Invalid component type.")
	}
}

function normalize(value, array) {
	switch (array.constructor) {
		case Float32Array:
			return value;
		case Uint32Array:
			return Math.round(4294967295 * value);
		case Uint16Array:
			return Math.round(65535 * value);
		case Uint8Array:
			return Math.round(255 * value);
		case Int32Array:
			return Math.round(2147483647 * value);
		case Int16Array:
			return Math.round(32767 * value);
		case Int8Array:
			return Math.round(127 * value);
		default:
			throw Error("Invalid component type.")
	}
}
let MathUtils = {
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp$1,
	euclideanModulo: euclideanModulo,
	mapLinear: function(x, a1, a2, b1, b2) {
		return b1 + (x - a1) * (b2 - b1) / (a2 - a1)
	},
	inverseLerp: function(x, y, value) {
		return x !== y ? (value - x) / (y - x) : 0
	},
	lerp: lerp$1,
	damp: function(x, y, lambda, dt) {
		return lerp$1(x, y, 1 - Math.exp(-lambda * dt))
	},
	pingpong: function(x, length = 1) {
		return length - Math.abs(euclideanModulo(x, 2 * length) - length)
	},
	smoothstep: function(x, min, max) {
		return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min)) * x * (3 - 2 * x)
	},
	smootherstep: function(x, min, max) {
		return x <= min ? 0 : x >= max ? 1 : (x = (x - min) / (max - min)) * x * x * (x * (6 * x - 15) + 10)
	},
	randInt: function(low, high) {
		return low + Math.floor(Math.random() * (high - low + 1))
	},
	randFloat: function(low, high) {
		return low + Math.random() * (high - low)
	},
	randFloatSpread: function(range) {
		return range * (.5 - Math.random())
	},
	seededRandom: function(s) {
		void 0 !== s && (_seed = s);
		let t = _seed += 1831565813;
		return t = Math.imul(t ^ t >>> 15, 1 | t), (((t ^= t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t >>> 14) >>> 0) / 4294967296
	},
	degToRad: function(degrees) {
		return degrees * DEG2RAD
	},
	radToDeg: function(radians) {
		return radians * RAD2DEG
	},
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: function(value) {
		return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2))
	},
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: function(q, a, b, c, order) {
		let cos = Math.cos,
			sin = Math.sin,
			c2 = cos(b / 2),
			s2 = sin(b / 2),
			c13 = cos((a + c) / 2),
			s13 = sin((a + c) / 2),
			c1_3 = cos((a - c) / 2),
			s1_3 = sin((a - c) / 2),
			c3_1 = cos((c - a) / 2),
			s3_1 = sin((c - a) / 2);
		switch (order) {
			case "XYX":
				q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
				break;
			case "YZY":
				q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
				break;
			case "ZXZ":
				q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
				break;
			case "XZX":
				q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
				break;
			case "YXY":
				q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
				break;
			case "ZYZ":
				q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
				break;
			default:
				console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order)
		}
	},
	normalize: normalize,
	denormalize: denormalize
};
class Vector2 {
	constructor(x = 0, y = 0) {
		Vector2.prototype.isVector2 = !0, this.x = x, this.y = y
	}
	get width() {
		return this.x
	}
	set width(value) {
		this.x = value
	}
	get height() {
		return this.y
	}
	set height(value) {
		this.y = value
	}
	set(x, y) {
		return this.x = x, this.y = y, this
	}
	setScalar(scalar) {
		return this.x = scalar, this.y = scalar, this
	}
	setX(x) {
		return this.x = x, this
	}
	setY(y) {
		return this.y = y, this
	}
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			default:
				throw Error("index is out of range: " + index)
		}
		return this
	}
	getComponent(index) {
		switch (index) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			default:
				throw Error("index is out of range: " + index)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y)
	}
	copy(v) {
		return this.x = v.x, this.y = v.y, this
	}
	add(v) {
		return this.x += v.x, this.y += v.y, this
	}
	addScalar(s) {
		return this.x += s, this.y += s, this
	}
	addVectors(a, b) {
		return this.x = a.x + b.x, this.y = a.y + b.y, this
	}
	addScaledVector(v, s) {
		return this.x += v.x * s, this.y += v.y * s, this
	}
	sub(v) {
		return this.x -= v.x, this.y -= v.y, this
	}
	subScalar(s) {
		return this.x -= s, this.y -= s, this
	}
	subVectors(a, b) {
		return this.x = a.x - b.x, this.y = a.y - b.y, this
	}
	multiply(v) {
		return this.x *= v.x, this.y *= v.y, this
	}
	multiplyScalar(scalar) {
		return this.x *= scalar, this.y *= scalar, this
	}
	divide(v) {
		return this.x /= v.x, this.y /= v.y, this
	}
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar)
	}
	applyMatrix3(m) {
		let x = this.x,
			y = this.y,
			e = m.elements;
		return this.x = e[0] * x + e[3] * y + e[6], this.y = e[1] * x + e[4] * y + e[7], this
	}
	min(v) {
		return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this
	}
	max(v) {
		return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this
	}
	clamp(min, max) {
		return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), this
	}
	clampScalar(minVal, maxVal) {
		return this.x = Math.max(minVal, Math.min(maxVal, this.x)), this.y = Math.max(minVal, Math.min(maxVal, this.y)), this
	}
	clampLength(min, max) {
		let length = this.length();
		return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this
	}
	roundToZero() {
		return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this
	}
	dot(v) {
		return this.x * v.x + this.y * v.y
	}
	cross(v) {
		return this.x * v.y - this.y * v.x
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	angle() {
		return Math.atan2(-this.y, -this.x) + Math.PI
	}
	angleTo(v) {
		let denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
		return 0 === denominator ? Math.PI / 2 : Math.acos(clamp$1(this.dot(v) / denominator, -1, 1))
	}
	distanceTo(v) {
		return Math.sqrt(this.distanceToSquared(v))
	}
	distanceToSquared(v) {
		let dx = this.x - v.x,
			dy = this.y - v.y;
		return dx * dx + dy * dy
	}
	manhattanDistanceTo(v) {
		return Math.abs(this.x - v.x) + Math.abs(this.y - v.y)
	}
	setLength(length) {
		return this.normalize().multiplyScalar(length)
	}
	lerp(v, alpha) {
		return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this
	}
	lerpVectors(v1, v2, alpha) {
		return this.x = v1.x + (v2.x - v1.x) * alpha, this.y = v1.y + (v2.y - v1.y) * alpha, this
	}
	equals(v) {
		return v.x === this.x && v.y === this.y
	}
	fromArray(array, offset = 0) {
		return this.x = array[offset], this.y = array[offset + 1], this
	}
	toArray(array = [], offset = 0) {
		return array[offset] = this.x, array[offset + 1] = this.y, array
	}
	fromBufferAttribute(attribute, index) {
		return this.x = attribute.getX(index), this.y = attribute.getY(index), this
	}
	rotateAround(center, angle) {
		let c = Math.cos(angle),
			s = Math.sin(angle),
			x = this.x - center.x,
			y = this.y - center.y;
		return this.x = x * c - y * s + center.x, this.y = x * s + y * c + center.y, this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y
	}
}
class Matrix3 {
	constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
		Matrix3.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== n11 && this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33)
	}
	set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
		let te = this.elements;
		return te[0] = n11, te[1] = n21, te[2] = n31, te[3] = n12, te[4] = n22, te[5] = n32, te[6] = n13, te[7] = n23, te[8] = n33, this
	}
	identity() {
		return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
	}
	copy(m) {
		let te = this.elements,
			me = m.elements;
		return te[0] = me[0], te[1] = me[1], te[2] = me[2], te[3] = me[3], te[4] = me[4], te[5] = me[5], te[6] = me[6], te[7] = me[7], te[8] = me[8], this
	}
	extractBasis(xAxis, yAxis, zAxis) {
		return xAxis.setFromMatrix3Column(this, 0), yAxis.setFromMatrix3Column(this, 1), zAxis.setFromMatrix3Column(this, 2), this
	}
	setFromMatrix4(m) {
		let me = m.elements;
		return this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]), this
	}
	multiply(m) {
		return this.multiplyMatrices(this, m)
	}
	premultiply(m) {
		return this.multiplyMatrices(m, this)
	}
	multiplyMatrices(a, b) {
		let ae = a.elements,
			be = b.elements,
			te = this.elements,
			a11 = ae[0],
			a12 = ae[3],
			a13 = ae[6],
			a21 = ae[1],
			a22 = ae[4],
			a23 = ae[7],
			a31 = ae[2],
			a32 = ae[5],
			a33 = ae[8],
			b11 = be[0],
			b12 = be[3],
			b13 = be[6],
			b21 = be[1],
			b22 = be[4],
			b23 = be[7],
			b31 = be[2],
			b32 = be[5],
			b33 = be[8];
		return te[0] = a11 * b11 + a12 * b21 + a13 * b31, te[3] = a11 * b12 + a12 * b22 + a13 * b32, te[6] = a11 * b13 + a12 * b23 + a13 * b33, te[1] = a21 * b11 + a22 * b21 + a23 * b31, te[4] = a21 * b12 + a22 * b22 + a23 * b32, te[7] = a21 * b13 + a22 * b23 + a23 * b33, te[2] = a31 * b11 + a32 * b21 + a33 * b31, te[5] = a31 * b12 + a32 * b22 + a33 * b32, te[8] = a31 * b13 + a32 * b23 + a33 * b33, this
	}
	multiplyScalar(s) {
		let te = this.elements;
		return te[0] *= s, te[3] *= s, te[6] *= s, te[1] *= s, te[4] *= s, te[7] *= s, te[2] *= s, te[5] *= s, te[8] *= s, this
	}
	determinant() {
		let te = this.elements,
			a = te[0],
			b = te[1],
			c = te[2],
			d = te[3],
			e = te[4],
			f = te[5],
			g = te[6],
			h = te[7],
			i = te[8];
		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g
	}
	invert() {
		let te = this.elements,
			n11 = te[0],
			n21 = te[1],
			n31 = te[2],
			n12 = te[3],
			n22 = te[4],
			n32 = te[5],
			n13 = te[6],
			n23 = te[7],
			n33 = te[8],
			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,
			det = n11 * t11 + n21 * t12 + n31 * t13;
		if (0 === det) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
		let detInv = 1 / det;
		return te[0] = t11 * detInv, te[1] = (n31 * n23 - n33 * n21) * detInv, te[2] = (n32 * n21 - n31 * n22) * detInv, te[3] = t12 * detInv, te[4] = (n33 * n11 - n31 * n13) * detInv, te[5] = (n31 * n12 - n32 * n11) * detInv, te[6] = t13 * detInv, te[7] = (n21 * n13 - n23 * n11) * detInv, te[8] = (n22 * n11 - n21 * n12) * detInv, this
	}
	transpose() {
		let tmp;
		let m = this.elements;
		return tmp = m[1], m[1] = m[3], m[3] = tmp, tmp = m[2], m[2] = m[6], m[6] = tmp, tmp = m[5], m[5] = m[7], m[7] = tmp, this
	}
	getNormalMatrix(matrix4) {
		return this.setFromMatrix4(matrix4).invert().transpose()
	}
	transposeIntoArray(r) {
		let m = this.elements;
		return r[0] = m[0], r[1] = m[3], r[2] = m[6], r[3] = m[1], r[4] = m[4], r[5] = m[7], r[6] = m[2], r[7] = m[5], r[8] = m[8], this
	}
	setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
		let c = Math.cos(rotation),
			s = Math.sin(rotation);
		return this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1), this
	}
	scale(sx, sy) {
		return this.premultiply(_m3.makeScale(sx, sy)), this
	}
	rotate(theta) {
		return this.premultiply(_m3.makeRotation(-theta)), this
	}
	translate(tx, ty) {
		return this.premultiply(_m3.makeTranslation(tx, ty)), this
	}
	makeTranslation(x, y) {
		return x.isVector2 ? this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1) : this.set(1, 0, x, 0, 1, y, 0, 0, 1), this
	}
	makeRotation(theta) {
		let c = Math.cos(theta),
			s = Math.sin(theta);
		return this.set(c, -s, 0, s, c, 0, 0, 0, 1), this
	}
	makeScale(x, y) {
		return this.set(x, 0, 0, 0, y, 0, 0, 0, 1), this
	}
	equals(matrix) {
		let te = this.elements,
			me = matrix.elements;
		for (let i = 0; i < 9; i++)
			if (te[i] !== me[i]) return !1;
		return !0
	}
	fromArray(array, offset = 0) {
		for (let i = 0; i < 9; i++) this.elements[i] = array[i + offset];
		return this
	}
	toArray(array = [], offset = 0) {
		let te = this.elements;
		return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2], array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5], array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8], array
	}
	clone() {
		return new this.constructor().fromArray(this.elements)
	}
}
let _m3 = new Matrix3;

function arrayNeedsUint32(array) {
	for (let i = array.length - 1; i >= 0; --i)
		if (array[i] >= 65535) return !0;
	return !1
}

function createElementNS(name) {
	return document.createElementNS("http://www.w3.org/1999/xhtml", name)
}
let _cache = {};

function warnOnce(message) {
	message in _cache || (_cache[message] = !0, console.warn(message))
}
let LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
	LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
	COLOR_SPACES = {
		[LinearSRGBColorSpace]: {
			transfer: LinearTransfer,
			primaries: Rec709Primaries,
			toReference: color => color,
			fromReference: color => color
		},
		[SRGBColorSpace]: {
			transfer: SRGBTransfer,
			primaries: Rec709Primaries,
			toReference: color => color.convertSRGBToLinear(),
			fromReference: color => color.convertLinearToSRGB()
		},
		[LinearDisplayP3ColorSpace]: {
			transfer: LinearTransfer,
			primaries: "p3",
			toReference: color => color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
			fromReference: color => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
		},
		[DisplayP3ColorSpace]: {
			transfer: SRGBTransfer,
			primaries: "p3",
			toReference: color => color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
			fromReference: color => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
		}
	},
	SUPPORTED_WORKING_COLOR_SPACES = new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]),
	ColorManagement = {
		enabled: !0,
		_workingColorSpace: LinearSRGBColorSpace,
		get workingColorSpace() {
			return this._workingColorSpace
		},
		set workingColorSpace(colorSpace) {
			if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) throw Error(`Unsupported working color space, "${colorSpace}".`);
			this._workingColorSpace = colorSpace
		},
		convert: function(color, sourceColorSpace, targetColorSpace) {
			if (!1 === this.enabled || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) return color;
			let sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
			return (0, COLOR_SPACES[targetColorSpace].fromReference)(sourceToReference(color))
		},
		fromWorkingColorSpace: function(color, targetColorSpace) {
			return this.convert(color, this._workingColorSpace, targetColorSpace)
		},
		toWorkingColorSpace: function(color, sourceColorSpace) {
			return this.convert(color, sourceColorSpace, this._workingColorSpace)
		},
		getPrimaries: function(colorSpace1) {
			return COLOR_SPACES[colorSpace1].primaries
		},
		getTransfer: function(colorSpace1) {
			return "" === colorSpace1 ? LinearTransfer : COLOR_SPACES[colorSpace1].transfer
		}
	};

function SRGBToLinear(c) {
	return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4)
}

function LinearToSRGB(c) {
	return c < .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055
}
class ImageUtils {
	static getDataURL(image) {
		let canvas;
		if (/^data:/i.test(image.src) || "undefined" == typeof HTMLCanvasElement) return image.src;
		if (image instanceof HTMLCanvasElement) canvas = image;
		else {
			void 0 === _canvas && (_canvas = createElementNS("canvas")), _canvas.width = image.width, _canvas.height = image.height;
			let context = _canvas.getContext("2d");
			image instanceof ImageData ? context.putImageData(image, 0, 0) : context.drawImage(image, 0, 0, image.width, image.height), canvas = _canvas
		}
		return canvas.width > 2048 || canvas.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image), canvas.toDataURL("image/jpeg", .6)) : canvas.toDataURL("image/png")
	}
	static sRGBToLinear(image) {
		if ("undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap) {
			let canvas = createElementNS("canvas");
			canvas.width = image.width, canvas.height = image.height;
			let context = canvas.getContext("2d");
			context.drawImage(image, 0, 0, image.width, image.height);
			let imageData = context.getImageData(0, 0, image.width, image.height),
				data = imageData.data;
			for (let i = 0; i < data.length; i++) data[i] = 255 * SRGBToLinear(data[i] / 255);
			return context.putImageData(imageData, 0, 0), canvas
		}
		if (!image.data) return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), image;
		{
			let data = image.data.slice(0);
			for (let i = 0; i < data.length; i++) data instanceof Uint8Array || data instanceof Uint8ClampedArray ? data[i] = Math.floor(255 * SRGBToLinear(data[i] / 255)) : data[i] = SRGBToLinear(data[i]);
			return {
				data: data,
				width: image.width,
				height: image.height
			}
		}
	}
}
let _sourceId = 0;
class Source {
	constructor(data = null) {
		this.isSource = !0, Object.defineProperty(this, "id", {
			value: _sourceId++
		}), this.uuid = generateUUID(), this.data = data, this.version = 0
	}
	set needsUpdate(value) {
		!0 === value && this.version++
	}
	toJSON(meta) {
		let isRootObject = void 0 === meta || "string" == typeof meta;
		if (!isRootObject && void 0 !== meta.images[this.uuid]) return meta.images[this.uuid];
		let output = {
				uuid: this.uuid,
				url: ""
			},
			data = this.data;
		if (null !== data) {
			let url;
			if (Array.isArray(data)) {
				url = [];
				for (let i = 0, l = data.length; i < l; i++) data[i].isDataTexture ? url.push(serializeImage(data[i].image)) : url.push(serializeImage(data[i]))
			} else url = serializeImage(data);
			output.url = url
		}
		return isRootObject || (meta.images[this.uuid] = output), output
	}
}

function serializeImage(image) {
	return "undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap ? ImageUtils.getDataURL(image) : image.data ? {
		data: Array.from(image.data),
		width: image.width,
		height: image.height,
		type: image.data.constructor.name
	} : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let _textureId = 0;
class Texture$1 extends EventDispatcher {
	constructor(image = Texture$1.DEFAULT_IMAGE, mapping = Texture$1.DEFAULT_MAPPING, wrapS = 1001, wrapT = 1001, magFilter = 1006, minFilter = 1008, format = 1023, type = 1009, anisotropy = Texture$1.DEFAULT_ANISOTROPY, colorSpace1 = "") {
		super(), this.isTexture = !0, Object.defineProperty(this, "id", {
			value: _textureId++
		}), this.uuid = generateUUID(), this.name = "", this.source = new Source(image), this.mipmaps = [], this.mapping = mapping, this.channel = 0, this.wrapS = wrapS, this.wrapT = wrapT, this.magFilter = magFilter, this.minFilter = minFilter, this.anisotropy = anisotropy, this.format = format, this.internalFormat = null, this.type = type, this.offset = new Vector2(0, 0), this.repeat = new Vector2(1, 1), this.center = new Vector2(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Matrix3, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, "string" == typeof colorSpace1 ? this.colorSpace = colorSpace1 : (warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = 3001 === colorSpace1 ? SRGBColorSpace : ""), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
	}
	get image() {
		return this.source.data
	}
	set image(value = null) {
		this.source.data = value
	}
	updateMatrix() {
		this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(source) {
		return this.name = source.name, this.source = source.source, this.mipmaps = source.mipmaps.slice(0), this.mapping = source.mapping, this.channel = source.channel, this.wrapS = source.wrapS, this.wrapT = source.wrapT, this.magFilter = source.magFilter, this.minFilter = source.minFilter, this.anisotropy = source.anisotropy, this.format = source.format, this.internalFormat = source.internalFormat, this.type = source.type, this.offset.copy(source.offset), this.repeat.copy(source.repeat), this.center.copy(source.center), this.rotation = source.rotation, this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrix.copy(source.matrix), this.generateMipmaps = source.generateMipmaps, this.premultiplyAlpha = source.premultiplyAlpha, this.flipY = source.flipY, this.unpackAlignment = source.unpackAlignment, this.colorSpace = source.colorSpace, this.userData = JSON.parse(JSON.stringify(source.userData)), this.needsUpdate = !0, this
	}
	toJSON(meta) {
		let isRootObject = void 0 === meta || "string" == typeof meta;
		if (!isRootObject && void 0 !== meta.textures[this.uuid]) return meta.textures[this.uuid];
		let output = {
			metadata: {
				version: 4.6,
				type: "Texture",
				generator: "Texture.toJSON"
			},
			uuid: this.uuid,
			name: this.name,
			image: this.source.toJSON(meta).uuid,
			mapping: this.mapping,
			channel: this.channel,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			center: [this.center.x, this.center.y],
			rotation: this.rotation,
			wrap: [this.wrapS, this.wrapT],
			format: this.format,
			internalFormat: this.internalFormat,
			type: this.type,
			colorSpace: this.colorSpace,
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,
			flipY: this.flipY,
			generateMipmaps: this.generateMipmaps,
			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment
		};
		return Object.keys(this.userData).length > 0 && (output.userData = this.userData), isRootObject || (meta.textures[this.uuid] = output), output
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
	transformUv(uv) {
		if (300 !== this.mapping) return uv;
		if (uv.applyMatrix3(this.matrix), uv.x < 0 || uv.x > 1) switch (this.wrapS) {
			case 1e3:
				uv.x = uv.x - Math.floor(uv.x);
				break;
			case 1001:
				uv.x = uv.x < 0 ? 0 : 1;
				break;
			case 1002:
				1 === Math.abs(Math.floor(uv.x) % 2) ? uv.x = Math.ceil(uv.x) - uv.x : uv.x = uv.x - Math.floor(uv.x)
		}
		if (uv.y < 0 || uv.y > 1) switch (this.wrapT) {
			case 1e3:
				uv.y = uv.y - Math.floor(uv.y);
				break;
			case 1001:
				uv.y = uv.y < 0 ? 0 : 1;
				break;
			case 1002:
				1 === Math.abs(Math.floor(uv.y) % 2) ? uv.y = Math.ceil(uv.y) - uv.y : uv.y = uv.y - Math.floor(uv.y)
		}
		return this.flipY && (uv.y = 1 - uv.y), uv
	}
	set needsUpdate(value) {
		!0 === value && (this.version++, this.source.needsUpdate = !0)
	}
	get encoding() {
		return warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === SRGBColorSpace ? 3001 : 3e3
	}
	set encoding(encoding) {
		warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = 3001 === encoding ? SRGBColorSpace : ""
	}
}
Texture$1.DEFAULT_IMAGE = null, Texture$1.DEFAULT_MAPPING = 300, Texture$1.DEFAULT_ANISOTROPY = 1;
class Vector4 {
	constructor(x = 0, y = 0, z = 0, w = 1) {
		Vector4.prototype.isVector4 = !0, this.x = x, this.y = y, this.z = z, this.w = w
	}
	get width() {
		return this.z
	}
	set width(value) {
		this.z = value
	}
	get height() {
		return this.w
	}
	set height(value) {
		this.w = value
	}
	set(x, y, z, w) {
		return this.x = x, this.y = y, this.z = z, this.w = w, this
	}
	setScalar(scalar) {
		return this.x = scalar, this.y = scalar, this.z = scalar, this.w = scalar, this
	}
	setX(x) {
		return this.x = x, this
	}
	setY(y) {
		return this.y = y, this
	}
	setZ(z) {
		return this.z = z, this
	}
	setW(w) {
		return this.w = w, this
	}
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			case 2:
				this.z = value;
				break;
			case 3:
				this.w = value;
				break;
			default:
				throw Error("index is out of range: " + index)
		}
		return this
	}
	getComponent(index) {
		switch (index) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			case 3:
				return this.w;
			default:
				throw Error("index is out of range: " + index)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z, this.w)
	}
	copy(v) {
		return this.x = v.x, this.y = v.y, this.z = v.z, this.w = void 0 !== v.w ? v.w : 1, this
	}
	add(v) {
		return this.x += v.x, this.y += v.y, this.z += v.z, this.w += v.w, this
	}
	addScalar(s) {
		return this.x += s, this.y += s, this.z += s, this.w += s, this
	}
	addVectors(a, b) {
		return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this
	}
	addScaledVector(v, s) {
		return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this.w += v.w * s, this
	}
	sub(v) {
		return this.x -= v.x, this.y -= v.y, this.z -= v.z, this.w -= v.w, this
	}
	subScalar(s) {
		return this.x -= s, this.y -= s, this.z -= s, this.w -= s, this
	}
	subVectors(a, b) {
		return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this
	}
	multiply(v) {
		return this.x *= v.x, this.y *= v.y, this.z *= v.z, this.w *= v.w, this
	}
	multiplyScalar(scalar) {
		return this.x *= scalar, this.y *= scalar, this.z *= scalar, this.w *= scalar, this
	}
	applyMatrix4(m) {
		let x = this.x,
			y = this.y,
			z = this.z,
			w = this.w,
			e = m.elements;
		return this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w, this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w, this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w, this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w, this
	}
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar)
	}
	setAxisAngleFromQuaternion(q) {
		this.w = 2 * Math.acos(q.w);
		let s = Math.sqrt(1 - q.w * q.w);
		return s < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = q.x / s, this.y = q.y / s, this.z = q.z / s), this
	}
	setAxisAngleFromRotationMatrix(m) {
		let angle, x, y, z;
		let te = m.elements,
			m11 = te[0],
			m12 = te[4],
			m13 = te[8],
			m21 = te[1],
			m22 = te[5],
			m23 = te[9],
			m31 = te[2],
			m32 = te[6],
			m33 = te[10];
		if (.01 > Math.abs(m12 - m21) && .01 > Math.abs(m13 - m31) && .01 > Math.abs(m23 - m32)) {
			if (.1 > Math.abs(m12 + m21) && .1 > Math.abs(m13 + m31) && .1 > Math.abs(m23 + m32) && .1 > Math.abs(m11 + m22 + m33 - 3)) return this.set(1, 0, 0, 0), this;
			angle = Math.PI;
			let xx = (m11 + 1) / 2,
				yy = (m22 + 1) / 2,
				zz = (m33 + 1) / 2,
				xy = (m12 + m21) / 4,
				xz = (m13 + m31) / 4,
				yz = (m23 + m32) / 4;
			return xx > yy && xx > zz ? xx < .01 ? (x = 0, y = .707106781, z = .707106781) : (y = xy / (x = Math.sqrt(xx)), z = xz / x) : yy > zz ? yy < .01 ? (x = .707106781, y = 0, z = .707106781) : (x = xy / (y = Math.sqrt(yy)), z = yz / y) : zz < .01 ? (x = .707106781, y = .707106781, z = 0) : (x = xz / (z = Math.sqrt(zz)), y = yz / z), this.set(x, y, z, angle), this
		}
		let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
		return .001 > Math.abs(s) && (s = 1), this.x = (m32 - m23) / s, this.y = (m13 - m31) / s, this.z = (m21 - m12) / s, this.w = Math.acos((m11 + m22 + m33 - 1) / 2), this
	}
	min(v) {
		return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), this.w = Math.min(this.w, v.w), this
	}
	max(v) {
		return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), this.w = Math.max(this.w, v.w), this
	}
	clamp(min, max) {
		return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), this.z = Math.max(min.z, Math.min(max.z, this.z)), this.w = Math.max(min.w, Math.min(max.w, this.w)), this
	}
	clampScalar(minVal, maxVal) {
		return this.x = Math.max(minVal, Math.min(maxVal, this.x)), this.y = Math.max(minVal, Math.min(maxVal, this.y)), this.z = Math.max(minVal, Math.min(maxVal, this.z)), this.w = Math.max(minVal, Math.min(maxVal, this.w)), this
	}
	clampLength(min, max) {
		let length = this.length();
		return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
	}
	roundToZero() {
		return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
	}
	dot(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	setLength(length) {
		return this.normalize().multiplyScalar(length)
	}
	lerp(v, alpha) {
		return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha, this.w += (v.w - this.w) * alpha, this
	}
	lerpVectors(v1, v2, alpha) {
		return this.x = v1.x + (v2.x - v1.x) * alpha, this.y = v1.y + (v2.y - v1.y) * alpha, this.z = v1.z + (v2.z - v1.z) * alpha, this.w = v1.w + (v2.w - v1.w) * alpha, this
	}
	equals(v) {
		return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w
	}
	fromArray(array, offset = 0) {
		return this.x = array[offset], this.y = array[offset + 1], this.z = array[offset + 2], this.w = array[offset + 3], this
	}
	toArray(array = [], offset = 0) {
		return array[offset] = this.x, array[offset + 1] = this.y, array[offset + 2] = this.z, array[offset + 3] = this.w, array
	}
	fromBufferAttribute(attribute, index) {
		return this.x = attribute.getX(index), this.y = attribute.getY(index), this.z = attribute.getZ(index), this.w = attribute.getW(index), this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z, yield this.w
	}
}
class RenderTarget extends EventDispatcher {
	constructor(width = 1, height = 1, options = {}) {
		super(), this.isRenderTarget = !0, this.width = width, this.height = height, this.depth = 1, this.scissor = new Vector4(0, 0, width, height), this.scissorTest = !1, this.viewport = new Vector4(0, 0, width, height), void 0 !== options.encoding && (warnOnce("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), options.colorSpace = 3001 === options.encoding ? SRGBColorSpace : ""), options = Object.assign({
			generateMipmaps: !1,
			internalFormat: null,
			minFilter: 1006,
			depthBuffer: !0,
			stencilBuffer: !1,
			depthTexture: null,
			samples: 0
		}, options), this.texture = new Texture$1({
			width: width,
			height: height,
			depth: 1
		}, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = options.generateMipmaps, this.texture.internalFormat = options.internalFormat, this.depthBuffer = options.depthBuffer, this.stencilBuffer = options.stencilBuffer, this.depthTexture = options.depthTexture, this.samples = options.samples
	}
	setSize(width, height, depth = 1) {
		(this.width !== width || this.height !== height || this.depth !== depth) && (this.width = width, this.height = height, this.depth = depth, this.texture.image.width = width, this.texture.image.height = height, this.texture.image.depth = depth, this.dispose()), this.viewport.set(0, 0, width, height), this.scissor.set(0, 0, width, height)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(source) {
		this.width = source.width, this.height = source.height, this.depth = source.depth, this.scissor.copy(source.scissor), this.scissorTest = source.scissorTest, this.viewport.copy(source.viewport), this.texture = source.texture.clone(), this.texture.isRenderTargetTexture = !0;
		let image = Object.assign({}, source.texture.image);
		return this.texture.source = new Source(image), this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, null !== source.depthTexture && (this.depthTexture = source.depthTexture.clone()), this.samples = source.samples, this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
class WebGLRenderTarget extends RenderTarget {
	constructor(width = 1, height = 1, options = {}) {
		super(width, height, options), this.isWebGLRenderTarget = !0
	}
}
class DataArrayTexture extends Texture$1 {
	constructor(data = null, width = 1, height = 1, depth = 1) {
		super(null), this.isDataArrayTexture = !0, this.image = {
			data,
			width,
			height,
			depth
		}, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
	}
}
class Data3DTexture extends Texture$1 {
	constructor(data = null, width = 1, height = 1, depth = 1) {
		super(null), this.isData3DTexture = !0, this.image = {
			data,
			width,
			height,
			depth
		}, this.magFilter = NearestFilter, this.minFilter = NearestFilter, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
	}
}
class Quaternion {
	constructor(x = 0, y = 0, z = 0, w = 1) {
		this.isQuaternion = !0, this._x = x, this._y = y, this._z = z, this._w = w
	}
	static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
		let x0 = src0[srcOffset0 + 0],
			y0 = src0[srcOffset0 + 1],
			z0 = src0[srcOffset0 + 2],
			w0 = src0[srcOffset0 + 3],
			x1 = src1[srcOffset1 + 0],
			y1 = src1[srcOffset1 + 1],
			z1 = src1[srcOffset1 + 2],
			w1 = src1[srcOffset1 + 3];
		if (0 === t) {
			dst[dstOffset + 0] = x0, dst[dstOffset + 1] = y0, dst[dstOffset + 2] = z0, dst[dstOffset + 3] = w0;
			return
		}
		if (1 === t) {
			dst[dstOffset + 0] = x1, dst[dstOffset + 1] = y1, dst[dstOffset + 2] = z1, dst[dstOffset + 3] = w1;
			return
		}
		if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
			let s = 1 - t,
				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = cos >= 0 ? 1 : -1,
				sqrSin = 1 - cos * cos;
			if (sqrSin > Number.EPSILON) {
				let sin = Math.sqrt(sqrSin),
					len = Math.atan2(sin, cos * dir);
				s = Math.sin(s * len) / sin, t = Math.sin(t * len) / sin
			}
			let tDir = t * dir;
			if (x0 = x0 * s + x1 * tDir, y0 = y0 * s + y1 * tDir, z0 = z0 * s + z1 * tDir, w0 = w0 * s + w1 * tDir, s === 1 - t) {
				let f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
				x0 *= f, y0 *= f, z0 *= f, w0 *= f
			}
		}
		dst[dstOffset] = x0, dst[dstOffset + 1] = y0, dst[dstOffset + 2] = z0, dst[dstOffset + 3] = w0
	}
	static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
		let x0 = src0[srcOffset0],
			y0 = src0[srcOffset0 + 1],
			z0 = src0[srcOffset0 + 2],
			w0 = src0[srcOffset0 + 3],
			x1 = src1[srcOffset1],
			y1 = src1[srcOffset1 + 1],
			z1 = src1[srcOffset1 + 2],
			w1 = src1[srcOffset1 + 3];
		return dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1, dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1, dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1, dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1, dst
	}
	get x() {
		return this._x
	}
	set x(value) {
		this._x = value, this._onChangeCallback()
	}
	get y() {
		return this._y
	}
	set y(value) {
		this._y = value, this._onChangeCallback()
	}
	get z() {
		return this._z
	}
	set z(value) {
		this._z = value, this._onChangeCallback()
	}
	get w() {
		return this._w
	}
	set w(value) {
		this._w = value, this._onChangeCallback()
	}
	set(x, y, z, w) {
		return this._x = x, this._y = y, this._z = z, this._w = w, this._onChangeCallback(), this
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._w)
	}
	copy(quaternion) {
		return this._x = quaternion.x, this._y = quaternion.y, this._z = quaternion.z, this._w = quaternion.w, this._onChangeCallback(), this
	}
	setFromEuler(euler, update = !0) {
		let x = euler._x,
			y = euler._y,
			z = euler._z,
			order = euler._order,
			cos = Math.cos,
			sin = Math.sin,
			c1 = cos(x / 2),
			c2 = cos(y / 2),
			c3 = cos(z / 2),
			s1 = sin(x / 2),
			s2 = sin(y / 2),
			s3 = sin(z / 2);
		switch (order) {
			case "XYZ":
				this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;
			case "YXZ":
				this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;
			case "ZXY":
				this._x = s1 * c2 * c3 - c1 * s2 * s3, this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;
			case "ZYX":
				this._x = s1 * c2 * c3 - c1 * s2 * s3, this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;
			case "YZX":
				this._x = s1 * c2 * c3 + c1 * s2 * s3, this._y = c1 * s2 * c3 + s1 * c2 * s3, this._z = c1 * c2 * s3 - s1 * s2 * c3, this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;
			case "XZY":
				this._x = s1 * c2 * c3 - c1 * s2 * s3, this._y = c1 * s2 * c3 - s1 * c2 * s3, this._z = c1 * c2 * s3 + s1 * s2 * c3, this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;
			default:
				console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order)
		}
		return !0 === update && this._onChangeCallback(), this
	}
	setFromAxisAngle(axis, angle) {
		let halfAngle = angle / 2,
			s = Math.sin(halfAngle);
		return this._x = axis.x * s, this._y = axis.y * s, this._z = axis.z * s, this._w = Math.cos(halfAngle), this._onChangeCallback(), this
	}
	setFromRotationMatrix(m) {
		let te = m.elements,
			m11 = te[0],
			m12 = te[4],
			m13 = te[8],
			m21 = te[1],
			m22 = te[5],
			m23 = te[9],
			m31 = te[2],
			m32 = te[6],
			m33 = te[10],
			trace = m11 + m22 + m33;
		if (trace > 0) {
			let s = .5 / Math.sqrt(trace + 1);
			this._w = .25 / s, this._x = (m32 - m23) * s, this._y = (m13 - m31) * s, this._z = (m21 - m12) * s
		} else if (m11 > m22 && m11 > m33) {
			let s = 2 * Math.sqrt(1 + m11 - m22 - m33);
			this._w = (m32 - m23) / s, this._x = .25 * s, this._y = (m12 + m21) / s, this._z = (m13 + m31) / s
		} else if (m22 > m33) {
			let s = 2 * Math.sqrt(1 + m22 - m11 - m33);
			this._w = (m13 - m31) / s, this._x = (m12 + m21) / s, this._y = .25 * s, this._z = (m23 + m32) / s
		} else {
			let s = 2 * Math.sqrt(1 + m33 - m11 - m22);
			this._w = (m21 - m12) / s, this._x = (m13 + m31) / s, this._y = (m23 + m32) / s, this._z = .25 * s
		}
		return this._onChangeCallback(), this
	}
	setFromUnitVectors(vFrom, vTo) {
		let r = vFrom.dot(vTo) + 1;
		return r < Number.EPSILON ? (r = 0, Math.abs(vFrom.x) > Math.abs(vFrom.z) ? (this._x = -vFrom.y, this._y = vFrom.x, this._z = 0) : (this._x = 0, this._y = -vFrom.z, this._z = vFrom.y)) : (this._x = vFrom.y * vTo.z - vFrom.z * vTo.y, this._y = vFrom.z * vTo.x - vFrom.x * vTo.z, this._z = vFrom.x * vTo.y - vFrom.y * vTo.x), this._w = r, this.normalize()
	}
	angleTo(q) {
		return 2 * Math.acos(Math.abs(clamp$1(this.dot(q), -1, 1)))
	}
	rotateTowards(q, step) {
		let angle = this.angleTo(q);
		return 0 === angle || this.slerp(q, Math.min(1, step / angle)), this
	}
	identity() {
		return this.set(0, 0, 0, 1)
	}
	invert() {
		return this.conjugate()
	}
	conjugate() {
		return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
	}
	dot(v) {
		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w
	}
	lengthSq() {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
	}
	length() {
		return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
	}
	normalize() {
		let l = this.length();
		return 0 === l ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (l = 1 / l, this._x = this._x * l, this._y = this._y * l, this._z = this._z * l, this._w = this._w * l), this._onChangeCallback(), this
	}
	multiply(q) {
		return this.multiplyQuaternions(this, q)
	}
	premultiply(q) {
		return this.multiplyQuaternions(q, this)
	}
	multiplyQuaternions(a, b) {
		let qax = a._x,
			qay = a._y,
			qaz = a._z,
			qaw = a._w,
			qbx = b._x,
			qby = b._y,
			qbz = b._z,
			qbw = b._w;
		return this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby, this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz, this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx, this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz, this._onChangeCallback(), this
	}
	slerp(qb, t) {
		if (0 === t) return this;
		if (1 === t) return this.copy(qb);
		let x = this._x,
			y = this._y,
			z = this._z,
			w = this._w,
			cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
		if (cosHalfTheta < 0 ? (this._w = -qb._w, this._x = -qb._x, this._y = -qb._y, this._z = -qb._z, cosHalfTheta = -cosHalfTheta) : this.copy(qb), cosHalfTheta >= 1) return this._w = w, this._x = x, this._y = y, this._z = z, this;
		let sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
		if (sqrSinHalfTheta <= Number.EPSILON) {
			let s = 1 - t;
			return this._w = s * w + t * this._w, this._x = s * x + t * this._x, this._y = s * y + t * this._y, this._z = s * z + t * this._z, this.normalize(), this
		}
		let sinHalfTheta = Math.sqrt(sqrSinHalfTheta),
			halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta),
			ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
			ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
		return this._w = w * ratioA + this._w * ratioB, this._x = x * ratioA + this._x * ratioB, this._y = y * ratioA + this._y * ratioB, this._z = z * ratioA + this._z * ratioB, this._onChangeCallback(), this
	}
	slerpQuaternions(qa, qb, t) {
		return this.copy(qa).slerp(qb, t)
	}
	random() {
		let u1 = Math.random(),
			sqrt1u1 = Math.sqrt(1 - u1),
			sqrtu1 = Math.sqrt(u1),
			u2 = 2 * Math.PI * Math.random(),
			u3 = 2 * Math.PI * Math.random();
		return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2))
	}
	equals(quaternion) {
		return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w
	}
	fromArray(array, offset = 0) {
		return this._x = array[offset], this._y = array[offset + 1], this._z = array[offset + 2], this._w = array[offset + 3], this._onChangeCallback(), this
	}
	toArray(array = [], offset = 0) {
		return array[offset] = this._x, array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._w, array
	}
	fromBufferAttribute(attribute, index) {
		return this._x = attribute.getX(index), this._y = attribute.getY(index), this._z = attribute.getZ(index), this._w = attribute.getW(index), this._onChangeCallback(), this
	}
	toJSON() {
		return this.toArray()
	}
	_onChange(callback) {
		return this._onChangeCallback = callback, this
	}
	_onChangeCallback() {}*[Symbol.iterator]() {
		yield this._x, yield this._y, yield this._z, yield this._w
	}
}
class Vector3 {
	constructor(x = 0, y = 0, z = 0) {
		Vector3.prototype.isVector3 = !0, this.x = x, this.y = y, this.z = z
	}
	set(x, y, z) {
		return void 0 === z && (z = this.z), this.x = x, this.y = y, this.z = z, this
	}
	setScalar(scalar) {
		return this.x = scalar, this.y = scalar, this.z = scalar, this
	}
	setX(x) {
		return this.x = x, this
	}
	setY(y) {
		return this.y = y, this
	}
	setZ(z) {
		return this.z = z, this
	}
	setComponent(index, value) {
		switch (index) {
			case 0:
				this.x = value;
				break;
			case 1:
				this.y = value;
				break;
			case 2:
				this.z = value;
				break;
			default:
				throw Error("index is out of range: " + index)
		}
		return this
	}
	getComponent(index) {
		switch (index) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			default:
				throw Error("index is out of range: " + index)
		}
	}
	clone() {
		return new this.constructor(this.x, this.y, this.z)
	}
	copy(v) {
		return this.x = v.x, this.y = v.y, this.z = v.z, this
	}
	add(v) {
		return this.x += v.x, this.y += v.y, this.z += v.z, this
	}
	addScalar(s) {
		return this.x += s, this.y += s, this.z += s, this
	}
	addVectors(a, b) {
		return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
	}
	addScaledVector(v, s) {
		return this.x += v.x * s, this.y += v.y * s, this.z += v.z * s, this
	}
	sub(v) {
		return this.x -= v.x, this.y -= v.y, this.z -= v.z, this
	}
	subScalar(s) {
		return this.x -= s, this.y -= s, this.z -= s, this
	}
	subVectors(a, b) {
		return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
	}
	multiply(v) {
		return this.x *= v.x, this.y *= v.y, this.z *= v.z, this
	}
	multiplyScalar(scalar) {
		return this.x *= scalar, this.y *= scalar, this.z *= scalar, this
	}
	multiplyVectors(a, b) {
		return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
	}
	applyEuler(euler) {
		return this.applyQuaternion(_quaternion$4.setFromEuler(euler))
	}
	applyAxisAngle(axis, angle) {
		return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle))
	}
	applyMatrix3(m) {
		let x = this.x,
			y = this.y,
			z = this.z,
			e = m.elements;
		return this.x = e[0] * x + e[3] * y + e[6] * z, this.y = e[1] * x + e[4] * y + e[7] * z, this.z = e[2] * x + e[5] * y + e[8] * z, this
	}
	applyNormalMatrix(m) {
		return this.applyMatrix3(m).normalize()
	}
	applyMatrix4(m) {
		let x = this.x,
			y = this.y,
			z = this.z,
			e = m.elements,
			w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
		return this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w, this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w, this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w, this
	}
	applyQuaternion(q) {
		let vx = this.x,
			vy = this.y,
			vz = this.z,
			qx = q.x,
			qy = q.y,
			qz = q.z,
			qw = q.w,
			tx = 2 * (qy * vz - qz * vy),
			ty = 2 * (qz * vx - qx * vz),
			tz = 2 * (qx * vy - qy * vx);
		return this.x = vx + qw * tx + qy * tz - qz * ty, this.y = vy + qw * ty + qz * tx - qx * tz, this.z = vz + qw * tz + qx * ty - qy * tx, this
	}
	project(camera) {
		return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix)
	}
	unproject(camera) {
		return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld)
	}
	transformDirection(m) {
		let x = this.x,
			y = this.y,
			z = this.z,
			e = m.elements;
		return this.x = e[0] * x + e[4] * y + e[8] * z, this.y = e[1] * x + e[5] * y + e[9] * z, this.z = e[2] * x + e[6] * y + e[10] * z, this.normalize()
	}
	divide(v) {
		return this.x /= v.x, this.y /= v.y, this.z /= v.z, this
	}
	divideScalar(scalar) {
		return this.multiplyScalar(1 / scalar)
	}
	min(v) {
		return this.x = Math.min(this.x, v.x), this.y = Math.min(this.y, v.y), this.z = Math.min(this.z, v.z), this
	}
	max(v) {
		return this.x = Math.max(this.x, v.x), this.y = Math.max(this.y, v.y), this.z = Math.max(this.z, v.z), this
	}
	clamp(min, max) {
		return this.x = Math.max(min.x, Math.min(max.x, this.x)), this.y = Math.max(min.y, Math.min(max.y, this.y)), this.z = Math.max(min.z, Math.min(max.z, this.z)), this
	}
	clampScalar(minVal, maxVal) {
		return this.x = Math.max(minVal, Math.min(maxVal, this.x)), this.y = Math.max(minVal, Math.min(maxVal, this.y)), this.z = Math.max(minVal, Math.min(maxVal, this.z)), this
	}
	clampLength(min, max) {
		let length = this.length();
		return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
	}
	floor() {
		return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
	}
	ceil() {
		return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
	}
	round() {
		return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
	}
	roundToZero() {
		return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
	}
	negate() {
		return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
	}
	dot(v) {
		return this.x * v.x + this.y * v.y + this.z * v.z
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
	}
	manhattanLength() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
	}
	normalize() {
		return this.divideScalar(this.length() || 1)
	}
	setLength(length) {
		return this.normalize().multiplyScalar(length)
	}
	lerp(v, alpha) {
		return this.x += (v.x - this.x) * alpha, this.y += (v.y - this.y) * alpha, this.z += (v.z - this.z) * alpha, this
	}
	lerpVectors(v1, v2, alpha) {
		return this.x = v1.x + (v2.x - v1.x) * alpha, this.y = v1.y + (v2.y - v1.y) * alpha, this.z = v1.z + (v2.z - v1.z) * alpha, this
	}
	cross(v) {
		return this.crossVectors(this, v)
	}
	crossVectors(a, b) {
		let ax = a.x,
			ay = a.y,
			az = a.z,
			bx = b.x,
			by = b.y,
			bz = b.z;
		return this.x = ay * bz - az * by, this.y = az * bx - ax * bz, this.z = ax * by - ay * bx, this
	}
	projectOnVector(v) {
		let denominator = v.lengthSq();
		if (0 === denominator) return this.set(0, 0, 0);
		let scalar = v.dot(this) / denominator;
		return this.copy(v).multiplyScalar(scalar)
	}
	projectOnPlane(planeNormal) {
		return _vector$c.copy(this).projectOnVector(planeNormal), this.sub(_vector$c)
	}
	reflect(normal) {
		return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)))
	}
	angleTo(v) {
		let denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
		return 0 === denominator ? Math.PI / 2 : Math.acos(clamp$1(this.dot(v) / denominator, -1, 1))
	}
	distanceTo(v) {
		return Math.sqrt(this.distanceToSquared(v))
	}
	distanceToSquared(v) {
		let dx = this.x - v.x,
			dy = this.y - v.y,
			dz = this.z - v.z;
		return dx * dx + dy * dy + dz * dz
	}
	manhattanDistanceTo(v) {
		return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
	}
	setFromSpherical(s) {
		return this.setFromSphericalCoords(s.radius, s.phi, s.theta)
	}
	setFromSphericalCoords(radius, phi, theta) {
		let sinPhiRadius = Math.sin(phi) * radius;
		return this.x = sinPhiRadius * Math.sin(theta), this.y = Math.cos(phi) * radius, this.z = sinPhiRadius * Math.cos(theta), this
	}
	setFromCylindrical(c) {
		return this.setFromCylindricalCoords(c.radius, c.theta, c.y)
	}
	setFromCylindricalCoords(radius, theta, y) {
		return this.x = radius * Math.sin(theta), this.y = y, this.z = radius * Math.cos(theta), this
	}
	setFromMatrixPosition(m) {
		let e = m.elements;
		return this.x = e[12], this.y = e[13], this.z = e[14], this
	}
	setFromMatrixScale(m) {
		let sx = this.setFromMatrixColumn(m, 0).length(),
			sy = this.setFromMatrixColumn(m, 1).length(),
			sz = this.setFromMatrixColumn(m, 2).length();
		return this.x = sx, this.y = sy, this.z = sz, this
	}
	setFromMatrixColumn(m, index) {
		return this.fromArray(m.elements, 4 * index)
	}
	setFromMatrix3Column(m, index) {
		return this.fromArray(m.elements, 3 * index)
	}
	setFromEuler(e) {
		return this.x = e._x, this.y = e._y, this.z = e._z, this
	}
	setFromColor(c) {
		return this.x = c.r, this.y = c.g, this.z = c.b, this
	}
	equals(v) {
		return v.x === this.x && v.y === this.y && v.z === this.z
	}
	fromArray(array, offset = 0) {
		return this.x = array[offset], this.y = array[offset + 1], this.z = array[offset + 2], this
	}
	toArray(array = [], offset = 0) {
		return array[offset] = this.x, array[offset + 1] = this.y, array[offset + 2] = this.z, array
	}
	fromBufferAttribute(attribute, index) {
		return this.x = attribute.getX(index), this.y = attribute.getY(index), this.z = attribute.getZ(index), this
	}
	random() {
		return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
	}
	randomDirection() {
		let u = (Math.random() - .5) * 2,
			t = Math.random() * Math.PI * 2,
			f = Math.sqrt(1 - u ** 2);
		return this.x = f * Math.cos(t), this.y = f * Math.sin(t), this.z = u, this
	}*[Symbol.iterator]() {
		yield this.x, yield this.y, yield this.z
	}
}
let _vector$c = new Vector3,
	_quaternion$4 = new Quaternion;
class Box3 {
	constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-1 / 0, -1 / 0, -1 / 0)) {
		this.isBox3 = !0, this.min = min, this.max = max
	}
	set(min, max) {
		return this.min.copy(min), this.max.copy(max), this
	}
	setFromArray(array) {
		this.makeEmpty();
		for (let i = 0, il = array.length; i < il; i += 3) this.expandByPoint(_vector$b.fromArray(array, i));
		return this
	}
	setFromBufferAttribute(attribute) {
		this.makeEmpty();
		for (let i = 0, il = attribute.count; i < il; i++) this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
		return this
	}
	setFromPoints(points) {
		this.makeEmpty();
		for (let i = 0, il = points.length; i < il; i++) this.expandByPoint(points[i]);
		return this
	}
	setFromCenterAndSize(center, size) {
		let halfSize = _vector$b.copy(size).multiplyScalar(.5);
		return this.min.copy(center).sub(halfSize), this.max.copy(center).add(halfSize), this
	}
	setFromObject(object, precise = !1) {
		return this.makeEmpty(), this.expandByObject(object, precise)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(box) {
		return this.min.copy(box.min), this.max.copy(box.max), this
	}
	makeEmpty() {
		return this.min.x = this.min.y = this.min.z = Infinity, this.max.x = this.max.y = this.max.z = -1 / 0, this
	}
	isEmpty() {
		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
	}
	getCenter(target) {
		return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(.5)
	}
	getSize(target) {
		return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min)
	}
	expandByPoint(point) {
		return this.min.min(point), this.max.max(point), this
	}
	expandByVector(vector) {
		return this.min.sub(vector), this.max.add(vector), this
	}
	expandByScalar(scalar) {
		return this.min.addScalar(-scalar), this.max.addScalar(scalar), this
	}
	expandByObject(object, precise = !1) {
		object.updateWorldMatrix(!1, !1);
		let geometry = object.geometry;
		if (void 0 !== geometry) {
			let positionAttribute = geometry.getAttribute("position");
			if (!0 === precise && void 0 !== positionAttribute && !0 !== object.isInstancedMesh)
				for (let i = 0, l = positionAttribute.count; i < l; i++) !0 === object.isMesh ? object.getVertexPosition(i, _vector$b) : _vector$b.fromBufferAttribute(positionAttribute, i), _vector$b.applyMatrix4(object.matrixWorld), this.expandByPoint(_vector$b);
			else void 0 !== object.boundingBox ? (null === object.boundingBox && object.computeBoundingBox(), _box$4.copy(object.boundingBox)) : (null === geometry.boundingBox && geometry.computeBoundingBox(), _box$4.copy(geometry.boundingBox)), _box$4.applyMatrix4(object.matrixWorld), this.union(_box$4)
		}
		let children = object.children;
		for (let i = 0, l = children.length; i < l; i++) this.expandByObject(children[i], precise);
		return this
	}
	containsPoint(point) {
		return !(point.x < this.min.x) && !(point.x > this.max.x) && !(point.y < this.min.y) && !(point.y > this.max.y) && !(point.z < this.min.z) && !(point.z > this.max.z)
	}
	containsBox(box) {
		return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z
	}
	getParameter(point, target) {
		return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z))
	}
	intersectsBox(box) {
		return !(box.max.x < this.min.x) && !(box.min.x > this.max.x) && !(box.max.y < this.min.y) && !(box.min.y > this.max.y) && !(box.max.z < this.min.z) && !(box.min.z > this.max.z)
	}
	intersectsSphere(sphere) {
		return this.clampPoint(sphere.center, _vector$b), _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius
	}
	intersectsPlane(plane) {
		let min, max;
		return plane.normal.x > 0 ? (min = plane.normal.x * this.min.x, max = plane.normal.x * this.max.x) : (min = plane.normal.x * this.max.x, max = plane.normal.x * this.min.x), plane.normal.y > 0 ? (min += plane.normal.y * this.min.y, max += plane.normal.y * this.max.y) : (min += plane.normal.y * this.max.y, max += plane.normal.y * this.min.y), plane.normal.z > 0 ? (min += plane.normal.z * this.min.z, max += plane.normal.z * this.max.z) : (min += plane.normal.z * this.max.z, max += plane.normal.z * this.min.z), min <= -plane.constant && max >= -plane.constant
	}
	intersectsTriangle(triangle) {
		if (this.isEmpty()) return !1;
		this.getCenter(_center), _extents.subVectors(this.max, _center), _v0$2.subVectors(triangle.a, _center), _v1$7.subVectors(triangle.b, _center), _v2$4.subVectors(triangle.c, _center), _f0.subVectors(_v1$7, _v0$2), _f1.subVectors(_v2$4, _v1$7), _f2.subVectors(_v0$2, _v2$4);
		let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
		return !!(satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents) && satForAxes(axes = [1, 0, 0, 0, 1, 0, 0, 0, 1], _v0$2, _v1$7, _v2$4, _extents)) && (_triangleNormal.crossVectors(_f0, _f1), satForAxes(axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z], _v0$2, _v1$7, _v2$4, _extents))
	}
	clampPoint(point, target) {
		return target.copy(point).clamp(this.min, this.max)
	}
	distanceToPoint(point) {
		return this.clampPoint(point, _vector$b).distanceTo(point)
	}
	getBoundingSphere(target) {
		return this.isEmpty() ? target.makeEmpty() : (this.getCenter(target.center), target.radius = .5 * this.getSize(_vector$b).length()), target
	}
	intersect(box) {
		return this.min.max(box.min), this.max.min(box.max), this.isEmpty() && this.makeEmpty(), this
	}
	union(box) {
		return this.min.min(box.min), this.max.max(box.max), this
	}
	applyMatrix4(matrix) {
		return this.isEmpty() || (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix), _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix), _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix), _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix), _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix), _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix), _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix), _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix), this.setFromPoints(_points)), this
	}
	translate(offset) {
		return this.min.add(offset), this.max.add(offset), this
	}
	equals(box) {
		return box.min.equals(this.min) && box.max.equals(this.max)
	}
}
let _points = [new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3, new Vector3],
	_vector$b = new Vector3,
	_box$4 = new Box3,
	_v0$2 = new Vector3,
	_v1$7 = new Vector3,
	_v2$4 = new Vector3,
	_f0 = new Vector3,
	_f1 = new Vector3,
	_f2 = new Vector3,
	_center = new Vector3,
	_extents = new Vector3,
	_triangleNormal = new Vector3,
	_testAxis = new Vector3;

function satForAxes(axes, v0, v1, v2, extents) {
	for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
		_testAxis.fromArray(axes, i);
		let r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z),
			p0 = v0.dot(_testAxis),
			p1 = v1.dot(_testAxis),
			p2 = v2.dot(_testAxis);
		if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) return !1
	}
	return !0
}
let _box$3 = new Box3,
	_v1$6 = new Vector3,
	_v2$3 = new Vector3;
class Sphere {
	constructor(center = new Vector3, radius = -1) {
		this.isSphere = !0, this.center = center, this.radius = radius
	}
	set(center, radius) {
		return this.center.copy(center), this.radius = radius, this
	}
	setFromPoints(points, optionalCenter) {
		let center = this.center;
		void 0 !== optionalCenter ? center.copy(optionalCenter) : _box$3.setFromPoints(points).getCenter(center);
		let maxRadiusSq = 0;
		for (let i = 0, il = points.length; i < il; i++) maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
		return this.radius = Math.sqrt(maxRadiusSq), this
	}
	copy(sphere) {
		return this.center.copy(sphere.center), this.radius = sphere.radius, this
	}
	isEmpty() {
		return this.radius < 0
	}
	makeEmpty() {
		return this.center.set(0, 0, 0), this.radius = -1, this
	}
	containsPoint(point) {
		return point.distanceToSquared(this.center) <= this.radius * this.radius
	}
	distanceToPoint(point) {
		return point.distanceTo(this.center) - this.radius
	}
	intersectsSphere(sphere) {
		let radiusSum = this.radius + sphere.radius;
		return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
	}
	intersectsBox(box) {
		return box.intersectsSphere(this)
	}
	intersectsPlane(plane) {
		return Math.abs(plane.distanceToPoint(this.center)) <= this.radius
	}
	clampPoint(point, target) {
		let deltaLengthSq = this.center.distanceToSquared(point);
		return target.copy(point), deltaLengthSq > this.radius * this.radius && (target.sub(this.center).normalize(), target.multiplyScalar(this.radius).add(this.center)), target
	}
	getBoundingBox(target) {
		return this.isEmpty() ? target.makeEmpty() : (target.set(this.center, this.center), target.expandByScalar(this.radius)), target
	}
	applyMatrix4(matrix) {
		return this.center.applyMatrix4(matrix), this.radius = this.radius * matrix.getMaxScaleOnAxis(), this
	}
	translate(offset) {
		return this.center.add(offset), this
	}
	expandByPoint(point) {
		if (this.isEmpty()) return this.center.copy(point), this.radius = 0, this;
		_v1$6.subVectors(point, this.center);
		let lengthSq = _v1$6.lengthSq();
		if (lengthSq > this.radius * this.radius) {
			let length = Math.sqrt(lengthSq),
				delta = (length - this.radius) * .5;
			this.center.addScaledVector(_v1$6, delta / length), this.radius += delta
		}
		return this
	}
	union(sphere) {
		return sphere.isEmpty() || (this.isEmpty() ? this.copy(sphere) : !0 === this.center.equals(sphere.center) ? this.radius = Math.max(this.radius, sphere.radius) : (_v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius), this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3)), this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3)))), this
	}
	equals(sphere) {
		return sphere.center.equals(this.center) && sphere.radius === this.radius
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
let _vector$a = new Vector3,
	_segCenter = new Vector3,
	_segDir = new Vector3,
	_diff = new Vector3,
	_edge1 = new Vector3,
	_edge2 = new Vector3,
	_normal$1 = new Vector3;
class Ray {
	constructor(origin = new Vector3, direction = new Vector3(0, 0, -1)) {
		this.origin = origin, this.direction = direction
	}
	set(origin, direction) {
		return this.origin.copy(origin), this.direction.copy(direction), this
	}
	copy(ray) {
		return this.origin.copy(ray.origin), this.direction.copy(ray.direction), this
	}
	at(t, target) {
		return target.copy(this.origin).addScaledVector(this.direction, t)
	}
	lookAt(v) {
		return this.direction.copy(v).sub(this.origin).normalize(), this
	}
	recast(t) {
		return this.origin.copy(this.at(t, _vector$a)), this
	}
	closestPointToPoint(point, target) {
		target.subVectors(point, this.origin);
		let directionDistance = target.dot(this.direction);
		return directionDistance < 0 ? target.copy(this.origin) : target.copy(this.origin).addScaledVector(this.direction, directionDistance)
	}
	distanceToPoint(point) {
		return Math.sqrt(this.distanceSqToPoint(point))
	}
	distanceSqToPoint(point) {
		let directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
		return directionDistance < 0 ? this.origin.distanceToSquared(point) : (_vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance), _vector$a.distanceToSquared(point))
	}
	distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
		let s0, s1, sqrDist, extDet;
		_segCenter.copy(v0).add(v1).multiplyScalar(.5), _segDir.copy(v1).sub(v0).normalize(), _diff.copy(this.origin).sub(_segCenter);
		let segExtent = .5 * v0.distanceTo(v1),
			a01 = -this.direction.dot(_segDir),
			b0 = _diff.dot(this.direction),
			b1 = -_diff.dot(_segDir),
			c = _diff.lengthSq(),
			det = Math.abs(1 - a01 * a01);
		if (det > 0) {
			if (s0 = a01 * b1 - b0, s1 = a01 * b0 - b1, extDet = segExtent * det, s0 >= 0) {
				if (s1 >= -extDet) {
					if (s1 <= extDet) {
						let invDet = 1 / det;
						s0 *= invDet, s1 *= invDet, sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c
					} else sqrDist = -(s0 = Math.max(0, -(a01 * (s1 = segExtent) + b0))) * s0 + s1 * (s1 + 2 * b1) + c
				} else sqrDist = -(s0 = Math.max(0, -(a01 * (s1 = -segExtent) + b0))) * s0 + s1 * (s1 + 2 * b1) + c
			} else s1 <= -extDet ? (s1 = (s0 = Math.max(0, -(-a01 * segExtent + b0))) > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c) : s1 <= extDet ? (s0 = 0, sqrDist = (s1 = Math.min(Math.max(-segExtent, -b1), segExtent)) * (s1 + 2 * b1) + c) : (s1 = (s0 = Math.max(0, -(a01 * segExtent + b0))) > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent), sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c)
		} else s1 = a01 > 0 ? -segExtent : segExtent, sqrDist = -(s0 = Math.max(0, -(a01 * s1 + b0))) * s0 + s1 * (s1 + 2 * b1) + c;
		return optionalPointOnRay && optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0), optionalPointOnSegment && optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1), sqrDist
	}
	intersectSphere(sphere, target) {
		_vector$a.subVectors(sphere.center, this.origin);
		let tca = _vector$a.dot(this.direction),
			d2 = _vector$a.dot(_vector$a) - tca * tca,
			radius2 = sphere.radius * sphere.radius;
		if (d2 > radius2) return null;
		let thc = Math.sqrt(radius2 - d2),
			t0 = tca - thc,
			t1 = tca + thc;
		return t1 < 0 ? null : t0 < 0 ? this.at(t1, target) : this.at(t0, target)
	}
	intersectsSphere(sphere) {
		return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius
	}
	distanceToPlane(plane) {
		let denominator = plane.normal.dot(this.direction);
		if (0 === denominator) return 0 === plane.distanceToPoint(this.origin) ? 0 : null;
		let t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
		return t >= 0 ? t : null
	}
	intersectPlane(plane, target) {
		let t = this.distanceToPlane(plane);
		return null === t ? null : this.at(t, target)
	}
	intersectsPlane(plane) {
		let distToPoint = plane.distanceToPoint(this.origin);
		return !!(0 === distToPoint || plane.normal.dot(this.direction) * distToPoint < 0)
	}
	intersectBox(box, target) {
		let tmin, tmax, tymin, tymax, tzmin, tzmax;
		let invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z,
			origin = this.origin;
		return (invdirx >= 0 ? (tmin = (box.min.x - origin.x) * invdirx, tmax = (box.max.x - origin.x) * invdirx) : (tmin = (box.max.x - origin.x) * invdirx, tmax = (box.min.x - origin.x) * invdirx), invdiry >= 0 ? (tymin = (box.min.y - origin.y) * invdiry, tymax = (box.max.y - origin.y) * invdiry) : (tymin = (box.max.y - origin.y) * invdiry, tymax = (box.min.y - origin.y) * invdiry), tmin > tymax || tymin > tmax) ? null : ((tymin > tmin || isNaN(tmin)) && (tmin = tymin), (tymax < tmax || isNaN(tmax)) && (tmax = tymax), invdirz >= 0 ? (tzmin = (box.min.z - origin.z) * invdirz, tzmax = (box.max.z - origin.z) * invdirz) : (tzmin = (box.max.z - origin.z) * invdirz, tzmax = (box.min.z - origin.z) * invdirz), tmin > tzmax || tzmin > tmax) ? null : ((tzmin > tmin || tmin != tmin) && (tmin = tzmin), (tzmax < tmax || tmax != tmax) && (tmax = tzmax), tmax < 0) ? null : this.at(tmin >= 0 ? tmin : tmax, target)
	}
	intersectsBox(box) {
		return null !== this.intersectBox(box, _vector$a)
	}
	intersectTriangle(a, b, c, backfaceCulling, target) {
		let sign;
		_edge1.subVectors(b, a), _edge2.subVectors(c, a), _normal$1.crossVectors(_edge1, _edge2);
		let DdN = this.direction.dot(_normal$1);
		if (DdN > 0) {
			if (backfaceCulling) return null;
			sign = 1
		} else {
			if (!(DdN < 0)) return null;
			sign = -1, DdN = -DdN
		}
		_diff.subVectors(this.origin, a);
		let DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
		if (DdQxE2 < 0) return null;
		let DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
		if (DdE1xQ < 0 || DdQxE2 + DdE1xQ > DdN) return null;
		let QdN = -sign * _diff.dot(_normal$1);
		return QdN < 0 ? null : this.at(QdN / DdN, target)
	}
	applyMatrix4(matrix4) {
		return this.origin.applyMatrix4(matrix4), this.direction.transformDirection(matrix4), this
	}
	equals(ray) {
		return ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
class Matrix4 {
	constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
		Matrix4.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== n11 && this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44)
	}
	set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
		let te = this.elements;
		return te[0] = n11, te[4] = n12, te[8] = n13, te[12] = n14, te[1] = n21, te[5] = n22, te[9] = n23, te[13] = n24, te[2] = n31, te[6] = n32, te[10] = n33, te[14] = n34, te[3] = n41, te[7] = n42, te[11] = n43, te[15] = n44, this
	}
	identity() {
		return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
	}
	clone() {
		return new Matrix4().fromArray(this.elements)
	}
	copy(m) {
		let te = this.elements,
			me = m.elements;
		return te[0] = me[0], te[1] = me[1], te[2] = me[2], te[3] = me[3], te[4] = me[4], te[5] = me[5], te[6] = me[6], te[7] = me[7], te[8] = me[8], te[9] = me[9], te[10] = me[10], te[11] = me[11], te[12] = me[12], te[13] = me[13], te[14] = me[14], te[15] = me[15], this
	}
	copyPosition(m) {
		let te = this.elements,
			me = m.elements;
		return te[12] = me[12], te[13] = me[13], te[14] = me[14], this
	}
	setFromMatrix3(m) {
		let me = m.elements;
		return this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1), this
	}
	extractBasis(xAxis, yAxis, zAxis) {
		return xAxis.setFromMatrixColumn(this, 0), yAxis.setFromMatrixColumn(this, 1), zAxis.setFromMatrixColumn(this, 2), this
	}
	makeBasis(xAxis, yAxis, zAxis) {
		return this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1), this
	}
	extractRotation(m) {
		let te = this.elements,
			me = m.elements,
			scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length(),
			scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length(),
			scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
		return te[0] = me[0] * scaleX, te[1] = me[1] * scaleX, te[2] = me[2] * scaleX, te[3] = 0, te[4] = me[4] * scaleY, te[5] = me[5] * scaleY, te[6] = me[6] * scaleY, te[7] = 0, te[8] = me[8] * scaleZ, te[9] = me[9] * scaleZ, te[10] = me[10] * scaleZ, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1, this
	}
	makeRotationFromEuler(euler) {
		let te = this.elements,
			x = euler.x,
			y = euler.y,
			z = euler.z,
			a = Math.cos(x),
			b = Math.sin(x),
			c = Math.cos(y),
			d = Math.sin(y),
			e = Math.cos(z),
			f = Math.sin(z);
		if ("XYZ" === euler.order) {
			let ae = a * e,
				af = a * f,
				be = b * e,
				bf = b * f;
			te[0] = c * e, te[4] = -c * f, te[8] = d, te[1] = af + be * d, te[5] = ae - bf * d, te[9] = -b * c, te[2] = bf - ae * d, te[6] = be + af * d, te[10] = a * c
		} else if ("YXZ" === euler.order) {
			let ce = c * e,
				cf = c * f,
				de = d * e,
				df = d * f;
			te[0] = ce + df * b, te[4] = de * b - cf, te[8] = a * d, te[1] = a * f, te[5] = a * e, te[9] = -b, te[2] = cf * b - de, te[6] = df + ce * b, te[10] = a * c
		} else if ("ZXY" === euler.order) {
			let ce = c * e,
				cf = c * f,
				de = d * e,
				df = d * f;
			te[0] = ce - df * b, te[4] = -a * f, te[8] = de + cf * b, te[1] = cf + de * b, te[5] = a * e, te[9] = df - ce * b, te[2] = -a * d, te[6] = b, te[10] = a * c
		} else if ("ZYX" === euler.order) {
			let ae = a * e,
				af = a * f,
				be = b * e,
				bf = b * f;
			te[0] = c * e, te[4] = be * d - af, te[8] = ae * d + bf, te[1] = c * f, te[5] = bf * d + ae, te[9] = af * d - be, te[2] = -d, te[6] = b * c, te[10] = a * c
		} else if ("YZX" === euler.order) {
			let ac = a * c,
				ad = a * d,
				bc = b * c,
				bd = b * d;
			te[0] = c * e, te[4] = bd - ac * f, te[8] = bc * f + ad, te[1] = f, te[5] = a * e, te[9] = -b * e, te[2] = -d * e, te[6] = ad * f + bc, te[10] = ac - bd * f
		} else if ("XZY" === euler.order) {
			let ac = a * c,
				ad = a * d,
				bc = b * c,
				bd = b * d;
			te[0] = c * e, te[4] = -f, te[8] = d * e, te[1] = ac * f + bd, te[5] = a * e, te[9] = ad * f - bc, te[2] = bc * f - ad, te[6] = b * e, te[10] = bd * f + ac
		}
		return te[3] = 0, te[7] = 0, te[11] = 0, te[12] = 0, te[13] = 0, te[14] = 0, te[15] = 1, this
	}
	makeRotationFromQuaternion(q) {
		return this.compose(_zero, q, _one)
	}
	lookAt(eye, target, up) {
		let te = this.elements;
		return _z.subVectors(eye, target), 0 === _z.lengthSq() && (_z.z = 1), _z.normalize(), _x.crossVectors(up, _z), 0 === _x.lengthSq() && (1 === Math.abs(up.z) ? _z.x += 1e-4 : _z.z += 1e-4, _z.normalize(), _x.crossVectors(up, _z)), _x.normalize(), _y.crossVectors(_z, _x), te[0] = _x.x, te[4] = _y.x, te[8] = _z.x, te[1] = _x.y, te[5] = _y.y, te[9] = _z.y, te[2] = _x.z, te[6] = _y.z, te[10] = _z.z, this
	}
	multiply(m) {
		return this.multiplyMatrices(this, m)
	}
	premultiply(m) {
		return this.multiplyMatrices(m, this)
	}
	multiplyMatrices(a, b) {
		let ae = a.elements,
			be = b.elements,
			te = this.elements,
			a11 = ae[0],
			a12 = ae[4],
			a13 = ae[8],
			a14 = ae[12],
			a21 = ae[1],
			a22 = ae[5],
			a23 = ae[9],
			a24 = ae[13],
			a31 = ae[2],
			a32 = ae[6],
			a33 = ae[10],
			a34 = ae[14],
			a41 = ae[3],
			a42 = ae[7],
			a43 = ae[11],
			a44 = ae[15],
			b11 = be[0],
			b12 = be[4],
			b13 = be[8],
			b14 = be[12],
			b21 = be[1],
			b22 = be[5],
			b23 = be[9],
			b24 = be[13],
			b31 = be[2],
			b32 = be[6],
			b33 = be[10],
			b34 = be[14],
			b41 = be[3],
			b42 = be[7],
			b43 = be[11],
			b44 = be[15];
		return te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41, te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42, te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43, te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44, te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41, te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42, te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43, te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44, te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41, te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42, te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43, te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44, te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41, te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42, te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43, te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44, this
	}
	multiplyScalar(s) {
		let te = this.elements;
		return te[0] *= s, te[4] *= s, te[8] *= s, te[12] *= s, te[1] *= s, te[5] *= s, te[9] *= s, te[13] *= s, te[2] *= s, te[6] *= s, te[10] *= s, te[14] *= s, te[3] *= s, te[7] *= s, te[11] *= s, te[15] *= s, this
	}
	determinant() {
		let te = this.elements,
			n11 = te[0],
			n12 = te[4],
			n13 = te[8],
			n14 = te[12],
			n21 = te[1],
			n22 = te[5],
			n23 = te[9],
			n24 = te[13],
			n31 = te[2],
			n32 = te[6],
			n33 = te[10],
			n34 = te[14],
			n41 = te[3];
		return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + te[7] * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + te[11] * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + te[15] * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31)
	}
	transpose() {
		let tmp;
		let te = this.elements;
		return tmp = te[1], te[1] = te[4], te[4] = tmp, tmp = te[2], te[2] = te[8], te[8] = tmp, tmp = te[6], te[6] = te[9], te[9] = tmp, tmp = te[3], te[3] = te[12], te[12] = tmp, tmp = te[7], te[7] = te[13], te[13] = tmp, tmp = te[11], te[11] = te[14], te[14] = tmp, this
	}
	setPosition(x, y, z) {
		let te = this.elements;
		return x.isVector3 ? (te[12] = x.x, te[13] = x.y, te[14] = x.z) : (te[12] = x, te[13] = y, te[14] = z), this
	}
	invert() {
		let te = this.elements,
			n11 = te[0],
			n21 = te[1],
			n31 = te[2],
			n41 = te[3],
			n12 = te[4],
			n22 = te[5],
			n32 = te[6],
			n42 = te[7],
			n13 = te[8],
			n23 = te[9],
			n33 = te[10],
			n43 = te[11],
			n14 = te[12],
			n24 = te[13],
			n34 = te[14],
			n44 = te[15],
			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34,
			det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
		if (0 === det) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
		let detInv = 1 / det;
		return te[0] = t11 * detInv, te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv, te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv, te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv, te[4] = t12 * detInv, te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv, te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv, te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv, te[8] = t13 * detInv, te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv, te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv, te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv, te[12] = t14 * detInv, te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv, te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv, te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv, this
	}
	scale(v) {
		let te = this.elements,
			x = v.x,
			y = v.y,
			z = v.z;
		return te[0] *= x, te[4] *= y, te[8] *= z, te[1] *= x, te[5] *= y, te[9] *= z, te[2] *= x, te[6] *= y, te[10] *= z, te[3] *= x, te[7] *= y, te[11] *= z, this
	}
	getMaxScaleOnAxis() {
		let te = this.elements;
		return Math.sqrt(Math.max(te[0] * te[0] + te[1] * te[1] + te[2] * te[2], te[4] * te[4] + te[5] * te[5] + te[6] * te[6], te[8] * te[8] + te[9] * te[9] + te[10] * te[10]))
	}
	makeTranslation(x, y, z) {
		return x.isVector3 ? this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1) : this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1), this
	}
	makeRotationX(theta) {
		let c = Math.cos(theta),
			s = Math.sin(theta);
		return this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1), this
	}
	makeRotationY(theta) {
		let c = Math.cos(theta),
			s = Math.sin(theta);
		return this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1), this
	}
	makeRotationZ(theta) {
		let c = Math.cos(theta),
			s = Math.sin(theta);
		return this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
	}
	makeRotationAxis(axis, angle) {
		let c = Math.cos(angle),
			s = Math.sin(angle),
			t = 1 - c,
			x = axis.x,
			y = axis.y,
			z = axis.z,
			tx = t * x,
			ty = t * y;
		return this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1), this
	}
	makeScale(x, y, z) {
		return this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1), this
	}
	makeShear(xy, xz, yx, yz, zx, zy) {
		return this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1), this
	}
	compose(position, quaternion, scale) {
		let te = this.elements,
			x = quaternion._x,
			y = quaternion._y,
			z = quaternion._z,
			w = quaternion._w,
			x2 = x + x,
			y2 = y + y,
			z2 = z + z,
			xx = x * x2,
			xy = x * y2,
			xz = x * z2,
			yy = y * y2,
			yz = y * z2,
			zz = z * z2,
			wx = w * x2,
			wy = w * y2,
			wz = w * z2,
			sx = scale.x,
			sy = scale.y,
			sz = scale.z;
		return te[0] = (1 - (yy + zz)) * sx, te[1] = (xy + wz) * sx, te[2] = (xz - wy) * sx, te[3] = 0, te[4] = (xy - wz) * sy, te[5] = (1 - (xx + zz)) * sy, te[6] = (yz + wx) * sy, te[7] = 0, te[8] = (xz + wy) * sz, te[9] = (yz - wx) * sz, te[10] = (1 - (xx + yy)) * sz, te[11] = 0, te[12] = position.x, te[13] = position.y, te[14] = position.z, te[15] = 1, this
	}
	decompose(position, quaternion, scale) {
		let te = this.elements,
			sx = _v1$5.set(te[0], te[1], te[2]).length(),
			sy = _v1$5.set(te[4], te[5], te[6]).length(),
			sz = _v1$5.set(te[8], te[9], te[10]).length();
		0 > this.determinant() && (sx = -sx), position.x = te[12], position.y = te[13], position.z = te[14], _m1$2.copy(this);
		let invSX = 1 / sx,
			invSY = 1 / sy,
			invSZ = 1 / sz;
		return _m1$2.elements[0] *= invSX, _m1$2.elements[1] *= invSX, _m1$2.elements[2] *= invSX, _m1$2.elements[4] *= invSY, _m1$2.elements[5] *= invSY, _m1$2.elements[6] *= invSY, _m1$2.elements[8] *= invSZ, _m1$2.elements[9] *= invSZ, _m1$2.elements[10] *= invSZ, quaternion.setFromRotationMatrix(_m1$2), scale.x = sx, scale.y = sy, scale.z = sz, this
	}
	makePerspective(left, right, top, bottom, near, far, coordinateSystem = 2e3) {
		let c, d;
		let te = this.elements;
		if (2e3 === coordinateSystem) c = -(far + near) / (far - near), d = -2 * far * near / (far - near);
		else if (2001 === coordinateSystem) c = -far / (far - near), d = -far * near / (far - near);
		else throw Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
		return te[0] = 2 * near / (right - left), te[4] = 0, te[8] = (right + left) / (right - left), te[12] = 0, te[1] = 0, te[5] = 2 * near / (top - bottom), te[9] = (top + bottom) / (top - bottom), te[13] = 0, te[2] = 0, te[6] = 0, te[10] = c, te[14] = d, te[3] = 0, te[7] = 0, te[11] = -1, te[15] = 0, this
	}
	makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = 2e3) {
		let z, zInv;
		let te = this.elements,
			w = 1 / (right - left),
			h = 1 / (top - bottom),
			p = 1 / (far - near);
		if (2e3 === coordinateSystem) z = (far + near) * p, zInv = -2 * p;
		else if (2001 === coordinateSystem) z = near * p, zInv = -1 * p;
		else throw Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
		return te[0] = 2 * w, te[4] = 0, te[8] = 0, te[12] = -((right + left) * w), te[1] = 0, te[5] = 2 * h, te[9] = 0, te[13] = -((top + bottom) * h), te[2] = 0, te[6] = 0, te[10] = zInv, te[14] = -z, te[3] = 0, te[7] = 0, te[11] = 0, te[15] = 1, this
	}
	equals(matrix) {
		let te = this.elements,
			me = matrix.elements;
		for (let i = 0; i < 16; i++)
			if (te[i] !== me[i]) return !1;
		return !0
	}
	fromArray(array, offset = 0) {
		for (let i = 0; i < 16; i++) this.elements[i] = array[i + offset];
		return this
	}
	toArray(array = [], offset = 0) {
		let te = this.elements;
		return array[offset] = te[0], array[offset + 1] = te[1], array[offset + 2] = te[2], array[offset + 3] = te[3], array[offset + 4] = te[4], array[offset + 5] = te[5], array[offset + 6] = te[6], array[offset + 7] = te[7], array[offset + 8] = te[8], array[offset + 9] = te[9], array[offset + 10] = te[10], array[offset + 11] = te[11], array[offset + 12] = te[12], array[offset + 13] = te[13], array[offset + 14] = te[14], array[offset + 15] = te[15], array
	}
}
let _v1$5 = new Vector3,
	_m1$2 = new Matrix4,
	_zero = new Vector3(0, 0, 0),
	_one = new Vector3(1, 1, 1),
	_x = new Vector3,
	_y = new Vector3,
	_z = new Vector3,
	_matrix$1 = new Matrix4,
	_quaternion$3 = new Quaternion;
class Euler {
	constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
		this.isEuler = !0, this._x = x, this._y = y, this._z = z, this._order = order
	}
	get x() {
		return this._x
	}
	set x(value) {
		this._x = value, this._onChangeCallback()
	}
	get y() {
		return this._y
	}
	set y(value) {
		this._y = value, this._onChangeCallback()
	}
	get z() {
		return this._z
	}
	set z(value) {
		this._z = value, this._onChangeCallback()
	}
	get order() {
		return this._order
	}
	set order(value) {
		this._order = value, this._onChangeCallback()
	}
	set(x, y, z, order = this._order) {
		return this._x = x, this._y = y, this._z = z, this._order = order, this._onChangeCallback(), this
	}
	clone() {
		return new this.constructor(this._x, this._y, this._z, this._order)
	}
	copy(euler) {
		return this._x = euler._x, this._y = euler._y, this._z = euler._z, this._order = euler._order, this._onChangeCallback(), this
	}
	setFromRotationMatrix(m, order = this._order, update = !0) {
		let te = m.elements,
			m11 = te[0],
			m12 = te[4],
			m13 = te[8],
			m21 = te[1],
			m22 = te[5],
			m23 = te[9],
			m31 = te[2],
			m32 = te[6],
			m33 = te[10];
		switch (order) {
			case "XYZ":
				this._y = Math.asin(clamp$1(m13, -1, 1)), .9999999 > Math.abs(m13) ? (this._x = Math.atan2(-m23, m33), this._z = Math.atan2(-m12, m11)) : (this._x = Math.atan2(m32, m22), this._z = 0);
				break;
			case "YXZ":
				this._x = Math.asin(-clamp$1(m23, -1, 1)), .9999999 > Math.abs(m23) ? (this._y = Math.atan2(m13, m33), this._z = Math.atan2(m21, m22)) : (this._y = Math.atan2(-m31, m11), this._z = 0);
				break;
			case "ZXY":
				this._x = Math.asin(clamp$1(m32, -1, 1)), .9999999 > Math.abs(m32) ? (this._y = Math.atan2(-m31, m33), this._z = Math.atan2(-m12, m22)) : (this._y = 0, this._z = Math.atan2(m21, m11));
				break;
			case "ZYX":
				this._y = Math.asin(-clamp$1(m31, -1, 1)), .9999999 > Math.abs(m31) ? (this._x = Math.atan2(m32, m33), this._z = Math.atan2(m21, m11)) : (this._x = 0, this._z = Math.atan2(-m12, m22));
				break;
			case "YZX":
				this._z = Math.asin(clamp$1(m21, -1, 1)), .9999999 > Math.abs(m21) ? (this._x = Math.atan2(-m23, m22), this._y = Math.atan2(-m31, m11)) : (this._x = 0, this._y = Math.atan2(m13, m33));
				break;
			case "XZY":
				this._z = Math.asin(-clamp$1(m12, -1, 1)), .9999999 > Math.abs(m12) ? (this._x = Math.atan2(m32, m22), this._y = Math.atan2(m13, m11)) : (this._x = Math.atan2(-m23, m33), this._y = 0);
				break;
			default:
				console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order)
		}
		return this._order = order, !0 === update && this._onChangeCallback(), this
	}
	setFromQuaternion(q, order, update) {
		return _matrix$1.makeRotationFromQuaternion(q), this.setFromRotationMatrix(_matrix$1, order, update)
	}
	setFromVector3(v, order = this._order) {
		return this.set(v.x, v.y, v.z, order)
	}
	reorder(newOrder) {
		return _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, newOrder)
	}
	equals(euler) {
		return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order
	}
	fromArray(array) {
		return this._x = array[0], this._y = array[1], this._z = array[2], void 0 !== array[3] && (this._order = array[3]), this._onChangeCallback(), this
	}
	toArray(array = [], offset = 0) {
		return array[offset] = this._x, array[offset + 1] = this._y, array[offset + 2] = this._z, array[offset + 3] = this._order, array
	}
	_onChange(callback) {
		return this._onChangeCallback = callback, this
	}
	_onChangeCallback() {}*[Symbol.iterator]() {
		yield this._x, yield this._y, yield this._z, yield this._order
	}
}
Euler.DEFAULT_ORDER = "XYZ";
class Layers {
	constructor() {
		this.mask = 1
	}
	set(channel) {
		this.mask = (1 << channel | 0) >>> 0
	}
	enable(channel) {
		this.mask |= 1 << channel | 0
	}
	enableAll() {
		this.mask = -1
	}
	toggle(channel) {
		this.mask ^= 1 << channel | 0
	}
	disable(channel) {
		this.mask &= ~(1 << channel | 0)
	}
	disableAll() {
		this.mask = 0
	}
	test(layers) {
		return (this.mask & layers.mask) != 0
	}
	isEnabled(channel) {
		return (this.mask & (1 << channel | 0)) != 0
	}
}
let _object3DId = 0,
	_v1$4 = new Vector3,
	_q1 = new Quaternion,
	_m1$1 = new Matrix4,
	_target = new Vector3,
	_position$3 = new Vector3,
	_scale$2 = new Vector3,
	_quaternion$2 = new Quaternion,
	_xAxis = new Vector3(1, 0, 0),
	_yAxis = new Vector3(0, 1, 0),
	_zAxis = new Vector3(0, 0, 1),
	_addedEvent = {
		type: "added"
	},
	_removedEvent = {
		type: "removed"
	};
class Object3D extends EventDispatcher {
	constructor() {
		super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
			value: _object3DId++
		}), this.uuid = generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Object3D.DEFAULT_UP.clone();
		let position = new Vector3,
			rotation = new Euler,
			quaternion = new Quaternion,
			scale = new Vector3(1, 1, 1);
		rotation._onChange(function() {
			quaternion.setFromEuler(rotation, !1)
		}), quaternion._onChange(function() {
			rotation.setFromQuaternion(quaternion, void 0, !1)
		}), Object.defineProperties(this, {
			position: {
				configurable: !0,
				enumerable: !0,
				value: position
			},
			rotation: {
				configurable: !0,
				enumerable: !0,
				value: rotation
			},
			quaternion: {
				configurable: !0,
				enumerable: !0,
				value: quaternion
			},
			scale: {
				configurable: !0,
				enumerable: !0,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4
			},
			normalMatrix: {
				value: new Matrix3
			}
		}), this.matrix = new Matrix4, this.matrixWorld = new Matrix4, this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Layers, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
	}
	onBeforeShadow() {}
	onAfterShadow() {}
	onBeforeRender() {}
	onAfterRender() {}
	applyMatrix4(matrix) {
		this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
	}
	applyQuaternion(q) {
		return this.quaternion.premultiply(q), this
	}
	setRotationFromAxisAngle(axis, angle) {
		this.quaternion.setFromAxisAngle(axis, angle)
	}
	setRotationFromEuler(euler) {
		this.quaternion.setFromEuler(euler, !0)
	}
	setRotationFromMatrix(m) {
		this.quaternion.setFromRotationMatrix(m)
	}
	setRotationFromQuaternion(q) {
		this.quaternion.copy(q)
	}
	rotateOnAxis(axis, angle) {
		return _q1.setFromAxisAngle(axis, angle), this.quaternion.multiply(_q1), this
	}
	rotateOnWorldAxis(axis, angle) {
		return _q1.setFromAxisAngle(axis, angle), this.quaternion.premultiply(_q1), this
	}
	rotateX(angle) {
		return this.rotateOnAxis(_xAxis, angle)
	}
	rotateY(angle) {
		return this.rotateOnAxis(_yAxis, angle)
	}
	rotateZ(angle) {
		return this.rotateOnAxis(_zAxis, angle)
	}
	translateOnAxis(axis, distance) {
		return _v1$4.copy(axis).applyQuaternion(this.quaternion), this.position.add(_v1$4.multiplyScalar(distance)), this
	}
	translateX(distance) {
		return this.translateOnAxis(_xAxis, distance)
	}
	translateY(distance) {
		return this.translateOnAxis(_yAxis, distance)
	}
	translateZ(distance) {
		return this.translateOnAxis(_zAxis, distance)
	}
	localToWorld(vector) {
		return this.updateWorldMatrix(!0, !1), vector.applyMatrix4(this.matrixWorld)
	}
	worldToLocal(vector) {
		return this.updateWorldMatrix(!0, !1), vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())
	}
	lookAt(x, y, z) {
		x.isVector3 ? _target.copy(x) : _target.set(x, y, z);
		let parent = this.parent;
		this.updateWorldMatrix(!0, !1), _position$3.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _m1$1.lookAt(_position$3, _target, this.up) : _m1$1.lookAt(_target, _position$3, this.up), this.quaternion.setFromRotationMatrix(_m1$1), parent && (_m1$1.extractRotation(parent.matrixWorld), _q1.setFromRotationMatrix(_m1$1), this.quaternion.premultiply(_q1.invert()))
	}
	add(object) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
			return this
		}
		return object === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", object) : object && object.isObject3D ? (null !== object.parent && object.parent.remove(object), object.parent = this, this.children.push(object), object.dispatchEvent(_addedEvent)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object), this
	}
	remove(object) {
		if (arguments.length > 1) {
			for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
			return this
		}
		let index = this.children.indexOf(object);
		return -1 !== index && (object.parent = null, this.children.splice(index, 1), object.dispatchEvent(_removedEvent)), this
	}
	removeFromParent() {
		let parent = this.parent;
		return null !== parent && parent.remove(this), this
	}
	clear() {
		return this.remove(...this.children)
	}
	attach(object) {
		return this.updateWorldMatrix(!0, !1), _m1$1.copy(this.matrixWorld).invert(), null !== object.parent && (object.parent.updateWorldMatrix(!0, !1), _m1$1.multiply(object.parent.matrixWorld)), object.applyMatrix4(_m1$1), this.add(object), object.updateWorldMatrix(!1, !0), this
	}
	getObjectById(id) {
		return this.getObjectByProperty("id", id)
	}
	getObjectByName(name) {
		return this.getObjectByProperty("name", name)
	}
	getObjectByProperty(name, value) {
		if (this[name] === value) return this;
		for (let i = 0, l = this.children.length; i < l; i++) {
			let object = this.children[i].getObjectByProperty(name, value);
			if (void 0 !== object) return object
		}
	}
	getObjectsByProperty(name, value, result = []) {
		this[name] === value && result.push(this);
		let children = this.children;
		for (let i = 0, l = children.length; i < l; i++) children[i].getObjectsByProperty(name, value, result);
		return result
	}
	getWorldPosition(target) {
		return this.updateWorldMatrix(!0, !1), target.setFromMatrixPosition(this.matrixWorld)
	}
	getWorldQuaternion(target) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, target, _scale$2), target
	}
	getWorldScale(target) {
		return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(_position$3, _quaternion$2, target), target
	}
	getWorldDirection(target) {
		this.updateWorldMatrix(!0, !1);
		let e = this.matrixWorld.elements;
		return target.set(e[8], e[9], e[10]).normalize()
	}
	raycast() {}
	traverse(callback) {
		callback(this);
		let children = this.children;
		for (let i = 0, l = children.length; i < l; i++) children[i].traverse(callback)
	}
	traverseVisible(callback) {
		if (!1 === this.visible) return;
		callback(this);
		let children = this.children;
		for (let i = 0, l = children.length; i < l; i++) children[i].traverseVisible(callback)
	}
	traverseAncestors(callback) {
		let parent = this.parent;
		null !== parent && (callback(parent), parent.traverseAncestors(callback))
	}
	updateMatrix() {
		this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
	}
	updateMatrixWorld(force) {
		this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || force) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, force = !0);
		let children = this.children;
		for (let i = 0, l = children.length; i < l; i++) {
			let child = children[i];
			(!0 === child.matrixWorldAutoUpdate || !0 === force) && child.updateMatrixWorld(force)
		}
	}
	updateWorldMatrix(updateParents, updateChildren) {
		let parent = this.parent;
		if (!0 === updateParents && null !== parent && !0 === parent.matrixWorldAutoUpdate && parent.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === updateChildren) {
			let children = this.children;
			for (let i = 0, l = children.length; i < l; i++) {
				let child = children[i];
				!0 === child.matrixWorldAutoUpdate && child.updateWorldMatrix(!1, !0)
			}
		}
	}
	toJSON(meta) {
		let isRootObject = void 0 === meta || "string" == typeof meta,
			output = {};
		isRootObject && (meta = {
			geometries: {},
			materials: {},
			textures: {},
			images: {},
			shapes: {},
			skeletons: {},
			animations: {},
			nodes: {}
		}, output.metadata = {
			version: 4.6,
			type: "Object",
			generator: "Object3D.toJSON"
		});
		let object = {};

		function serialize(library, element) {
			return void 0 === library[element.uuid] && (library[element.uuid] = element.toJSON(meta)), element.uuid
		}
		if (object.uuid = this.uuid, object.type = this.type, "" !== this.name && (object.name = this.name), !0 === this.castShadow && (object.castShadow = !0), !0 === this.receiveShadow && (object.receiveShadow = !0), !1 === this.visible && (object.visible = !1), !1 === this.frustumCulled && (object.frustumCulled = !1), 0 !== this.renderOrder && (object.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (object.userData = this.userData), object.layers = this.layers.mask, object.matrix = this.matrix.toArray(), object.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (object.matrixAutoUpdate = !1), this.isInstancedMesh && (object.type = "InstancedMesh", object.count = this.count, object.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (object.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (object.type = "BatchedMesh", object.perObjectFrustumCulled = this.perObjectFrustumCulled, object.sortObjects = this.sortObjects, object.drawRanges = this._drawRanges, object.reservedRanges = this._reservedRanges, object.visibility = this._visibility, object.active = this._active, object.bounds = this._bounds.map(bound => ({
				boxInitialized: bound.boxInitialized,
				boxMin: bound.box.min.toArray(),
				boxMax: bound.box.max.toArray(),
				sphereInitialized: bound.sphereInitialized,
				sphereRadius: bound.sphere.radius,
				sphereCenter: bound.sphere.center.toArray()
			})), object.maxGeometryCount = this._maxGeometryCount, object.maxVertexCount = this._maxVertexCount, object.maxIndexCount = this._maxIndexCount, object.geometryInitialized = this._geometryInitialized, object.geometryCount = this._geometryCount, object.matricesTexture = this._matricesTexture.toJSON(meta), null !== this.boundingSphere && (object.boundingSphere = {
				center: object.boundingSphere.center.toArray(),
				radius: object.boundingSphere.radius
			}), null !== this.boundingBox && (object.boundingBox = {
				min: object.boundingBox.min.toArray(),
				max: object.boundingBox.max.toArray()
			})), this.isScene) this.background && (this.background.isColor ? object.background = this.background.toJSON() : this.background.isTexture && (object.background = this.background.toJSON(meta).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (object.environment = this.environment.toJSON(meta).uuid);
		else if (this.isMesh || this.isLine || this.isPoints) {
			object.geometry = serialize(meta.geometries, this.geometry);
			let parameters = this.geometry.parameters;
			if (void 0 !== parameters && void 0 !== parameters.shapes) {
				let shapes = parameters.shapes;
				if (Array.isArray(shapes))
					for (let i = 0, l = shapes.length; i < l; i++) {
						let shape = shapes[i];
						serialize(meta.shapes, shape)
					} else serialize(meta.shapes, shapes)
			}
		}
		if (this.isSkinnedMesh && (object.bindMode = this.bindMode, object.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (serialize(meta.skeletons, this.skeleton), object.skeleton = this.skeleton.uuid)), void 0 !== this.material) {
			if (Array.isArray(this.material)) {
				let uuids = [];
				for (let i = 0, l = this.material.length; i < l; i++) uuids.push(serialize(meta.materials, this.material[i]));
				object.material = uuids
			} else object.material = serialize(meta.materials, this.material)
		}
		if (this.children.length > 0) {
			object.children = [];
			for (let i = 0; i < this.children.length; i++) object.children.push(this.children[i].toJSON(meta).object)
		}
		if (this.animations.length > 0) {
			object.animations = [];
			for (let i = 0; i < this.animations.length; i++) {
				let animation = this.animations[i];
				object.animations.push(serialize(meta.animations, animation))
			}
		}
		if (isRootObject) {
			let geometries = extractFromCache(meta.geometries),
				materials = extractFromCache(meta.materials),
				textures = extractFromCache(meta.textures),
				images = extractFromCache(meta.images),
				shapes = extractFromCache(meta.shapes),
				skeletons = extractFromCache(meta.skeletons),
				animations = extractFromCache(meta.animations),
				nodes = extractFromCache(meta.nodes);
			geometries.length > 0 && (output.geometries = geometries), materials.length > 0 && (output.materials = materials), textures.length > 0 && (output.textures = textures), images.length > 0 && (output.images = images), shapes.length > 0 && (output.shapes = shapes), skeletons.length > 0 && (output.skeletons = skeletons), animations.length > 0 && (output.animations = animations), nodes.length > 0 && (output.nodes = nodes)
		}
		return output.object = object, output;

		function extractFromCache(cache) {
			let values = [];
			for (let key in cache) {
				let data = cache[key];
				delete data.metadata, values.push(data)
			}
			return values
		}
	}
	clone(recursive) {
		return new this.constructor().copy(this, recursive)
	}
	copy(source, recursive = !0) {
		if (this.name = source.name, this.up.copy(source.up), this.position.copy(source.position), this.rotation.order = source.rotation.order, this.quaternion.copy(source.quaternion), this.scale.copy(source.scale), this.matrix.copy(source.matrix), this.matrixWorld.copy(source.matrixWorld), this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate, this.layers.mask = source.layers.mask, this.visible = source.visible, this.castShadow = source.castShadow, this.receiveShadow = source.receiveShadow, this.frustumCulled = source.frustumCulled, this.renderOrder = source.renderOrder, this.animations = source.animations.slice(), this.userData = JSON.parse(JSON.stringify(source.userData)), !0 === recursive)
			for (let i = 0; i < source.children.length; i++) {
				let child = source.children[i];
				this.add(child.clone())
			}
		return this
	}
}
Object3D.DEFAULT_UP = new Vector3(0, 1, 0), Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0, Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
let _v0$1 = new Vector3,
	_v1$3 = new Vector3,
	_v2$2 = new Vector3,
	_v3$1 = new Vector3,
	_vab = new Vector3,
	_vac = new Vector3,
	_vbc = new Vector3,
	_vap = new Vector3,
	_vbp = new Vector3,
	_vcp = new Vector3,
	warnedGetUV = !1;
class Triangle {
	constructor(a = new Vector3, b = new Vector3, c = new Vector3) {
		this.a = a, this.b = b, this.c = c
	}
	static getNormal(a, b, c, target) {
		target.subVectors(c, b), _v0$1.subVectors(a, b), target.cross(_v0$1);
		let targetLengthSq = target.lengthSq();
		return targetLengthSq > 0 ? target.multiplyScalar(1 / Math.sqrt(targetLengthSq)) : target.set(0, 0, 0)
	}
	static getBarycoord(point, a, b, c, target) {
		_v0$1.subVectors(c, a), _v1$3.subVectors(b, a), _v2$2.subVectors(point, a);
		let dot00 = _v0$1.dot(_v0$1),
			dot01 = _v0$1.dot(_v1$3),
			dot02 = _v0$1.dot(_v2$2),
			dot11 = _v1$3.dot(_v1$3),
			dot12 = _v1$3.dot(_v2$2),
			denom = dot00 * dot11 - dot01 * dot01;
		if (0 === denom) return target.set(0, 0, 0), null;
		let invDenom = 1 / denom,
			u = (dot11 * dot02 - dot01 * dot12) * invDenom,
			v = (dot00 * dot12 - dot01 * dot02) * invDenom;
		return target.set(1 - u - v, v, u)
	}
	static containsPoint(point, a, b, c) {
		return null !== this.getBarycoord(point, a, b, c, _v3$1) && _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1
	}
	static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
		return !1 === warnedGetUV && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), warnedGetUV = !0), this.getInterpolation(point, p1, p2, p3, uv1, uv2, uv3, target)
	}
	static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
		return null === this.getBarycoord(point, p1, p2, p3, _v3$1) ? (target.x = 0, target.y = 0, "z" in target && (target.z = 0), "w" in target && (target.w = 0), null) : (target.setScalar(0), target.addScaledVector(v1, _v3$1.x), target.addScaledVector(v2, _v3$1.y), target.addScaledVector(v3, _v3$1.z), target)
	}
	static isFrontFacing(a, b, c, direction) {
		return _v0$1.subVectors(c, b), _v1$3.subVectors(a, b), 0 > _v0$1.cross(_v1$3).dot(direction)
	}
	set(a, b, c) {
		return this.a.copy(a), this.b.copy(b), this.c.copy(c), this
	}
	setFromPointsAndIndices(points, i0, i1, i2) {
		return this.a.copy(points[i0]), this.b.copy(points[i1]), this.c.copy(points[i2]), this
	}
	setFromAttributeAndIndices(attribute, i0, i1, i2) {
		return this.a.fromBufferAttribute(attribute, i0), this.b.fromBufferAttribute(attribute, i1), this.c.fromBufferAttribute(attribute, i2), this
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(triangle) {
		return this.a.copy(triangle.a), this.b.copy(triangle.b), this.c.copy(triangle.c), this
	}
	getArea() {
		return _v0$1.subVectors(this.c, this.b), _v1$3.subVectors(this.a, this.b), .5 * _v0$1.cross(_v1$3).length()
	}
	getMidpoint(target) {
		return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
	}
	getNormal(target) {
		return Triangle.getNormal(this.a, this.b, this.c, target)
	}
	getPlane(target) {
		return target.setFromCoplanarPoints(this.a, this.b, this.c)
	}
	getBarycoord(point, target) {
		return Triangle.getBarycoord(point, this.a, this.b, this.c, target)
	}
	getUV(point, uv1, uv2, uv3, target) {
		return !1 === warnedGetUV && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), warnedGetUV = !0), Triangle.getInterpolation(point, this.a, this.b, this.c, uv1, uv2, uv3, target)
	}
	getInterpolation(point, v1, v2, v3, target) {
		return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target)
	}
	containsPoint(point) {
		return Triangle.containsPoint(point, this.a, this.b, this.c)
	}
	isFrontFacing(direction) {
		return Triangle.isFrontFacing(this.a, this.b, this.c, direction)
	}
	intersectsBox(box) {
		return box.intersectsTriangle(this)
	}
	closestPointToPoint(p, target) {
		let v, w;
		let a = this.a,
			b = this.b,
			c = this.c;
		_vab.subVectors(b, a), _vac.subVectors(c, a), _vap.subVectors(p, a);
		let d1 = _vab.dot(_vap),
			d2 = _vac.dot(_vap);
		if (d1 <= 0 && d2 <= 0) return target.copy(a);
		_vbp.subVectors(p, b);
		let d3 = _vab.dot(_vbp),
			d4 = _vac.dot(_vbp);
		if (d3 >= 0 && d4 <= d3) return target.copy(b);
		let vc = d1 * d4 - d3 * d2;
		if (vc <= 0 && d1 >= 0 && d3 <= 0) return v = d1 / (d1 - d3), target.copy(a).addScaledVector(_vab, v);
		_vcp.subVectors(p, c);
		let d5 = _vab.dot(_vcp),
			d6 = _vac.dot(_vcp);
		if (d6 >= 0 && d5 <= d6) return target.copy(c);
		let vb = d5 * d2 - d1 * d6;
		if (vb <= 0 && d2 >= 0 && d6 <= 0) return w = d2 / (d2 - d6), target.copy(a).addScaledVector(_vac, w);
		let va = d3 * d6 - d5 * d4;
		if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) return _vbc.subVectors(c, b), w = (d4 - d3) / (d4 - d3 + (d5 - d6)), target.copy(b).addScaledVector(_vbc, w);
		let denom = 1 / (va + vb + vc);
		return v = vb * denom, w = vc * denom, target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w)
	}
	equals(triangle) {
		return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c)
	}
}
let _colorKeywords = {
		aliceblue: 15792383,
		antiquewhite: 16444375,
		aqua: 65535,
		aquamarine: 8388564,
		azure: 15794175,
		beige: 16119260,
		bisque: 16770244,
		black: 0,
		blanchedalmond: 16772045,
		blue: 255,
		blueviolet: 9055202,
		brown: 10824234,
		burlywood: 14596231,
		cadetblue: 6266528,
		chartreuse: 8388352,
		chocolate: 13789470,
		coral: 16744272,
		cornflowerblue: 6591981,
		cornsilk: 16775388,
		crimson: 14423100,
		cyan: 65535,
		darkblue: 139,
		darkcyan: 35723,
		darkgoldenrod: 12092939,
		darkgray: 11119017,
		darkgreen: 25600,
		darkgrey: 11119017,
		darkkhaki: 12433259,
		darkmagenta: 9109643,
		darkolivegreen: 5597999,
		darkorange: 16747520,
		darkorchid: 10040012,
		darkred: 9109504,
		darksalmon: 15308410,
		darkseagreen: 9419919,
		darkslateblue: 4734347,
		darkslategray: 3100495,
		darkslategrey: 3100495,
		darkturquoise: 52945,
		darkviolet: 9699539,
		deeppink: 16716947,
		deepskyblue: 49151,
		dimgray: 6908265,
		dimgrey: 6908265,
		dodgerblue: 2003199,
		firebrick: 11674146,
		floralwhite: 16775920,
		forestgreen: 2263842,
		fuchsia: 16711935,
		gainsboro: 14474460,
		ghostwhite: 16316671,
		gold: 16766720,
		goldenrod: 14329120,
		gray: 8421504,
		green: 32768,
		greenyellow: 11403055,
		grey: 8421504,
		honeydew: 15794160,
		hotpink: 16738740,
		indianred: 13458524,
		indigo: 4915330,
		ivory: 16777200,
		khaki: 15787660,
		lavender: 15132410,
		lavenderblush: 16773365,
		lawngreen: 8190976,
		lemonchiffon: 16775885,
		lightblue: 11393254,
		lightcoral: 15761536,
		lightcyan: 14745599,
		lightgoldenrodyellow: 16448210,
		lightgray: 13882323,
		lightgreen: 9498256,
		lightgrey: 13882323,
		lightpink: 16758465,
		lightsalmon: 16752762,
		lightseagreen: 2142890,
		lightskyblue: 8900346,
		lightslategray: 7833753,
		lightslategrey: 7833753,
		lightsteelblue: 11584734,
		lightyellow: 16777184,
		lime: 65280,
		limegreen: 3329330,
		linen: 16445670,
		magenta: 16711935,
		maroon: 8388608,
		mediumaquamarine: 6737322,
		mediumblue: 205,
		mediumorchid: 12211667,
		mediumpurple: 9662683,
		mediumseagreen: 3978097,
		mediumslateblue: 8087790,
		mediumspringgreen: 64154,
		mediumturquoise: 4772300,
		mediumvioletred: 13047173,
		midnightblue: 1644912,
		mintcream: 16121850,
		mistyrose: 16770273,
		moccasin: 16770229,
		navajowhite: 16768685,
		navy: 128,
		oldlace: 16643558,
		olive: 8421376,
		olivedrab: 7048739,
		orange: 16753920,
		orangered: 16729344,
		orchid: 14315734,
		palegoldenrod: 15657130,
		palegreen: 10025880,
		paleturquoise: 11529966,
		palevioletred: 14381203,
		papayawhip: 16773077,
		peachpuff: 16767673,
		peru: 13468991,
		pink: 16761035,
		plum: 14524637,
		powderblue: 11591910,
		purple: 8388736,
		rebeccapurple: 6697881,
		red: 16711680,
		rosybrown: 12357519,
		royalblue: 4286945,
		saddlebrown: 9127187,
		salmon: 16416882,
		sandybrown: 16032864,
		seagreen: 3050327,
		seashell: 16774638,
		sienna: 10506797,
		silver: 12632256,
		skyblue: 8900331,
		slateblue: 6970061,
		slategray: 7372944,
		slategrey: 7372944,
		snow: 16775930,
		springgreen: 65407,
		steelblue: 4620980,
		tan: 13808780,
		teal: 32896,
		thistle: 14204888,
		tomato: 16737095,
		turquoise: 4251856,
		violet: 15631086,
		wheat: 16113331,
		white: 16777215,
		whitesmoke: 16119285,
		yellow: 16776960,
		yellowgreen: 10145074
	},
	_hslA = {
		h: 0,
		s: 0,
		l: 0
	},
	_hslB = {
		h: 0,
		s: 0,
		l: 0
	};

function hue2rgb(p, q, t) {
	return (t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6) ? p + (q - p) * 6 * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * 6 * (2 / 3 - t) : p
}
class Color {
	constructor(r, g, b) {
		return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(r, g, b)
	}
	set(r, g, b) {
		return void 0 === g && void 0 === b ? r && r.isColor ? this.copy(r) : "number" == typeof r ? this.setHex(r) : "string" == typeof r && this.setStyle(r) : this.setRGB(r, g, b), this
	}
	setScalar(scalar) {
		return this.r = scalar, this.g = scalar, this.b = scalar, this
	}
	setHex(hex, colorSpace1 = SRGBColorSpace) {
		return hex = Math.floor(hex), this.r = (hex >> 16 & 255) / 255, this.g = (hex >> 8 & 255) / 255, this.b = (255 & hex) / 255, ColorManagement.toWorkingColorSpace(this, colorSpace1), this
	}
	setRGB(r, g, b, colorSpace1 = ColorManagement.workingColorSpace) {
		return this.r = r, this.g = g, this.b = b, ColorManagement.toWorkingColorSpace(this, colorSpace1), this
	}
	setHSL(h, s, l, colorSpace1 = ColorManagement.workingColorSpace) {
		if (h = euclideanModulo(h, 1), s = clamp$1(s, 0, 1), l = clamp$1(l, 0, 1), 0 === s) this.r = this.g = this.b = l;
		else {
			let p = l <= .5 ? l * (1 + s) : l + s - l * s,
				q = 2 * l - p;
			this.r = hue2rgb(q, p, h + 1 / 3), this.g = hue2rgb(q, p, h), this.b = hue2rgb(q, p, h - 1 / 3)
		}
		return ColorManagement.toWorkingColorSpace(this, colorSpace1), this
	}
	setStyle(style, colorSpace1 = SRGBColorSpace) {
		let m;

		function handleAlpha(string) {
			void 0 !== string && 1 > parseFloat(string) && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.")
		}
		if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
			let color;
			let name = m[1],
				components = m[2];
			switch (name) {
				case "rgb":
				case "rgba":
					if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) return handleAlpha(color[4]), this.setRGB(Math.min(255, parseInt(color[1], 10)) / 255, Math.min(255, parseInt(color[2], 10)) / 255, Math.min(255, parseInt(color[3], 10)) / 255, colorSpace1);
					if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) return handleAlpha(color[4]), this.setRGB(Math.min(100, parseInt(color[1], 10)) / 100, Math.min(100, parseInt(color[2], 10)) / 100, Math.min(100, parseInt(color[3], 10)) / 100, colorSpace1);
					break;
				case "hsl":
				case "hsla":
					if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) return handleAlpha(color[4]), this.setHSL(parseFloat(color[1]) / 360, parseFloat(color[2]) / 100, parseFloat(color[3]) / 100, colorSpace1);
					break;
				default:
					console.warn("THREE.Color: Unknown color model " + style)
			}
		} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
			let hex = m[1],
				size = hex.length;
			if (3 === size) return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace1);
			if (6 === size) return this.setHex(parseInt(hex, 16), colorSpace1);
			console.warn("THREE.Color: Invalid hex color " + style)
		} else if (style && style.length > 0) return this.setColorName(style, colorSpace1);
		return this
	}
	setColorName(style, colorSpace1 = SRGBColorSpace) {
		let hex = _colorKeywords[style.toLowerCase()];
		return void 0 !== hex ? this.setHex(hex, colorSpace1) : console.warn("THREE.Color: Unknown color " + style), this
	}
	clone() {
		return new this.constructor(this.r, this.g, this.b)
	}
	copy(color) {
		return this.r = color.r, this.g = color.g, this.b = color.b, this
	}
	copySRGBToLinear(color) {
		return this.r = SRGBToLinear(color.r), this.g = SRGBToLinear(color.g), this.b = SRGBToLinear(color.b), this
	}
	copyLinearToSRGB(color) {
		return this.r = LinearToSRGB(color.r), this.g = LinearToSRGB(color.g), this.b = LinearToSRGB(color.b), this
	}
	convertSRGBToLinear() {
		return this.copySRGBToLinear(this), this
	}
	convertLinearToSRGB() {
		return this.copyLinearToSRGB(this), this
	}
	getHex(colorSpace1 = SRGBColorSpace) {
		return ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace1), 65536 * Math.round(clamp$1(255 * _color.r, 0, 255)) + 256 * Math.round(clamp$1(255 * _color.g, 0, 255)) + Math.round(clamp$1(255 * _color.b, 0, 255))
	}
	getHexString(colorSpace1 = SRGBColorSpace) {
		return ("000000" + this.getHex(colorSpace1).toString(16)).slice(-6)
	}
	getHSL(target, colorSpace1 = ColorManagement.workingColorSpace) {
		let hue, saturation;
		ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace1);
		let r = _color.r,
			g = _color.g,
			b = _color.b,
			max = Math.max(r, g, b),
			min = Math.min(r, g, b),
			lightness = (min + max) / 2;
		if (min === max) hue = 0, saturation = 0;
		else {
			let delta = max - min;
			switch (saturation = lightness <= .5 ? delta / (max + min) : delta / (2 - max - min), max) {
				case r:
					hue = (g - b) / delta + (g < b ? 6 : 0);
					break;
				case g:
					hue = (b - r) / delta + 2;
					break;
				case b:
					hue = (r - g) / delta + 4
			}
			hue /= 6
		}
		return target.h = hue, target.s = saturation, target.l = lightness, target
	}
	getRGB(target, colorSpace1 = ColorManagement.workingColorSpace) {
		return ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace1), target.r = _color.r, target.g = _color.g, target.b = _color.b, target
	}
	getStyle(colorSpace1 = SRGBColorSpace) {
		ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace1);
		let r = _color.r,
			g = _color.g,
			b = _color.b;
		return colorSpace1 !== SRGBColorSpace ? `color(${colorSpace1} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})` : `rgb(${Math.round(255*r)},${Math.round(255*g)},${Math.round(255*b)})`
	}
	offsetHSL(h, s, l) {
		return this.getHSL(_hslA), this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l)
	}
	add(color) {
		return this.r += color.r, this.g += color.g, this.b += color.b, this
	}
	addColors(color1, color2) {
		return this.r = color1.r + color2.r, this.g = color1.g + color2.g, this.b = color1.b + color2.b, this
	}
	addScalar(s) {
		return this.r += s, this.g += s, this.b += s, this
	}
	sub(color) {
		return this.r = Math.max(0, this.r - color.r), this.g = Math.max(0, this.g - color.g), this.b = Math.max(0, this.b - color.b), this
	}
	multiply(color) {
		return this.r *= color.r, this.g *= color.g, this.b *= color.b, this
	}
	multiplyScalar(s) {
		return this.r *= s, this.g *= s, this.b *= s, this
	}
	lerp(color, alpha) {
		return this.r += (color.r - this.r) * alpha, this.g += (color.g - this.g) * alpha, this.b += (color.b - this.b) * alpha, this
	}
	lerpColors(color1, color2, alpha) {
		return this.r = color1.r + (color2.r - color1.r) * alpha, this.g = color1.g + (color2.g - color1.g) * alpha, this.b = color1.b + (color2.b - color1.b) * alpha, this
	}
	lerpHSL(color, alpha) {
		this.getHSL(_hslA), color.getHSL(_hslB);
		let h = lerp$1(_hslA.h, _hslB.h, alpha),
			s = lerp$1(_hslA.s, _hslB.s, alpha),
			l = lerp$1(_hslA.l, _hslB.l, alpha);
		return this.setHSL(h, s, l), this
	}
	setFromVector3(v) {
		return this.r = v.x, this.g = v.y, this.b = v.z, this
	}
	applyMatrix3(m) {
		let r = this.r,
			g = this.g,
			b = this.b,
			e = m.elements;
		return this.r = e[0] * r + e[3] * g + e[6] * b, this.g = e[1] * r + e[4] * g + e[7] * b, this.b = e[2] * r + e[5] * g + e[8] * b, this
	}
	equals(c) {
		return c.r === this.r && c.g === this.g && c.b === this.b
	}
	fromArray(array, offset = 0) {
		return this.r = array[offset], this.g = array[offset + 1], this.b = array[offset + 2], this
	}
	toArray(array = [], offset = 0) {
		return array[offset] = this.r, array[offset + 1] = this.g, array[offset + 2] = this.b, array
	}
	fromBufferAttribute(attribute, index) {
		return this.r = attribute.getX(index), this.g = attribute.getY(index), this.b = attribute.getZ(index), this
	}
	toJSON() {
		return this.getHex()
	}*[Symbol.iterator]() {
		yield this.r, yield this.g, yield this.b
	}
}
let _color = new Color;
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material$1 extends EventDispatcher {
	constructor() {
		super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
			value: _materialId++
		}), this.uuid = generateUUID(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Color(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
	}
	get alphaTest() {
		return this._alphaTest
	}
	set alphaTest(value) {
		this._alphaTest > 0 != value > 0 && this.version++, this._alphaTest = value
	}
	onBuild() {}
	onBeforeRender() {}
	onBeforeCompile() {}
	customProgramCacheKey() {
		return this.onBeforeCompile.toString()
	}
	setValues(values) {
		if (void 0 !== values)
			for (let key in values) {
				let newValue = values[key];
				if (void 0 === newValue) {
					console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
					continue
				}
				let currentValue = this[key];
				if (void 0 === currentValue) {
					console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
					continue
				}
				currentValue && currentValue.isColor ? currentValue.set(newValue) : currentValue && currentValue.isVector3 && newValue && newValue.isVector3 ? currentValue.copy(newValue) : this[key] = newValue
			}
	}
	toJSON(meta) {
		let isRootObject = void 0 === meta || "string" == typeof meta;
		isRootObject && (meta = {
			textures: {},
			images: {}
		});
		let data = {
			metadata: {
				version: 4.6,
				type: "Material",
				generator: "Material.toJSON"
			}
		};

		function extractFromCache(cache) {
			let values = [];
			for (let key in cache) {
				let data = cache[key];
				delete data.metadata, values.push(data)
			}
			return values
		}
		if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), this.color && this.color.isColor && (data.color = this.color.getHex()), void 0 !== this.roughness && (data.roughness = this.roughness), void 0 !== this.metalness && (data.metalness = this.metalness), void 0 !== this.sheen && (data.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (data.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (data.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (data.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (data.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (data.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (data.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (data.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (data.shininess = this.shininess), void 0 !== this.clearcoat && (data.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (data.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid, data.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (data.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (data.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (data.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid), void 0 !== this.anisotropy && (data.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (data.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid), this.map && this.map.isTexture && (data.map = this.map.toJSON(meta).uuid), this.matcap && this.matcap.isTexture && (data.matcap = this.matcap.toJSON(meta).uuid), this.alphaMap && this.alphaMap.isTexture && (data.alphaMap = this.alphaMap.toJSON(meta).uuid), this.lightMap && this.lightMap.isTexture && (data.lightMap = this.lightMap.toJSON(meta).uuid, data.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (data.aoMap = this.aoMap.toJSON(meta).uuid, data.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (data.bumpMap = this.bumpMap.toJSON(meta).uuid, data.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (data.normalMap = this.normalMap.toJSON(meta).uuid, data.normalMapType = this.normalMapType, data.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (data.displacementMap = this.displacementMap.toJSON(meta).uuid, data.displacementScale = this.displacementScale, data.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (data.roughnessMap = this.roughnessMap.toJSON(meta).uuid), this.metalnessMap && this.metalnessMap.isTexture && (data.metalnessMap = this.metalnessMap.toJSON(meta).uuid), this.emissiveMap && this.emissiveMap.isTexture && (data.emissiveMap = this.emissiveMap.toJSON(meta).uuid), this.specularMap && this.specularMap.isTexture && (data.specularMap = this.specularMap.toJSON(meta).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid), this.specularColorMap && this.specularColorMap.isTexture && (data.specularColorMap = this.specularColorMap.toJSON(meta).uuid), this.envMap && this.envMap.isTexture && (data.envMap = this.envMap.toJSON(meta).uuid, void 0 !== this.combine && (data.combine = this.combine)), void 0 !== this.envMapIntensity && (data.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (data.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (data.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (data.gradientMap = this.gradientMap.toJSON(meta).uuid), void 0 !== this.transmission && (data.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (data.transmissionMap = this.transmissionMap.toJSON(meta).uuid), void 0 !== this.thickness && (data.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (data.thicknessMap = this.thicknessMap.toJSON(meta).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (data.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (data.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (data.size = this.size), null !== this.shadowSide && (data.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (data.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (data.blending = this.blending), 0 !== this.side && (data.side = this.side), !0 === this.vertexColors && (data.vertexColors = !0), this.opacity < 1 && (data.opacity = this.opacity), !0 === this.transparent && (data.transparent = !0), 204 !== this.blendSrc && (data.blendSrc = this.blendSrc), 205 !== this.blendDst && (data.blendDst = this.blendDst), 100 !== this.blendEquation && (data.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (data.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (data.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (data.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (data.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (data.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (data.depthFunc = this.depthFunc), !1 === this.depthTest && (data.depthTest = this.depthTest), !1 === this.depthWrite && (data.depthWrite = this.depthWrite), !1 === this.colorWrite && (data.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (data.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (data.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (data.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (data.stencilFuncMask = this.stencilFuncMask), 7680 !== this.stencilFail && (data.stencilFail = this.stencilFail), 7680 !== this.stencilZFail && (data.stencilZFail = this.stencilZFail), 7680 !== this.stencilZPass && (data.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (data.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (data.rotation = this.rotation), !0 === this.polygonOffset && (data.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (data.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (data.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (data.linewidth = this.linewidth), void 0 !== this.dashSize && (data.dashSize = this.dashSize), void 0 !== this.gapSize && (data.gapSize = this.gapSize), void 0 !== this.scale && (data.scale = this.scale), !0 === this.dithering && (data.dithering = !0), this.alphaTest > 0 && (data.alphaTest = this.alphaTest), !0 === this.alphaHash && (data.alphaHash = !0), !0 === this.alphaToCoverage && (data.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (data.premultipliedAlpha = !0), !0 === this.forceSinglePass && (data.forceSinglePass = !0), !0 === this.wireframe && (data.wireframe = !0), this.wireframeLinewidth > 1 && (data.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (data.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (data.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (data.flatShading = !0), !1 === this.visible && (data.visible = !1), !1 === this.toneMapped && (data.toneMapped = !1), !1 === this.fog && (data.fog = !1), Object.keys(this.userData).length > 0 && (data.userData = this.userData), isRootObject) {
			let textures = extractFromCache(meta.textures),
				images = extractFromCache(meta.images);
			textures.length > 0 && (data.textures = textures), images.length > 0 && (data.images = images)
		}
		return data
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(source) {
		this.name = source.name, this.blending = source.blending, this.side = source.side, this.vertexColors = source.vertexColors, this.opacity = source.opacity, this.transparent = source.transparent, this.blendSrc = source.blendSrc, this.blendDst = source.blendDst, this.blendEquation = source.blendEquation, this.blendSrcAlpha = source.blendSrcAlpha, this.blendDstAlpha = source.blendDstAlpha, this.blendEquationAlpha = source.blendEquationAlpha, this.blendColor.copy(source.blendColor), this.blendAlpha = source.blendAlpha, this.depthFunc = source.depthFunc, this.depthTest = source.depthTest, this.depthWrite = source.depthWrite, this.stencilWriteMask = source.stencilWriteMask, this.stencilFunc = source.stencilFunc, this.stencilRef = source.stencilRef, this.stencilFuncMask = source.stencilFuncMask, this.stencilFail = source.stencilFail, this.stencilZFail = source.stencilZFail, this.stencilZPass = source.stencilZPass, this.stencilWrite = source.stencilWrite;
		let srcPlanes = source.clippingPlanes,
			dstPlanes = null;
		if (null !== srcPlanes) {
			let n = srcPlanes.length;
			dstPlanes = Array(n);
			for (let i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone()
		}
		return this.clippingPlanes = dstPlanes, this.clipIntersection = source.clipIntersection, this.clipShadows = source.clipShadows, this.shadowSide = source.shadowSide, this.colorWrite = source.colorWrite, this.precision = source.precision, this.polygonOffset = source.polygonOffset, this.polygonOffsetFactor = source.polygonOffsetFactor, this.polygonOffsetUnits = source.polygonOffsetUnits, this.dithering = source.dithering, this.alphaTest = source.alphaTest, this.alphaHash = source.alphaHash, this.alphaToCoverage = source.alphaToCoverage, this.premultipliedAlpha = source.premultipliedAlpha, this.forceSinglePass = source.forceSinglePass, this.visible = source.visible, this.toneMapped = source.toneMapped, this.userData = JSON.parse(JSON.stringify(source.userData)), this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
	set needsUpdate(value) {
		!0 === value && this.version++
	}
}
class MeshBasicMaterial extends Material$1 {
	constructor(parameters) {
		super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(parameters)
	}
	copy(source) {
		return super.copy(source), this.color.copy(source.color), this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.fog = source.fog, this
	}
}
let _tables = function() {
		let buffer = new ArrayBuffer(4),
			floatView = new Float32Array(buffer),
			uint32View = new Uint32Array(buffer),
			baseTable = new Uint32Array(512),
			shiftTable = new Uint32Array(512);
		for (let i = 0; i < 256; ++i) {
			let e = i - 127;
			e < -27 ? (baseTable[i] = 0, baseTable[256 | i] = 32768, shiftTable[i] = 24, shiftTable[256 | i] = 24) : e < -14 ? (baseTable[i] = 1024 >> -e - 14, baseTable[256 | i] = 1024 >> -e - 14 | 32768, shiftTable[i] = -e - 1, shiftTable[256 | i] = -e - 1) : e <= 15 ? (baseTable[i] = e + 15 << 10, baseTable[256 | i] = e + 15 << 10 | 32768, shiftTable[i] = 13, shiftTable[256 | i] = 13) : e < 128 ? (baseTable[i] = 31744, baseTable[256 | i] = 64512, shiftTable[i] = 24, shiftTable[256 | i] = 24) : (baseTable[i] = 31744, baseTable[256 | i] = 64512, shiftTable[i] = 13, shiftTable[256 | i] = 13)
		}
		let mantissaTable = new Uint32Array(2048),
			exponentTable = new Uint32Array(64),
			offsetTable = new Uint32Array(64);
		for (let i = 1; i < 1024; ++i) {
			let m = i << 13,
				e = 0;
			for (;
				(8388608 & m) == 0;) m <<= 1, e -= 8388608;
			m &= -8388609, e += 947912704, mantissaTable[i] = m | e
		}
		for (let i = 1024; i < 2048; ++i) mantissaTable[i] = 939524096 + (i - 1024 << 13);
		for (let i = 1; i < 31; ++i) exponentTable[i] = i << 23;
		exponentTable[31] = 1199570944, exponentTable[32] = 2147483648;
		for (let i = 33; i < 63; ++i) exponentTable[i] = 2147483648 + (i - 32 << 23);
		exponentTable[63] = 3347054592;
		for (let i = 1; i < 64; ++i) 32 !== i && (offsetTable[i] = 1024);
		return {
			floatView: floatView,
			uint32View: uint32View,
			baseTable: baseTable,
			shiftTable: shiftTable,
			mantissaTable: mantissaTable,
			exponentTable: exponentTable,
			offsetTable: offsetTable
		}
	}(),
	DataUtils = {
		toHalfFloat: function(val) {
			Math.abs(val) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), val = clamp$1(val, -65504, 65504), _tables.floatView[0] = val;
			let f = _tables.uint32View[0],
				e = f >> 23 & 511;
			return _tables.baseTable[e] + ((8388607 & f) >> _tables.shiftTable[e])
		},
		fromHalfFloat: function(val) {
			let m = val >> 10;
			return _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (1023 & val)] + _tables.exponentTable[m], _tables.floatView[0]
		}
	},
	_vector$9 = new Vector3,
	_vector2$1 = new Vector2;
class BufferAttribute {
	constructor(array, itemSize, normalized = !1) {
		if (Array.isArray(array)) throw TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		this.isBufferAttribute = !0, this.name = "", this.array = array, this.itemSize = itemSize, this.count = void 0 !== array ? array.length / itemSize : 0, this.normalized = normalized, this.usage = 35044, this._updateRange = {
			offset: 0,
			count: -1
		}, this.updateRanges = [], this.gpuType = 1015, this.version = 0
	}
	onUploadCallback() {}
	set needsUpdate(value) {
		!0 === value && this.version++
	}
	get updateRange() {
		return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
	}
	setUsage(value) {
		return this.usage = value, this
	}
	addUpdateRange(start, count) {
		this.updateRanges.push({
			start,
			count
		})
	}
	clearUpdateRanges() {
		this.updateRanges.length = 0
	}
	copy(source) {
		return this.name = source.name, this.array = new source.array.constructor(source.array), this.itemSize = source.itemSize, this.count = source.count, this.normalized = source.normalized, this.usage = source.usage, this.gpuType = source.gpuType, this
	}
	copyAt(index1, attribute, index2) {
		index1 *= this.itemSize, index2 *= attribute.itemSize;
		for (let i = 0, l = this.itemSize; i < l; i++) this.array[index1 + i] = attribute.array[index2 + i];
		return this
	}
	copyArray(array) {
		return this.array.set(array), this
	}
	applyMatrix3(m) {
		if (2 === this.itemSize)
			for (let i = 0, l = this.count; i < l; i++) _vector2$1.fromBufferAttribute(this, i), _vector2$1.applyMatrix3(m), this.setXY(i, _vector2$1.x, _vector2$1.y);
		else if (3 === this.itemSize)
			for (let i = 0, l = this.count; i < l; i++) _vector$9.fromBufferAttribute(this, i), _vector$9.applyMatrix3(m), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		return this
	}
	applyMatrix4(m) {
		for (let i = 0, l = this.count; i < l; i++) _vector$9.fromBufferAttribute(this, i), _vector$9.applyMatrix4(m), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		return this
	}
	applyNormalMatrix(m) {
		for (let i = 0, l = this.count; i < l; i++) _vector$9.fromBufferAttribute(this, i), _vector$9.applyNormalMatrix(m), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		return this
	}
	transformDirection(m) {
		for (let i = 0, l = this.count; i < l; i++) _vector$9.fromBufferAttribute(this, i), _vector$9.transformDirection(m), this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
		return this
	}
	set(value, offset = 0) {
		return this.array.set(value, offset), this
	}
	getComponent(index, component) {
		let value = this.array[index * this.itemSize + component];
		return this.normalized && (value = denormalize(value, this.array)), value
	}
	setComponent(index, component, value) {
		return this.normalized && (value = normalize(value, this.array)), this.array[index * this.itemSize + component] = value, this
	}
	getX(index) {
		let x = this.array[index * this.itemSize];
		return this.normalized && (x = denormalize(x, this.array)), x
	}
	setX(index, x) {
		return this.normalized && (x = normalize(x, this.array)), this.array[index * this.itemSize] = x, this
	}
	getY(index) {
		let y = this.array[index * this.itemSize + 1];
		return this.normalized && (y = denormalize(y, this.array)), y
	}
	setY(index, y) {
		return this.normalized && (y = normalize(y, this.array)), this.array[index * this.itemSize + 1] = y, this
	}
	getZ(index) {
		let z = this.array[index * this.itemSize + 2];
		return this.normalized && (z = denormalize(z, this.array)), z
	}
	setZ(index, z) {
		return this.normalized && (z = normalize(z, this.array)), this.array[index * this.itemSize + 2] = z, this
	}
	getW(index) {
		let w = this.array[index * this.itemSize + 3];
		return this.normalized && (w = denormalize(w, this.array)), w
	}
	setW(index, w) {
		return this.normalized && (w = normalize(w, this.array)), this.array[index * this.itemSize + 3] = w, this
	}
	setXY(index, x, y) {
		return index *= this.itemSize, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array)), this.array[index + 0] = x, this.array[index + 1] = y, this
	}
	setXYZ(index, x, y, z) {
		return index *= this.itemSize, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array)), this.array[index + 0] = x, this.array[index + 1] = y, this.array[index + 2] = z, this
	}
	setXYZW(index, x, y, z, w) {
		return index *= this.itemSize, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array), w = normalize(w, this.array)), this.array[index + 0] = x, this.array[index + 1] = y, this.array[index + 2] = z, this.array[index + 3] = w, this
	}
	onUpload(callback) {
		return this.onUploadCallback = callback, this
	}
	clone() {
		return new this.constructor(this.array, this.itemSize).copy(this)
	}
	toJSON() {
		let data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from(this.array),
			normalized: this.normalized
		};
		return "" !== this.name && (data.name = this.name), 35044 !== this.usage && (data.usage = this.usage), data
	}
}
class Uint16BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Uint16Array(array), itemSize, normalized)
	}
}
class Uint32BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Uint32Array(array), itemSize, normalized)
	}
}
class Float32BufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized) {
		super(new Float32Array(array), itemSize, normalized)
	}
}
let _id$2 = 0,
	_m1 = new Matrix4,
	_obj = new Object3D,
	_offset = new Vector3,
	_box$2 = new Box3,
	_boxMorphTargets = new Box3,
	_vector$8 = new Vector3;
class BufferGeometry extends EventDispatcher {
	constructor() {
		super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
			value: _id$2++
		}), this.uuid = generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
			start: 0,
			count: 1 / 0
		}, this.userData = {}
	}
	getIndex() {
		return this.index
	}
	setIndex(index) {
		return Array.isArray(index) ? this.index = new(arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1) : this.index = index, this
	}
	getAttribute(name) {
		return this.attributes[name]
	}
	setAttribute(name, attribute) {
		return this.attributes[name] = attribute, this
	}
	deleteAttribute(name) {
		return delete this.attributes[name], this
	}
	hasAttribute(name) {
		return void 0 !== this.attributes[name]
	}
	addGroup(start, count, materialIndex = 0) {
		this.groups.push({
			start: start,
			count: count,
			materialIndex: materialIndex
		})
	}
	clearGroups() {
		this.groups = []
	}
	setDrawRange(start, count) {
		this.drawRange.start = start, this.drawRange.count = count
	}
	applyMatrix4(matrix) {
		let position = this.attributes.position;
		void 0 !== position && (position.applyMatrix4(matrix), position.needsUpdate = !0);
		let normal = this.attributes.normal;
		if (void 0 !== normal) {
			let normalMatrix = new Matrix3().getNormalMatrix(matrix);
			normal.applyNormalMatrix(normalMatrix), normal.needsUpdate = !0
		}
		let tangent = this.attributes.tangent;
		return void 0 !== tangent && (tangent.transformDirection(matrix), tangent.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
	}
	applyQuaternion(q) {
		return _m1.makeRotationFromQuaternion(q), this.applyMatrix4(_m1), this
	}
	rotateX(angle) {
		return _m1.makeRotationX(angle), this.applyMatrix4(_m1), this
	}
	rotateY(angle) {
		return _m1.makeRotationY(angle), this.applyMatrix4(_m1), this
	}
	rotateZ(angle) {
		return _m1.makeRotationZ(angle), this.applyMatrix4(_m1), this
	}
	translate(x, y, z) {
		return _m1.makeTranslation(x, y, z), this.applyMatrix4(_m1), this
	}
	scale(x, y, z) {
		return _m1.makeScale(x, y, z), this.applyMatrix4(_m1), this
	}
	lookAt(vector) {
		return _obj.lookAt(vector), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this
	}
	center() {
		return this.computeBoundingBox(), this.boundingBox.getCenter(_offset).negate(), this.translate(_offset.x, _offset.y, _offset.z), this
	}
	setFromPoints(points) {
		let position = [];
		for (let i = 0, l = points.length; i < l; i++) {
			let point = points[i];
			position.push(point.x, point.y, point.z || 0)
		}
		return this.setAttribute("position", new Float32BufferAttribute(position, 3)), this
	}
	computeBoundingBox() {
		null === this.boundingBox && (this.boundingBox = new Box3);
		let position = this.attributes.position,
			morphAttributesPosition = this.morphAttributes.position;
		if (position && position.isGLBufferAttribute) {
			console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new Vector3(-1 / 0, -1 / 0, -1 / 0), new Vector3(Infinity, Infinity, Infinity));
			return
		}
		if (void 0 !== position) {
			if (this.boundingBox.setFromBufferAttribute(position), morphAttributesPosition)
				for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
					let morphAttribute = morphAttributesPosition[i];
					_box$2.setFromBufferAttribute(morphAttribute), this.morphTargetsRelative ? (_vector$8.addVectors(this.boundingBox.min, _box$2.min), this.boundingBox.expandByPoint(_vector$8), _vector$8.addVectors(this.boundingBox.max, _box$2.max), this.boundingBox.expandByPoint(_vector$8)) : (this.boundingBox.expandByPoint(_box$2.min), this.boundingBox.expandByPoint(_box$2.max))
				}
		} else this.boundingBox.makeEmpty();
		(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
	}
	computeBoundingSphere() {
		null === this.boundingSphere && (this.boundingSphere = new Sphere);
		let position = this.attributes.position,
			morphAttributesPosition = this.morphAttributes.position;
		if (position && position.isGLBufferAttribute) {
			console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new Vector3, 1 / 0);
			return
		}
		if (position) {
			let center = this.boundingSphere.center;
			if (_box$2.setFromBufferAttribute(position), morphAttributesPosition)
				for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
					let morphAttribute = morphAttributesPosition[i];
					_boxMorphTargets.setFromBufferAttribute(morphAttribute), this.morphTargetsRelative ? (_vector$8.addVectors(_box$2.min, _boxMorphTargets.min), _box$2.expandByPoint(_vector$8), _vector$8.addVectors(_box$2.max, _boxMorphTargets.max), _box$2.expandByPoint(_vector$8)) : (_box$2.expandByPoint(_boxMorphTargets.min), _box$2.expandByPoint(_boxMorphTargets.max))
				}
			_box$2.getCenter(center);
			let maxRadiusSq = 0;
			for (let i = 0, il = position.count; i < il; i++) _vector$8.fromBufferAttribute(position, i), maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
			if (morphAttributesPosition)
				for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
					let morphAttribute = morphAttributesPosition[i],
						morphTargetsRelative = this.morphTargetsRelative;
					for (let j = 0, jl = morphAttribute.count; j < jl; j++) _vector$8.fromBufferAttribute(morphAttribute, j), morphTargetsRelative && (_offset.fromBufferAttribute(position, j), _vector$8.add(_offset)), maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8))
				}
			this.boundingSphere.radius = Math.sqrt(maxRadiusSq), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
		}
	}
	computeTangents() {
		let index = this.index,
			attributes = this.attributes;
		if (null === index || void 0 === attributes.position || void 0 === attributes.normal || void 0 === attributes.uv) {
			console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
			return
		}
		let indices = index.array,
			positions = attributes.position.array,
			normals = attributes.normal.array,
			uvs = attributes.uv.array,
			nVertices = positions.length / 3;
		!1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
		let tangents = this.getAttribute("tangent").array,
			tan1 = [],
			tan2 = [];
		for (let i = 0; i < nVertices; i++) tan1[i] = new Vector3, tan2[i] = new Vector3;
		let vA = new Vector3,
			vB = new Vector3,
			vC = new Vector3,
			uvA = new Vector2,
			uvB = new Vector2,
			uvC = new Vector2,
			sdir = new Vector3,
			tdir = new Vector3,
			groups = this.groups;
		0 === groups.length && (groups = [{
			start: 0,
			count: indices.length
		}]);
		for (let i = 0, il = groups.length; i < il; ++i) {
			let group = groups[i],
				start = group.start,
				count = group.count;
			for (let j = start, jl = start + count; j < jl; j += 3) ! function(a, b, c) {
				vA.fromArray(positions, 3 * a), vB.fromArray(positions, 3 * b), vC.fromArray(positions, 3 * c), uvA.fromArray(uvs, 2 * a), uvB.fromArray(uvs, 2 * b), uvC.fromArray(uvs, 2 * c), vB.sub(vA), vC.sub(vA), uvB.sub(uvA), uvC.sub(uvA);
				let r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
				isFinite(r) && (sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r), tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r), tan1[a].add(sdir), tan1[b].add(sdir), tan1[c].add(sdir), tan2[a].add(tdir), tan2[b].add(tdir), tan2[c].add(tdir))
			}(indices[j + 0], indices[j + 1], indices[j + 2])
		}
		let tmp = new Vector3,
			tmp2 = new Vector3,
			n = new Vector3,
			n2 = new Vector3;

		function handleVertex(v) {
			n.fromArray(normals, 3 * v), n2.copy(n);
			let t = tan1[v];
			tmp.copy(t), tmp.sub(n.multiplyScalar(n.dot(t))).normalize(), tmp2.crossVectors(n2, t);
			let test = tmp2.dot(tan2[v]);
			tangents[4 * v] = tmp.x, tangents[4 * v + 1] = tmp.y, tangents[4 * v + 2] = tmp.z, tangents[4 * v + 3] = test < 0 ? -1 : 1
		}
		for (let i = 0, il = groups.length; i < il; ++i) {
			let group = groups[i],
				start = group.start,
				count = group.count;
			for (let j = start, jl = start + count; j < jl; j += 3) handleVertex(indices[j + 0]), handleVertex(indices[j + 1]), handleVertex(indices[j + 2])
		}
	}
	computeVertexNormals() {
		let index = this.index,
			positionAttribute = this.getAttribute("position");
		if (void 0 !== positionAttribute) {
			let normalAttribute = this.getAttribute("normal");
			if (void 0 === normalAttribute) normalAttribute = new BufferAttribute(new Float32Array(3 * positionAttribute.count), 3), this.setAttribute("normal", normalAttribute);
			else
				for (let i = 0, il = normalAttribute.count; i < il; i++) normalAttribute.setXYZ(i, 0, 0, 0);
			let pA = new Vector3,
				pB = new Vector3,
				pC = new Vector3,
				nA = new Vector3,
				nB = new Vector3,
				nC = new Vector3,
				cb = new Vector3,
				ab = new Vector3;
			if (index)
				for (let i = 0, il = index.count; i < il; i += 3) {
					let vA = index.getX(i + 0),
						vB = index.getX(i + 1),
						vC = index.getX(i + 2);
					pA.fromBufferAttribute(positionAttribute, vA), pB.fromBufferAttribute(positionAttribute, vB), pC.fromBufferAttribute(positionAttribute, vC), cb.subVectors(pC, pB), ab.subVectors(pA, pB), cb.cross(ab), nA.fromBufferAttribute(normalAttribute, vA), nB.fromBufferAttribute(normalAttribute, vB), nC.fromBufferAttribute(normalAttribute, vC), nA.add(cb), nB.add(cb), nC.add(cb), normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z), normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z), normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z)
				} else
					for (let i = 0, il = positionAttribute.count; i < il; i += 3) pA.fromBufferAttribute(positionAttribute, i + 0), pB.fromBufferAttribute(positionAttribute, i + 1), pC.fromBufferAttribute(positionAttribute, i + 2), cb.subVectors(pC, pB), ab.subVectors(pA, pB), cb.cross(ab), normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z), normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z), normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
			this.normalizeNormals(), normalAttribute.needsUpdate = !0
		}
	}
	normalizeNormals() {
		let normals = this.attributes.normal;
		for (let i = 0, il = normals.count; i < il; i++) _vector$8.fromBufferAttribute(normals, i), _vector$8.normalize(), normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z)
	}
	toNonIndexed() {
		function convertBufferAttribute(attribute, indices) {
			let array = attribute.array,
				itemSize = attribute.itemSize,
				normalized = attribute.normalized,
				array2 = new array.constructor(indices.length * itemSize),
				index = 0,
				index2 = 0;
			for (let i = 0, l = indices.length; i < l; i++) {
				index = attribute.isInterleavedBufferAttribute ? indices[i] * attribute.data.stride + attribute.offset : indices[i] * itemSize;
				for (let j = 0; j < itemSize; j++) array2[index2++] = array[index++]
			}
			return new BufferAttribute(array2, itemSize, normalized)
		}
		if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
		let geometry2 = new BufferGeometry,
			indices = this.index.array,
			attributes = this.attributes;
		for (let name in attributes) {
			let newAttribute = convertBufferAttribute(attributes[name], indices);
			geometry2.setAttribute(name, newAttribute)
		}
		let morphAttributes = this.morphAttributes;
		for (let name in morphAttributes) {
			let morphArray = [],
				morphAttribute = morphAttributes[name];
			for (let i = 0, il = morphAttribute.length; i < il; i++) {
				let newAttribute = convertBufferAttribute(morphAttribute[i], indices);
				morphArray.push(newAttribute)
			}
			geometry2.morphAttributes[name] = morphArray
		}
		geometry2.morphTargetsRelative = this.morphTargetsRelative;
		let groups = this.groups;
		for (let i = 0, l = groups.length; i < l; i++) {
			let group = groups[i];
			geometry2.addGroup(group.start, group.count, group.materialIndex)
		}
		return geometry2
	}
	toJSON() {
		let data = {
			metadata: {
				version: 4.6,
				type: "BufferGeometry",
				generator: "BufferGeometry.toJSON"
			}
		};
		if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), Object.keys(this.userData).length > 0 && (data.userData = this.userData), void 0 !== this.parameters) {
			let parameters = this.parameters;
			for (let key in parameters) void 0 !== parameters[key] && (data[key] = parameters[key]);
			return data
		}
		data.data = {
			attributes: {}
		};
		let index = this.index;
		null !== index && (data.data.index = {
			type: index.array.constructor.name,
			array: Array.prototype.slice.call(index.array)
		});
		let attributes = this.attributes;
		for (let key in attributes) {
			let attribute = attributes[key];
			data.data.attributes[key] = attribute.toJSON(data.data)
		}
		let morphAttributes = {},
			hasMorphAttributes = !1;
		for (let key in this.morphAttributes) {
			let attributeArray = this.morphAttributes[key],
				array = [];
			for (let i = 0, il = attributeArray.length; i < il; i++) {
				let attribute = attributeArray[i];
				array.push(attribute.toJSON(data.data))
			}
			array.length > 0 && (morphAttributes[key] = array, hasMorphAttributes = !0)
		}
		hasMorphAttributes && (data.data.morphAttributes = morphAttributes, data.data.morphTargetsRelative = this.morphTargetsRelative);
		let groups = this.groups;
		groups.length > 0 && (data.data.groups = JSON.parse(JSON.stringify(groups)));
		let boundingSphere = this.boundingSphere;
		return null !== boundingSphere && (data.data.boundingSphere = {
			center: boundingSphere.center.toArray(),
			radius: boundingSphere.radius
		}), data
	}
	clone() {
		return new this.constructor().copy(this)
	}
	copy(source) {
		this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
		let data = {};
		this.name = source.name;
		let index = source.index;
		null !== index && this.setIndex(index.clone(data));
		let attributes = source.attributes;
		for (let name in attributes) {
			let attribute = attributes[name];
			this.setAttribute(name, attribute.clone(data))
		}
		let morphAttributes = source.morphAttributes;
		for (let name in morphAttributes) {
			let array = [],
				morphAttribute = morphAttributes[name];
			for (let i = 0, l = morphAttribute.length; i < l; i++) array.push(morphAttribute[i].clone(data));
			this.morphAttributes[name] = array
		}
		this.morphTargetsRelative = source.morphTargetsRelative;
		let groups = source.groups;
		for (let i = 0, l = groups.length; i < l; i++) {
			let group = groups[i];
			this.addGroup(group.start, group.count, group.materialIndex)
		}
		let boundingBox = source.boundingBox;
		null !== boundingBox && (this.boundingBox = boundingBox.clone());
		let boundingSphere = source.boundingSphere;
		return null !== boundingSphere && (this.boundingSphere = boundingSphere.clone()), this.drawRange.start = source.drawRange.start, this.drawRange.count = source.drawRange.count, this.userData = source.userData, this
	}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
let _inverseMatrix$3 = new Matrix4,
	_ray$3 = new Ray,
	_sphere$6 = new Sphere,
	_sphereHitAt = new Vector3,
	_vA$1 = new Vector3,
	_vB$1 = new Vector3,
	_vC$1 = new Vector3,
	_tempA = new Vector3,
	_morphA = new Vector3,
	_uvA$1 = new Vector2,
	_uvB$1 = new Vector2,
	_uvC$1 = new Vector2,
	_normalA = new Vector3,
	_normalB = new Vector3,
	_normalC = new Vector3,
	_intersectionPoint = new Vector3,
	_intersectionPointWorld = new Vector3;
class Mesh extends Object3D {
	constructor(geometry = new BufferGeometry, material = new MeshBasicMaterial) {
		super(), this.isMesh = !0, this.type = "Mesh", this.geometry = geometry, this.material = material, this.updateMorphTargets()
	}
	copy(source, recursive) {
		return super.copy(source, recursive), void 0 !== source.morphTargetInfluences && (this.morphTargetInfluences = source.morphTargetInfluences.slice()), void 0 !== source.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary)), this.material = Array.isArray(source.material) ? source.material.slice() : source.material, this.geometry = source.geometry, this
	}
	updateMorphTargets() {
		let morphAttributes = this.geometry.morphAttributes,
			keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			let morphAttribute = morphAttributes[keys[0]];
			if (void 0 !== morphAttribute) {
				this.morphTargetInfluences = [], this.morphTargetDictionary = {};
				for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
					let name = morphAttribute[m].name || String(m);
					this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m
				}
			}
		}
	}
	getVertexPosition(index, target) {
		let geometry = this.geometry,
			position = geometry.attributes.position,
			morphPosition = geometry.morphAttributes.position,
			morphTargetsRelative = geometry.morphTargetsRelative;
		target.fromBufferAttribute(position, index);
		let morphInfluences = this.morphTargetInfluences;
		if (morphPosition && morphInfluences) {
			_morphA.set(0, 0, 0);
			for (let i = 0, il = morphPosition.length; i < il; i++) {
				let influence = morphInfluences[i],
					morphAttribute = morphPosition[i];
				0 !== influence && (_tempA.fromBufferAttribute(morphAttribute, index), morphTargetsRelative ? _morphA.addScaledVector(_tempA, influence) : _morphA.addScaledVector(_tempA.sub(target), influence))
			}
			target.add(_morphA)
		}
		return target
	}
	raycast(raycaster, intersects) {
		let geometry = this.geometry,
			material = this.material,
			matrixWorld = this.matrixWorld;
		if (void 0 !== material) {
			if (null === geometry.boundingSphere && geometry.computeBoundingSphere(), _sphere$6.copy(geometry.boundingSphere), _sphere$6.applyMatrix4(matrixWorld), _ray$3.copy(raycaster.ray).recast(raycaster.near), !1 === _sphere$6.containsPoint(_ray$3.origin) && (null === _ray$3.intersectSphere(_sphere$6, _sphereHitAt) || _ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) || (_inverseMatrix$3.copy(matrixWorld).invert(), _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3), null !== geometry.boundingBox && !1 === _ray$3.intersectsBox(geometry.boundingBox))) return;
			this._computeIntersections(raycaster, intersects, _ray$3)
		}
	}
	_computeIntersections(raycaster, intersects, rayLocalSpace) {
		let intersection;
		let geometry = this.geometry,
			material = this.material,
			index = geometry.index,
			position = geometry.attributes.position,
			uv = geometry.attributes.uv,
			uv1 = geometry.attributes.uv1,
			normal = geometry.attributes.normal,
			groups = geometry.groups,
			drawRange = geometry.drawRange;
		if (null !== index) {
			if (Array.isArray(material))
				for (let i = 0, il = groups.length; i < il; i++) {
					let group = groups[i],
						groupMaterial = material[group.materialIndex],
						start = Math.max(group.start, drawRange.start),
						end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
					for (let j = start; j < end; j += 3)(intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, index.getX(j), index.getX(j + 1), index.getX(j + 2))) && (intersection.faceIndex = Math.floor(j / 3), intersection.face.materialIndex = group.materialIndex, intersects.push(intersection))
				} else {
					let start = Math.max(0, drawRange.start),
						end = Math.min(index.count, drawRange.start + drawRange.count);
					for (let i = start; i < end; i += 3)(intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, index.getX(i), index.getX(i + 1), index.getX(i + 2))) && (intersection.faceIndex = Math.floor(i / 3), intersects.push(intersection))
				}
		} else if (void 0 !== position) {
			if (Array.isArray(material))
				for (let i = 0, il = groups.length; i < il; i++) {
					let group = groups[i],
						groupMaterial = material[group.materialIndex],
						start = Math.max(group.start, drawRange.start),
						end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
					for (let j = start; j < end; j += 3)(intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, j, j + 1, j + 2)) && (intersection.faceIndex = Math.floor(j / 3), intersection.face.materialIndex = group.materialIndex, intersects.push(intersection))
				} else {
					let start = Math.max(0, drawRange.start),
						end = Math.min(position.count, drawRange.start + drawRange.count);
					for (let i = start; i < end; i += 3)(intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, i, i + 1, i + 2)) && (intersection.faceIndex = Math.floor(i / 3), intersects.push(intersection))
				}
		}
	}
}

function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
	object.getVertexPosition(a, _vA$1), object.getVertexPosition(b, _vB$1), object.getVertexPosition(c, _vC$1);
	let intersection = function(object, material, raycaster, ray, pA, pB, pC, point) {
		if (null === (1 === material.side ? ray.intersectTriangle(pC, pB, pA, !0, point) : ray.intersectTriangle(pA, pB, pC, 0 === material.side, point))) return null;
		_intersectionPointWorld.copy(point), _intersectionPointWorld.applyMatrix4(object.matrixWorld);
		let distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
		return distance < raycaster.near || distance > raycaster.far ? null : {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		}
	}(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
	if (intersection) {
		uv && (_uvA$1.fromBufferAttribute(uv, a), _uvB$1.fromBufferAttribute(uv, b), _uvC$1.fromBufferAttribute(uv, c), intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2)), uv1 && (_uvA$1.fromBufferAttribute(uv1, a), _uvB$1.fromBufferAttribute(uv1, b), _uvC$1.fromBufferAttribute(uv1, c), intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2), intersection.uv2 = intersection.uv1), normal && (_normalA.fromBufferAttribute(normal, a), _normalB.fromBufferAttribute(normal, b), _normalC.fromBufferAttribute(normal, c), intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3), intersection.normal.dot(ray.direction) > 0 && intersection.normal.multiplyScalar(-1));
		let face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3,
			materialIndex: 0
		};
		Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal), intersection.face = face
	}
	return intersection
}
class BoxGeometry extends BufferGeometry {
	constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
		super(), this.type = "BoxGeometry", this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
		let scope = this;
		widthSegments = Math.floor(widthSegments), heightSegments = Math.floor(heightSegments);
		let indices = [],
			vertices = [],
			normals = [],
			uvs = [],
			numberOfVertices = 0,
			groupStart = 0;

		function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
			let segmentWidth = width / gridX,
				segmentHeight = height / gridY,
				widthHalf = width / 2,
				heightHalf = height / 2,
				depthHalf = depth / 2,
				gridX1 = gridX + 1,
				gridY1 = gridY + 1,
				vertexCounter = 0,
				groupCount = 0,
				vector = new Vector3;
			for (let iy = 0; iy < gridY1; iy++) {
				let y = iy * segmentHeight - heightHalf;
				for (let ix = 0; ix < gridX1; ix++) {
					let x = ix * segmentWidth - widthHalf;
					vector[u] = x * udir, vector[v] = y * vdir, vector[w] = depthHalf, vertices.push(vector.x, vector.y, vector.z), vector[u] = 0, vector[v] = 0, vector[w] = depth > 0 ? 1 : -1, normals.push(vector.x, vector.y, vector.z), uvs.push(ix / gridX), uvs.push(1 - iy / gridY), vertexCounter += 1
				}
			}
			for (let iy = 0; iy < gridY; iy++)
				for (let ix = 0; ix < gridX; ix++) {
					let a = numberOfVertices + ix + gridX1 * iy,
						b = numberOfVertices + ix + gridX1 * (iy + 1),
						c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1),
						d = numberOfVertices + (ix + 1) + gridX1 * iy;
					indices.push(a, b, d), indices.push(b, c, d), groupCount += 6
				}
			scope.addGroup(groupStart, groupCount, materialIndex), groupStart += groupCount, numberOfVertices += vertexCounter
		}
		buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments = Math.floor(depthSegments), heightSegments, 0), buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1), buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2), buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3), buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4), buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5), this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2))
	}
	copy(source) {
		return super.copy(source), this.parameters = Object.assign({}, source.parameters), this
	}
	static fromJSON(data) {
		return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments)
	}
}

function cloneUniforms(src) {
	let dst = {};
	for (let u in src)
		for (let p in dst[u] = {}, src[u]) {
			let property = src[u][p];
			property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion) ? property.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), dst[u][p] = null) : dst[u][p] = property.clone() : Array.isArray(property) ? dst[u][p] = property.slice() : dst[u][p] = property
		}
	return dst
}

function mergeUniforms(uniforms) {
	let merged = {};
	for (let u = 0; u < uniforms.length; u++) {
		let tmp = cloneUniforms(uniforms[u]);
		for (let p in tmp) merged[p] = tmp[p]
	}
	return merged
}

function getUnlitUniformColorSpace(renderer) {
	return null === renderer.getRenderTarget() ? renderer.outputColorSpace : ColorManagement.workingColorSpace
}
let UniformsUtils = {
	clone: cloneUniforms,
	merge: mergeUniforms
};
class ShaderMaterial extends Material$1 {
	constructor(parameters) {
		super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
			derivatives: !1,
			fragDepth: !1,
			drawBuffers: !1,
			shaderTextureLOD: !1,
			clipCullDistance: !1
		}, this.defaultAttributeValues = {
			color: [1, 1, 1],
			uv: [0, 0],
			uv1: [0, 0]
		}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== parameters && this.setValues(parameters)
	}
	copy(source) {
		return super.copy(source), this.fragmentShader = source.fragmentShader, this.vertexShader = source.vertexShader, this.uniforms = cloneUniforms(source.uniforms), this.uniformsGroups = function(src) {
			let dst = [];
			for (let u = 0; u < src.length; u++) dst.push(src[u].clone());
			return dst
		}(source.uniformsGroups), this.defines = Object.assign({}, source.defines), this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.fog = source.fog, this.lights = source.lights, this.clipping = source.clipping, this.extensions = Object.assign({}, source.extensions), this.glslVersion = source.glslVersion, this
	}
	toJSON(meta) {
		let data = super.toJSON(meta);
		for (let name in data.glslVersion = this.glslVersion, data.uniforms = {}, this.uniforms) {
			let value = this.uniforms[name].value;
			value && value.isTexture ? data.uniforms[name] = {
				type: "t",
				value: value.toJSON(meta).uuid
			} : value && value.isColor ? data.uniforms[name] = {
				type: "c",
				value: value.getHex()
			} : value && value.isVector2 ? data.uniforms[name] = {
				type: "v2",
				value: value.toArray()
			} : value && value.isVector3 ? data.uniforms[name] = {
				type: "v3",
				value: value.toArray()
			} : value && value.isVector4 ? data.uniforms[name] = {
				type: "v4",
				value: value.toArray()
			} : value && value.isMatrix3 ? data.uniforms[name] = {
				type: "m3",
				value: value.toArray()
			} : value && value.isMatrix4 ? data.uniforms[name] = {
				type: "m4",
				value: value.toArray()
			} : data.uniforms[name] = {
				value: value
			}
		}
		Object.keys(this.defines).length > 0 && (data.defines = this.defines), data.vertexShader = this.vertexShader, data.fragmentShader = this.fragmentShader, data.lights = this.lights, data.clipping = this.clipping;
		let extensions = {};
		for (let key in this.extensions) !0 === this.extensions[key] && (extensions[key] = !0);
		return Object.keys(extensions).length > 0 && (data.extensions = extensions), data
	}
}
class Camera extends Object3D {
	constructor() {
		super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Matrix4, this.projectionMatrix = new Matrix4, this.projectionMatrixInverse = new Matrix4, this.coordinateSystem = 2e3
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.matrixWorldInverse.copy(source.matrixWorldInverse), this.projectionMatrix.copy(source.projectionMatrix), this.projectionMatrixInverse.copy(source.projectionMatrixInverse), this.coordinateSystem = source.coordinateSystem, this
	}
	getWorldDirection(target) {
		return super.getWorldDirection(target).negate()
	}
	updateMatrixWorld(force) {
		super.updateMatrixWorld(force), this.matrixWorldInverse.copy(this.matrixWorld).invert()
	}
	updateWorldMatrix(updateParents, updateChildren) {
		super.updateWorldMatrix(updateParents, updateChildren), this.matrixWorldInverse.copy(this.matrixWorld).invert()
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
class PerspectiveCamera extends Camera {
	constructor(fov = 50, aspect = 1, near = .1, far = 2e3) {
		super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = fov, this.zoom = 1, this.near = near, this.far = far, this.focus = 10, this.aspect = aspect, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.fov = source.fov, this.zoom = source.zoom, this.near = source.near, this.far = source.far, this.focus = source.focus, this.aspect = source.aspect, this.view = null === source.view ? null : Object.assign({}, source.view), this.filmGauge = source.filmGauge, this.filmOffset = source.filmOffset, this
	}
	setFocalLength(focalLength) {
		let vExtentSlope = .5 * this.getFilmHeight() / focalLength;
		this.fov = 2 * RAD2DEG * Math.atan(vExtentSlope), this.updateProjectionMatrix()
	}
	getFocalLength() {
		let vExtentSlope = Math.tan(.5 * DEG2RAD * this.fov);
		return .5 * this.getFilmHeight() / vExtentSlope
	}
	getEffectiveFOV() {
		return 2 * RAD2DEG * Math.atan(Math.tan(.5 * DEG2RAD * this.fov) / this.zoom)
	}
	getFilmWidth() {
		return this.filmGauge * Math.min(this.aspect, 1)
	}
	getFilmHeight() {
		return this.filmGauge / Math.max(this.aspect, 1)
	}
	setViewOffset(fullWidth, fullHeight, x, y, width, height) {
		this.aspect = fullWidth / fullHeight, null === this.view && (this.view = {
			enabled: !0,
			fullWidth: 1,
			fullHeight: 1,
			offsetX: 0,
			offsetY: 0,
			width: 1,
			height: 1
		}), this.view.enabled = !0, this.view.fullWidth = fullWidth, this.view.fullHeight = fullHeight, this.view.offsetX = x, this.view.offsetY = y, this.view.width = width, this.view.height = height, this.updateProjectionMatrix()
	}
	clearViewOffset() {
		null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
	}
	updateProjectionMatrix() {
		let near = this.near,
			top = near * Math.tan(.5 * DEG2RAD * this.fov) / this.zoom,
			height = 2 * top,
			width = this.aspect * height,
			left = -.5 * width,
			view = this.view;
		if (null !== this.view && this.view.enabled) {
			let fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;
			left += view.offsetX * width / fullWidth, top -= view.offsetY * height / fullHeight, width *= view.width / fullWidth, height *= view.height / fullHeight
		}
		let skew = this.filmOffset;
		0 !== skew && (left += near * skew / this.getFilmWidth()), this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
	}
	toJSON(meta) {
		let data = super.toJSON(meta);
		return data.object.fov = this.fov, data.object.zoom = this.zoom, data.object.near = this.near, data.object.far = this.far, data.object.focus = this.focus, data.object.aspect = this.aspect, null !== this.view && (data.object.view = Object.assign({}, this.view)), data.object.filmGauge = this.filmGauge, data.object.filmOffset = this.filmOffset, data
	}
}
class CubeCamera extends Object3D {
	constructor(near, far, renderTarget) {
		super(), this.type = "CubeCamera", this.renderTarget = renderTarget, this.coordinateSystem = null, this.activeMipmapLevel = 0;
		let cameraPX = new PerspectiveCamera(-90, 1, near, far);
		cameraPX.layers = this.layers, this.add(cameraPX);
		let cameraNX = new PerspectiveCamera(-90, 1, near, far);
		cameraNX.layers = this.layers, this.add(cameraNX);
		let cameraPY = new PerspectiveCamera(-90, 1, near, far);
		cameraPY.layers = this.layers, this.add(cameraPY);
		let cameraNY = new PerspectiveCamera(-90, 1, near, far);
		cameraNY.layers = this.layers, this.add(cameraNY);
		let cameraPZ = new PerspectiveCamera(-90, 1, near, far);
		cameraPZ.layers = this.layers, this.add(cameraPZ);
		let cameraNZ = new PerspectiveCamera(-90, 1, near, far);
		cameraNZ.layers = this.layers, this.add(cameraNZ)
	}
	updateCoordinateSystem() {
		let coordinateSystem = this.coordinateSystem,
			cameras = this.children.concat(),
			[cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
		for (let camera of cameras) this.remove(camera);
		if (2e3 === coordinateSystem) cameraPX.up.set(0, 1, 0), cameraPX.lookAt(1, 0, 0), cameraNX.up.set(0, 1, 0), cameraNX.lookAt(-1, 0, 0), cameraPY.up.set(0, 0, -1), cameraPY.lookAt(0, 1, 0), cameraNY.up.set(0, 0, 1), cameraNY.lookAt(0, -1, 0), cameraPZ.up.set(0, 1, 0), cameraPZ.lookAt(0, 0, 1), cameraNZ.up.set(0, 1, 0), cameraNZ.lookAt(0, 0, -1);
		else if (2001 === coordinateSystem) cameraPX.up.set(0, -1, 0), cameraPX.lookAt(-1, 0, 0), cameraNX.up.set(0, -1, 0), cameraNX.lookAt(1, 0, 0), cameraPY.up.set(0, 0, 1), cameraPY.lookAt(0, 1, 0), cameraNY.up.set(0, 0, -1), cameraNY.lookAt(0, -1, 0), cameraPZ.up.set(0, -1, 0), cameraPZ.lookAt(0, 0, 1), cameraNZ.up.set(0, -1, 0), cameraNZ.lookAt(0, 0, -1);
		else throw Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
		for (let camera of cameras) this.add(camera), camera.updateMatrixWorld()
	}
	update(renderer, scene) {
		null === this.parent && this.updateMatrixWorld();
		let {
			renderTarget,
			activeMipmapLevel
		} = this;
		this.coordinateSystem !== renderer.coordinateSystem && (this.coordinateSystem = renderer.coordinateSystem, this.updateCoordinateSystem());
		let [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children, currentRenderTarget = renderer.getRenderTarget(), currentActiveCubeFace = renderer.getActiveCubeFace(), currentActiveMipmapLevel = renderer.getActiveMipmapLevel(), currentXrEnabled = renderer.xr.enabled;
		renderer.xr.enabled = !1;
		let generateMipmaps = renderTarget.texture.generateMipmaps;
		renderTarget.texture.generateMipmaps = !1, renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel), renderer.render(scene, cameraPX), renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel), renderer.render(scene, cameraNX), renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel), renderer.render(scene, cameraPY), renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel), renderer.render(scene, cameraNY), renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel), renderer.render(scene, cameraPZ), renderTarget.texture.generateMipmaps = generateMipmaps, renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel), renderer.render(scene, cameraNZ), renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel), renderer.xr.enabled = currentXrEnabled, renderTarget.texture.needsPMREMUpdate = !0
	}
}
class CubeTexture extends Texture$1 {
	constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace1) {
		super(images = void 0 !== images ? images : [], mapping = void 0 !== mapping ? mapping : 301, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace1), this.isCubeTexture = !0, this.flipY = !1
	}
	get images() {
		return this.image
	}
	set images(value) {
		this.image = value
	}
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
	constructor(size = 1, options = {}) {
		super(size, size, options), this.isWebGLCubeRenderTarget = !0;
		let image = {
			width: size,
			height: size,
			depth: 1
		};
		void 0 !== options.encoding && (warnOnce("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), options.colorSpace = 3001 === options.encoding ? SRGBColorSpace : ""), this.texture = new CubeTexture([image, image, image, image, image, image], options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== options.generateMipmaps && options.generateMipmaps, this.texture.minFilter = void 0 !== options.minFilter ? options.minFilter : 1006
	}
	fromEquirectangularTexture(renderer, texture) {
		this.texture.type = texture.type, this.texture.colorSpace = texture.colorSpace, this.texture.generateMipmaps = texture.generateMipmaps, this.texture.minFilter = texture.minFilter, this.texture.magFilter = texture.magFilter;
		let shader = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
				fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			},
			geometry = new BoxGeometry(5, 5, 5),
			material = new ShaderMaterial({
				name: "CubemapFromEquirect",
				uniforms: cloneUniforms(shader.uniforms),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: 1,
				blending: 0
			});
		material.uniforms.tEquirect.value = texture;
		let mesh = new Mesh(geometry, material),
			currentMinFilter = texture.minFilter;
		return 1008 === texture.minFilter && (texture.minFilter = 1006), new CubeCamera(1, 10, this).update(renderer, mesh), texture.minFilter = currentMinFilter, mesh.geometry.dispose(), mesh.material.dispose(), this
	}
	clear(renderer, color, depth, stencil) {
		let currentRenderTarget = renderer.getRenderTarget();
		for (let i = 0; i < 6; i++) renderer.setRenderTarget(this, i), renderer.clear(color, depth, stencil);
		renderer.setRenderTarget(currentRenderTarget)
	}
}
let _vector1 = new Vector3,
	_vector2 = new Vector3,
	_normalMatrix = new Matrix3;
class Plane {
	constructor(normal = new Vector3(1, 0, 0), constant = 0) {
		this.isPlane = !0, this.normal = normal, this.constant = constant
	}
	set(normal, constant) {
		return this.normal.copy(normal), this.constant = constant, this
	}
	setComponents(x, y, z, w) {
		return this.normal.set(x, y, z), this.constant = w, this
	}
	setFromNormalAndCoplanarPoint(normal, point) {
		return this.normal.copy(normal), this.constant = -point.dot(this.normal), this
	}
	setFromCoplanarPoints(a, b, c) {
		let normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
		return this.setFromNormalAndCoplanarPoint(normal, a), this
	}
	copy(plane) {
		return this.normal.copy(plane.normal), this.constant = plane.constant, this
	}
	normalize() {
		let inverseNormalLength = 1 / this.normal.length();
		return this.normal.multiplyScalar(inverseNormalLength), this.constant *= inverseNormalLength, this
	}
	negate() {
		return this.constant *= -1, this.normal.negate(), this
	}
	distanceToPoint(point) {
		return this.normal.dot(point) + this.constant
	}
	distanceToSphere(sphere) {
		return this.distanceToPoint(sphere.center) - sphere.radius
	}
	projectPoint(point, target) {
		return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point))
	}
	intersectLine(line, target) {
		let direction = line.delta(_vector1),
			denominator = this.normal.dot(direction);
		if (0 === denominator) return 0 === this.distanceToPoint(line.start) ? target.copy(line.start) : null;
		let t = -(line.start.dot(this.normal) + this.constant) / denominator;
		return t < 0 || t > 1 ? null : target.copy(line.start).addScaledVector(direction, t)
	}
	intersectsLine(line) {
		let startSign = this.distanceToPoint(line.start),
			endSign = this.distanceToPoint(line.end);
		return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0
	}
	intersectsBox(box) {
		return box.intersectsPlane(this)
	}
	intersectsSphere(sphere) {
		return sphere.intersectsPlane(this)
	}
	coplanarPoint(target) {
		return target.copy(this.normal).multiplyScalar(-this.constant)
	}
	applyMatrix4(matrix, optionalNormalMatrix) {
		let normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix),
			referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix),
			normal = this.normal.applyMatrix3(normalMatrix).normalize();
		return this.constant = -referencePoint.dot(normal), this
	}
	translate(offset) {
		return this.constant -= offset.dot(this.normal), this
	}
	equals(plane) {
		return plane.normal.equals(this.normal) && plane.constant === this.constant
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
let _sphere$5 = new Sphere,
	_vector$7 = new Vector3;
class Frustum {
	constructor(p0 = new Plane, p1 = new Plane, p2 = new Plane, p3 = new Plane, p4 = new Plane, p5 = new Plane) {
		this.planes = [p0, p1, p2, p3, p4, p5]
	}
	set(p0, p1, p2, p3, p4, p5) {
		let planes = this.planes;
		return planes[0].copy(p0), planes[1].copy(p1), planes[2].copy(p2), planes[3].copy(p3), planes[4].copy(p4), planes[5].copy(p5), this
	}
	copy(frustum) {
		let planes = this.planes;
		for (let i = 0; i < 6; i++) planes[i].copy(frustum.planes[i]);
		return this
	}
	setFromProjectionMatrix(m, coordinateSystem = 2e3) {
		let planes = this.planes,
			me = m.elements,
			me0 = me[0],
			me1 = me[1],
			me2 = me[2],
			me3 = me[3],
			me4 = me[4],
			me5 = me[5],
			me6 = me[6],
			me7 = me[7],
			me8 = me[8],
			me9 = me[9],
			me10 = me[10],
			me11 = me[11],
			me12 = me[12],
			me13 = me[13],
			me14 = me[14],
			me15 = me[15];
		if (planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize(), planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize(), planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize(), planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize(), planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize(), 2e3 === coordinateSystem) planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
		else if (2001 === coordinateSystem) planes[5].setComponents(me2, me6, me10, me14).normalize();
		else throw Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
		return this
	}
	intersectsObject(object) {
		if (void 0 !== object.boundingSphere) null === object.boundingSphere && object.computeBoundingSphere(), _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
		else {
			let geometry = object.geometry;
			null === geometry.boundingSphere && geometry.computeBoundingSphere(), _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld)
		}
		return this.intersectsSphere(_sphere$5)
	}
	intersectsSprite(sprite) {
		return _sphere$5.center.set(0, 0, 0), _sphere$5.radius = .7071067811865476, _sphere$5.applyMatrix4(sprite.matrixWorld), this.intersectsSphere(_sphere$5)
	}
	intersectsSphere(sphere) {
		let planes = this.planes,
			center = sphere.center,
			negRadius = -sphere.radius;
		for (let i = 0; i < 6; i++)
			if (planes[i].distanceToPoint(center) < negRadius) return !1;
		return !0
	}
	intersectsBox(box) {
		let planes = this.planes;
		for (let i = 0; i < 6; i++) {
			let plane = planes[i];
			if (_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x, _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y, _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z, 0 > plane.distanceToPoint(_vector$7)) return !1
		}
		return !0
	}
	containsPoint(point) {
		let planes = this.planes;
		for (let i = 0; i < 6; i++)
			if (0 > planes[i].distanceToPoint(point)) return !1;
		return !0
	}
	clone() {
		return new this.constructor().copy(this)
	}
}

function WebGLAnimation() {
	let context = null,
		isAnimating = !1,
		animationLoop = null,
		requestId = null;

	function onAnimationFrame(time, frame) {
		animationLoop(time, frame), requestId = context.requestAnimationFrame(onAnimationFrame)
	}
	return {
		start: function() {
			!0 !== isAnimating && null !== animationLoop && (requestId = context.requestAnimationFrame(onAnimationFrame), isAnimating = !0)
		},
		stop: function() {
			context.cancelAnimationFrame(requestId), isAnimating = !1
		},
		setAnimationLoop: function(callback) {
			animationLoop = callback
		},
		setContext: function(value) {
			context = value
		}
	}
}

function WebGLAttributes(gl, capabilities) {
	let isWebGL2 = capabilities.isWebGL2,
		buffers = new WeakMap;
	return {
		get: function(attribute) {
			return attribute.isInterleavedBufferAttribute && (attribute = attribute.data), buffers.get(attribute)
		},
		remove: function(attribute) {
			attribute.isInterleavedBufferAttribute && (attribute = attribute.data);
			let data = buffers.get(attribute);
			data && (gl.deleteBuffer(data.buffer), buffers.delete(attribute))
		},
		update: function(attribute, bufferType) {
			if (attribute.isGLBufferAttribute) {
				let cached = buffers.get(attribute);
				(!cached || cached.version < attribute.version) && buffers.set(attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				});
				return
			}
			attribute.isInterleavedBufferAttribute && (attribute = attribute.data);
			let data = buffers.get(attribute);
			if (void 0 === data) buffers.set(attribute, function(attribute, bufferType) {
				let type;
				let array = attribute.array,
					usage = attribute.usage,
					size = array.byteLength,
					buffer = gl.createBuffer();
				if (gl.bindBuffer(bufferType, buffer), gl.bufferData(bufferType, array, usage), attribute.onUploadCallback(), array instanceof Float32Array) type = gl.FLOAT;
				else if (array instanceof Uint16Array) {
					if (attribute.isFloat16BufferAttribute) {
						if (isWebGL2) type = gl.HALF_FLOAT;
						else throw Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.")
					} else type = gl.UNSIGNED_SHORT
				} else if (array instanceof Int16Array) type = gl.SHORT;
				else if (array instanceof Uint32Array) type = gl.UNSIGNED_INT;
				else if (array instanceof Int32Array) type = gl.INT;
				else if (array instanceof Int8Array) type = gl.BYTE;
				else if (array instanceof Uint8Array) type = gl.UNSIGNED_BYTE;
				else if (array instanceof Uint8ClampedArray) type = gl.UNSIGNED_BYTE;
				else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
				return {
					buffer: buffer,
					type: type,
					bytesPerElement: array.BYTES_PER_ELEMENT,
					version: attribute.version,
					size: size
				}
			}(attribute, bufferType));
			else if (data.version < attribute.version) {
				if (data.size !== attribute.array.byteLength) throw Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
				! function(buffer, attribute, bufferType) {
					let array = attribute.array,
						updateRange = attribute._updateRange,
						updateRanges = attribute.updateRanges;
					if (gl.bindBuffer(bufferType, buffer), -1 === updateRange.count && 0 === updateRanges.length && gl.bufferSubData(bufferType, 0, array), 0 !== updateRanges.length) {
						for (let i = 0, l = updateRanges.length; i < l; i++) {
							let range = updateRanges[i];
							isWebGL2 ? gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT, array, range.start, range.count) : gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT, array.subarray(range.start, range.start + range.count))
						}
						attribute.clearUpdateRanges()
					} - 1 !== updateRange.count && (isWebGL2 ? gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count) : gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count)), updateRange.count = -1), attribute.onUploadCallback()
				}(data.buffer, attribute, bufferType), data.version = attribute.version
			}
		}
	}
}
class PlaneGeometry extends BufferGeometry {
	constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
		super(), this.type = "PlaneGeometry", this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
		let width_half = width / 2,
			height_half = height / 2,
			gridX = Math.floor(widthSegments),
			gridY = Math.floor(heightSegments),
			gridX1 = gridX + 1,
			gridY1 = gridY + 1,
			segment_width = width / gridX,
			segment_height = height / gridY,
			indices = [],
			vertices = [],
			normals = [],
			uvs = [];
		for (let iy = 0; iy < gridY1; iy++) {
			let y = iy * segment_height - height_half;
			for (let ix = 0; ix < gridX1; ix++) {
				let x = ix * segment_width - width_half;
				vertices.push(x, -y, 0), normals.push(0, 0, 1), uvs.push(ix / gridX), uvs.push(1 - iy / gridY)
			}
		}
		for (let iy = 0; iy < gridY; iy++)
			for (let ix = 0; ix < gridX; ix++) {
				let a = ix + gridX1 * iy,
					b = ix + gridX1 * (iy + 1),
					c = ix + 1 + gridX1 * (iy + 1),
					d = ix + 1 + gridX1 * iy;
				indices.push(a, b, d), indices.push(b, c, d)
			}
		this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2))
	}
	copy(source) {
		return super.copy(source), this.parameters = Object.assign({}, source.parameters), this
	}
	static fromJSON(data) {
		return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments)
	}
}
let ShaderChunk = {
		alphahash_fragment: "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
		alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif",
		alphamap_fragment: "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
		alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
		alphatest_fragment: "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif",
		alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif",
		aomap_fragment: "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif",
		aomap_pars_fragment: "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
		batching_pars_vertex: "#ifdef USE_BATCHING\n	attribute float batchId;\n	uniform highp sampler2D batchingTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif",
		batching_vertex: "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
		begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif",
		beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif",
		bsdfs: "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated",
		iridescence_fragment: "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif",
		bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif",
		clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif",
		clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
		clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif",
		clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif",
		color_fragment: "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif",
		color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif",
		color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif",
		color_vertex: "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif",
		common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
		cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif",
		defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif",
		displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif",
		displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
		emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
		emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif",
		colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
		colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return sRGBTransferOETF( value );\n}",
		envmap_fragment: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif",
		envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif",
		envmap_pars_fragment: "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif",
		envmap_pars_vertex: "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif",
		envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif",
		envmap_vertex: "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif",
		fog_vertex: "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif",
		fog_pars_vertex: "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif",
		fog_fragment: "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
		fog_pars_fragment: "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
		gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}",
		lightmap_fragment: "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
		lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
		lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
		lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert",
		lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif",
		lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
		lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon",
		lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
		lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong",
		lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
		lights_physical_pars_fragment: "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
		lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
		lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif",
		lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
		logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
		logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif",
		logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif",
		logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif",
		map_fragment: "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif",
		map_pars_fragment: "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif",
		map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
		map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif",
		metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif",
		metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
		morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif",
		morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif",
		morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif",
		morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif",
		normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
		normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
		normal_pars_fragment: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
		normal_pars_vertex: "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif",
		normal_vertex: "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif",
		normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif",
		clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
		clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
		clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif",
		iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif",
		opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
		packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}",
		premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif",
		project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
		dithering_fragment: "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
		dithering_pars_fragment: "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif",
		roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif",
		roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
		shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif",
		shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif",
		shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif",
		shadowmask_pars_fragment: "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}",
		skinbase_vertex: "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
		skinning_pars_vertex: "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif",
		skinning_vertex: "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
		skinnormal_vertex: "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif",
		specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
		specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
		tonemapping_fragment: "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
		tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color *= toneMappingExposure;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	return color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
		transmission_fragment: "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
		transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif",
		uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",
		uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif",
		uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
		worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif",
		background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
		background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
		backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
		backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
		cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}",
		cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
		depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}",
		depth_frag: "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}",
		distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}",
		distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}",
		equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}",
		equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}",
		linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
		linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
		meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}",
		meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
		meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
		meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
		meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}",
		meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
		meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}",
		meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}",
		meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
		meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
		meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}",
		meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
		meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
		meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}",
		points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}",
		points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}",
		shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}",
		shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}",
		sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}",
		sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}"
	},
	UniformsLib = {
		common: {
			diffuse: {
				value: new Color(16777215)
			},
			opacity: {
				value: 1
			},
			map: {
				value: null
			},
			mapTransform: {
				value: new Matrix3
			},
			alphaMap: {
				value: null
			},
			alphaMapTransform: {
				value: new Matrix3
			},
			alphaTest: {
				value: 0
			}
		},
		specularmap: {
			specularMap: {
				value: null
			},
			specularMapTransform: {
				value: new Matrix3
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1
			},
			ior: {
				value: 1.5
			},
			refractionRatio: {
				value: .98
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			},
			aoMapTransform: {
				value: new Matrix3
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			},
			lightMapTransform: {
				value: new Matrix3
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpMapTransform: {
				value: new Matrix3
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalMapTransform: {
				value: new Matrix3
			},
			normalScale: {
				value: new Vector2(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementMapTransform: {
				value: new Matrix3
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			},
			emissiveMapTransform: {
				value: new Matrix3
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			},
			metalnessMapTransform: {
				value: new Matrix3
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			},
			roughnessMapTransform: {
				value: new Matrix3
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 25e-5
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2e3
			},
			fogColor: {
				value: new Color(16777215)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotLightMap: {
				value: []
			},
			spotShadowMap: {
				value: []
			},
			spotLightMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new Color(16777215)
			},
			opacity: {
				value: 1
			},
			size: {
				value: 1
			},
			scale: {
				value: 1
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			alphaMapTransform: {
				value: new Matrix3
			},
			alphaTest: {
				value: 0
			},
			uvTransform: {
				value: new Matrix3
			}
		},
		sprite: {
			diffuse: {
				value: new Color(16777215)
			},
			opacity: {
				value: 1
			},
			center: {
				value: new Vector2(.5, .5)
			},
			rotation: {
				value: 0
			},
			map: {
				value: null
			},
			mapTransform: {
				value: new Matrix3
			},
			alphaMap: {
				value: null
			},
			alphaMapTransform: {
				value: new Matrix3
			},
			alphaTest: {
				value: 0
			}
		}
	},
	ShaderLib = {
		basic: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},
		lambert: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0)
				}
			}]),
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},
		phong: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0)
				},
				specular: {
					value: new Color(1118481)
				},
				shininess: {
					value: 30
				}
			}]),
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},
		standard: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0)
				},
				roughness: {
					value: 1
				},
				metalness: {
					value: 0
				},
				envMapIntensity: {
					value: 1
				}
			}]),
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},
		toon: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0)
				}
			}]),
			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},
		matcap: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
				matcap: {
					value: null
				}
			}]),
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},
		points: {
			uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},
		dashed: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},
		depth: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},
		normal: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
				opacity: {
					value: 1
				}
			}]),
			vertexShader: ShaderChunk.meshnormal_vert,
			fragmentShader: ShaderChunk.meshnormal_frag
		},
		sprite: {
			uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new Matrix3
				},
				t2D: {
					value: null
				},
				backgroundIntensity: {
					value: 1
				}
			},
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},
		backgroundCube: {
			uniforms: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				},
				backgroundBlurriness: {
					value: 0
				},
				backgroundIntensity: {
					value: 1
				}
			},
			vertexShader: ShaderChunk.backgroundCube_vert,
			fragmentShader: ShaderChunk.backgroundCube_frag
		},
		cube: {
			uniforms: {
				tCube: {
					value: null
				},
				tFlip: {
					value: -1
				},
				opacity: {
					value: 1
				}
			},
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},
		distanceRGBA: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
				referencePosition: {
					value: new Vector3
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1e3
				}
			}]),
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},
		shadow: {
			uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
				color: {
					value: new Color(0)
				},
				opacity: {
					value: 1
				}
			}]),
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	};
ShaderLib.physical = {
	uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
		clearcoat: {
			value: 0
		},
		clearcoatMap: {
			value: null
		},
		clearcoatMapTransform: {
			value: new Matrix3
		},
		clearcoatNormalMap: {
			value: null
		},
		clearcoatNormalMapTransform: {
			value: new Matrix3
		},
		clearcoatNormalScale: {
			value: new Vector2(1, 1)
		},
		clearcoatRoughness: {
			value: 0
		},
		clearcoatRoughnessMap: {
			value: null
		},
		clearcoatRoughnessMapTransform: {
			value: new Matrix3
		},
		iridescence: {
			value: 0
		},
		iridescenceMap: {
			value: null
		},
		iridescenceMapTransform: {
			value: new Matrix3
		},
		iridescenceIOR: {
			value: 1.3
		},
		iridescenceThicknessMinimum: {
			value: 100
		},
		iridescenceThicknessMaximum: {
			value: 400
		},
		iridescenceThicknessMap: {
			value: null
		},
		iridescenceThicknessMapTransform: {
			value: new Matrix3
		},
		sheen: {
			value: 0
		},
		sheenColor: {
			value: new Color(0)
		},
		sheenColorMap: {
			value: null
		},
		sheenColorMapTransform: {
			value: new Matrix3
		},
		sheenRoughness: {
			value: 1
		},
		sheenRoughnessMap: {
			value: null
		},
		sheenRoughnessMapTransform: {
			value: new Matrix3
		},
		transmission: {
			value: 0
		},
		transmissionMap: {
			value: null
		},
		transmissionMapTransform: {
			value: new Matrix3
		},
		transmissionSamplerSize: {
			value: new Vector2
		},
		transmissionSamplerMap: {
			value: null
		},
		thickness: {
			value: 0
		},
		thicknessMap: {
			value: null
		},
		thicknessMapTransform: {
			value: new Matrix3
		},
		attenuationDistance: {
			value: 0
		},
		attenuationColor: {
			value: new Color(0)
		},
		specularColor: {
			value: new Color(1, 1, 1)
		},
		specularColorMap: {
			value: null
		},
		specularColorMapTransform: {
			value: new Matrix3
		},
		specularIntensity: {
			value: 1
		},
		specularIntensityMap: {
			value: null
		},
		specularIntensityMapTransform: {
			value: new Matrix3
		},
		anisotropyVector: {
			value: new Vector2
		},
		anisotropyMap: {
			value: null
		},
		anisotropyMapTransform: {
			value: new Matrix3
		}
	}]),
	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag
};
let _rgb = {
	r: 0,
	b: 0,
	g: 0
};

function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
	let planeMesh, boxMesh;
	let clearColor = new Color(0),
		clearAlpha = !0 === alpha ? 0 : 1,
		currentBackground = null,
		currentBackgroundVersion = 0,
		currentTonemapping = null;

	function setClear(color, alpha) {
		color.getRGB(_rgb, getUnlitUniformColorSpace(renderer)), state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha)
	}
	return {
		getClearColor: function() {
			return clearColor
		},
		setClearColor: function(color, alpha = 1) {
			clearColor.set(color), setClear(clearColor, clearAlpha = alpha)
		},
		getClearAlpha: function() {
			return clearAlpha
		},
		setClearAlpha: function(alpha) {
			setClear(clearColor, clearAlpha = alpha)
		},
		render: function(renderList, scene) {
			let forceClear = !1,
				background = !0 === scene.isScene ? scene.background : null;
			background && background.isTexture && (background = (scene.backgroundBlurriness > 0 ? cubeuvmaps : cubemaps).get(background)), null === background ? setClear(clearColor, clearAlpha) : background && background.isColor && (setClear(background, 1), forceClear = !0);
			let environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
			"additive" === environmentBlendMode ? state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha) : "alpha-blend" === environmentBlendMode && state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha), (renderer.autoClear || forceClear) && renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil), background && (background.isCubeTexture || 306 === background.mapping) ? (void 0 === boxMesh && ((boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
				name: "BackgroundCubeMaterial",
				uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
				vertexShader: ShaderLib.backgroundCube.vertexShader,
				fragmentShader: ShaderLib.backgroundCube.fragmentShader,
				side: 1,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			}))).geometry.deleteAttribute("normal"), boxMesh.geometry.deleteAttribute("uv"), boxMesh.onBeforeRender = function(renderer, scene, camera) {
				this.matrixWorld.copyPosition(camera.matrixWorld)
			}, Object.defineProperty(boxMesh.material, "envMap", {
				get: function() {
					return this.uniforms.envMap.value
				}
			}), objects.update(boxMesh)), boxMesh.material.uniforms.envMap.value = background, boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && !1 === background.isRenderTargetTexture ? -1 : 1, boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness, boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity, boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer, (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) && (boxMesh.material.needsUpdate = !0, currentBackground = background, currentBackgroundVersion = background.version, currentTonemapping = renderer.toneMapping), boxMesh.layers.enableAll(), renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null)) : background && background.isTexture && (void 0 === planeMesh && ((planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
				name: "BackgroundMaterial",
				uniforms: cloneUniforms(ShaderLib.background.uniforms),
				vertexShader: ShaderLib.background.vertexShader,
				fragmentShader: ShaderLib.background.fragmentShader,
				side: 0,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			}))).geometry.deleteAttribute("normal"), Object.defineProperty(planeMesh.material, "map", {
				get: function() {
					return this.uniforms.t2D.value
				}
			}), objects.update(planeMesh)), planeMesh.material.uniforms.t2D.value = background, planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity, planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer, !0 === background.matrixAutoUpdate && background.updateMatrix(), planeMesh.material.uniforms.uvTransform.value.copy(background.matrix), (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) && (planeMesh.material.needsUpdate = !0, currentBackground = background, currentBackgroundVersion = background.version, currentTonemapping = renderer.toneMapping), planeMesh.layers.enableAll(), renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null))
		}
	}
}

function WebGLBindingStates(gl, extensions, attributes, capabilities) {
	let maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
		extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object"),
		vaoAvailable = capabilities.isWebGL2 || null !== extension,
		bindingStates = {},
		defaultState = createBindingState(null),
		currentState = defaultState,
		forceUpdate = !1;

	function bindVertexArrayObject(vao) {
		return capabilities.isWebGL2 ? gl.bindVertexArray(vao) : extension.bindVertexArrayOES(vao)
	}

	function deleteVertexArrayObject(vao) {
		return capabilities.isWebGL2 ? gl.deleteVertexArray(vao) : extension.deleteVertexArrayOES(vao)
	}

	function createBindingState(vao) {
		let newAttributes = [],
			enabledAttributes = [],
			attributeDivisors = [];
		for (let i = 0; i < maxVertexAttributes; i++) newAttributes[i] = 0, enabledAttributes[i] = 0, attributeDivisors[i] = 0;
		return {
			geometry: null,
			program: null,
			wireframe: !1,
			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null
		}
	}

	function initAttributes() {
		let newAttributes = currentState.newAttributes;
		for (let i = 0, il = newAttributes.length; i < il; i++) newAttributes[i] = 0
	}

	function enableAttribute(attribute) {
		enableAttributeAndDivisor(attribute, 0)
	}

	function enableAttributeAndDivisor(attribute, meshPerAttribute) {
		let newAttributes = currentState.newAttributes,
			enabledAttributes = currentState.enabledAttributes,
			attributeDivisors = currentState.attributeDivisors;
		newAttributes[attribute] = 1, 0 === enabledAttributes[attribute] && (gl.enableVertexAttribArray(attribute), enabledAttributes[attribute] = 1), attributeDivisors[attribute] !== meshPerAttribute && ((capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays"))[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute), attributeDivisors[attribute] = meshPerAttribute)
	}

	function disableUnusedAttributes() {
		let newAttributes = currentState.newAttributes,
			enabledAttributes = currentState.enabledAttributes;
		for (let i = 0, il = enabledAttributes.length; i < il; i++) enabledAttributes[i] !== newAttributes[i] && (gl.disableVertexAttribArray(i), enabledAttributes[i] = 0)
	}

	function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
		!0 === integer ? gl.vertexAttribIPointer(index, size, type, stride, offset) : gl.vertexAttribPointer(index, size, type, normalized, stride, offset)
	}

	function reset() {
		resetDefaultState(), forceUpdate = !0, currentState !== defaultState && bindVertexArrayObject((currentState = defaultState).object)
	}

	function resetDefaultState() {
		defaultState.geometry = null, defaultState.program = null, defaultState.wireframe = !1
	}
	return {
		setup: function(object, material, program, geometry, index) {
			let updateBuffers = !1;
			if (vaoAvailable) {
				let state = function(geometry, program, material) {
					let wireframe = !0 === material.wireframe,
						programMap = bindingStates[geometry.id];
					void 0 === programMap && (programMap = {}, bindingStates[geometry.id] = programMap);
					let stateMap = programMap[program.id];
					void 0 === stateMap && (stateMap = {}, programMap[program.id] = stateMap);
					let state = stateMap[wireframe];
					return void 0 === state && (state = createBindingState(capabilities.isWebGL2 ? gl.createVertexArray() : extension.createVertexArrayOES()), stateMap[wireframe] = state), state
				}(geometry, program, material);
				currentState !== state && bindVertexArrayObject((currentState = state).object), (updateBuffers = function(object, geometry, program, index) {
					let cachedAttributes = currentState.attributes,
						geometryAttributes = geometry.attributes,
						attributesNum = 0,
						programAttributes = program.getAttributes();
					for (let name in programAttributes)
						if (programAttributes[name].location >= 0) {
							let cachedAttribute = cachedAttributes[name],
								geometryAttribute = geometryAttributes[name];
							if (void 0 === geometryAttribute && ("instanceMatrix" === name && object.instanceMatrix && (geometryAttribute = object.instanceMatrix), "instanceColor" === name && object.instanceColor && (geometryAttribute = object.instanceColor)), void 0 === cachedAttribute || cachedAttribute.attribute !== geometryAttribute || geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return !0;
							attributesNum++
						} return currentState.attributesNum !== attributesNum || currentState.index !== index
				}(object, geometry, program, index)) && function(object, geometry, program, index) {
					let cache = {},
						attributes = geometry.attributes,
						attributesNum = 0,
						programAttributes = program.getAttributes();
					for (let name in programAttributes)
						if (programAttributes[name].location >= 0) {
							let attribute = attributes[name];
							void 0 === attribute && ("instanceMatrix" === name && object.instanceMatrix && (attribute = object.instanceMatrix), "instanceColor" === name && object.instanceColor && (attribute = object.instanceColor));
							let data = {};
							data.attribute = attribute, attribute && attribute.data && (data.data = attribute.data), cache[name] = data, attributesNum++
						} currentState.attributes = cache, currentState.attributesNum = attributesNum, currentState.index = index
				}(object, geometry, program, index)
			} else {
				let wireframe = !0 === material.wireframe;
				(currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) && (currentState.geometry = geometry.id, currentState.program = program.id, currentState.wireframe = wireframe, updateBuffers = !0)
			}
			null !== index && attributes.update(index, gl.ELEMENT_ARRAY_BUFFER), (updateBuffers || forceUpdate) && (forceUpdate = !1, function(object, material, program, geometry) {
				if (!1 === capabilities.isWebGL2 && (object.isInstancedMesh || geometry.isInstancedBufferGeometry) && null === extensions.get("ANGLE_instanced_arrays")) return;
				initAttributes();
				let geometryAttributes = geometry.attributes,
					programAttributes = program.getAttributes(),
					materialDefaultAttributeValues = material.defaultAttributeValues;
				for (let name in programAttributes) {
					let programAttribute = programAttributes[name];
					if (programAttribute.location >= 0) {
						let geometryAttribute = geometryAttributes[name];
						if (void 0 === geometryAttribute && ("instanceMatrix" === name && object.instanceMatrix && (geometryAttribute = object.instanceMatrix), "instanceColor" === name && object.instanceColor && (geometryAttribute = object.instanceColor)), void 0 !== geometryAttribute) {
							let normalized = geometryAttribute.normalized,
								size = geometryAttribute.itemSize,
								attribute = attributes.get(geometryAttribute);
							if (void 0 === attribute) continue;
							let buffer = attribute.buffer,
								type = attribute.type,
								bytesPerElement = attribute.bytesPerElement,
								integer = !0 === capabilities.isWebGL2 && (type === gl.INT || type === gl.UNSIGNED_INT || 1013 === geometryAttribute.gpuType);
							if (geometryAttribute.isInterleavedBufferAttribute) {
								let data = geometryAttribute.data,
									stride = data.stride,
									offset = geometryAttribute.offset;
								if (data.isInstancedInterleavedBuffer) {
									for (let i = 0; i < programAttribute.locationSize; i++) enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
									!0 !== object.isInstancedMesh && void 0 === geometry._maxInstanceCount && (geometry._maxInstanceCount = data.meshPerAttribute * data.count)
								} else
									for (let i = 0; i < programAttribute.locationSize; i++) enableAttribute(programAttribute.location + i);
								gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
								for (let i = 0; i < programAttribute.locationSize; i++) vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i) * bytesPerElement, integer)
							} else {
								if (geometryAttribute.isInstancedBufferAttribute) {
									for (let i = 0; i < programAttribute.locationSize; i++) enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
									!0 !== object.isInstancedMesh && void 0 === geometry._maxInstanceCount && (geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count)
								} else
									for (let i = 0; i < programAttribute.locationSize; i++) enableAttribute(programAttribute.location + i);
								gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
								for (let i = 0; i < programAttribute.locationSize; i++) vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i * bytesPerElement, integer)
							}
						} else if (void 0 !== materialDefaultAttributeValues) {
							let value = materialDefaultAttributeValues[name];
							if (void 0 !== value) switch (value.length) {
								case 2:
									gl.vertexAttrib2fv(programAttribute.location, value);
									break;
								case 3:
									gl.vertexAttrib3fv(programAttribute.location, value);
									break;
								case 4:
									gl.vertexAttrib4fv(programAttribute.location, value);
									break;
								default:
									gl.vertexAttrib1fv(programAttribute.location, value)
							}
						}
					}
				}
				disableUnusedAttributes()
			}(object, material, program, geometry), null !== index && gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer))
		},
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: function() {
			for (let geometryId in reset(), bindingStates) {
				let programMap = bindingStates[geometryId];
				for (let programId in programMap) {
					let stateMap = programMap[programId];
					for (let wireframe in stateMap) deleteVertexArrayObject(stateMap[wireframe].object), delete stateMap[wireframe];
					delete programMap[programId]
				}
				delete bindingStates[geometryId]
			}
		},
		releaseStatesOfGeometry: function(geometry) {
			if (void 0 === bindingStates[geometry.id]) return;
			let programMap = bindingStates[geometry.id];
			for (let programId in programMap) {
				let stateMap = programMap[programId];
				for (let wireframe in stateMap) deleteVertexArrayObject(stateMap[wireframe].object), delete stateMap[wireframe];
				delete programMap[programId]
			}
			delete bindingStates[geometry.id]
		},
		releaseStatesOfProgram: function(program) {
			for (let geometryId in bindingStates) {
				let programMap = bindingStates[geometryId];
				if (void 0 === programMap[program.id]) continue;
				let stateMap = programMap[program.id];
				for (let wireframe in stateMap) deleteVertexArrayObject(stateMap[wireframe].object), delete stateMap[wireframe];
				delete programMap[program.id]
			}
		},
		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes
	}
}

function WebGLBufferRenderer(gl, extensions, info, capabilities) {
	let mode;
	let isWebGL2 = capabilities.isWebGL2;
	this.setMode = function(value) {
		mode = value
	}, this.render = function(start, count) {
		gl.drawArrays(mode, start, count), info.update(count, mode, 1)
	}, this.renderInstances = function(start, count, primcount) {
		let extension, methodName;
		if (0 !== primcount) {
			if (isWebGL2) extension = gl, methodName = "drawArraysInstanced";
			else if (extension = extensions.get("ANGLE_instanced_arrays"), methodName = "drawArraysInstancedANGLE", null === extension) {
				console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				return
			}
			extension[methodName](mode, start, count, primcount), info.update(count, mode, primcount)
		}
	}, this.renderMultiDraw = function(starts, counts, drawCount) {
		if (0 === drawCount) return;
		let extension = extensions.get("WEBGL_multi_draw");
		if (null === extension)
			for (let i = 0; i < drawCount; i++) this.render(starts[i], counts[i]);
		else {
			extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
			let elementCount = 0;
			for (let i = 0; i < drawCount; i++) elementCount += counts[i];
			info.update(elementCount, mode, 1)
		}
	}
}

function WebGLCapabilities(gl, extensions, parameters) {
	let maxAnisotropy;

	function getMaxPrecision(precision) {
		if ("highp" === precision) {
			if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) return "highp";
			precision = "mediump"
		}
		return "mediump" === precision && gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
	}
	let isWebGL2 = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === gl.constructor.name,
		precision = void 0 !== parameters.precision ? parameters.precision : "highp",
		maxPrecision = getMaxPrecision(precision);
	maxPrecision !== precision && (console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead."), precision = maxPrecision);
	let drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers"),
		logarithmicDepthBuffer = !0 === parameters.logarithmicDepthBuffer,
		maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
		maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
		maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE),
		maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),
		maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
		maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
		maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS),
		maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
		vertexTextures = maxVertexTextures > 0,
		floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float"),
		maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
	return {
		isWebGL2: isWebGL2,
		drawBuffers: drawBuffers,
		getMaxAnisotropy: function() {
			if (void 0 !== maxAnisotropy) return maxAnisotropy;
			if (!0 === extensions.has("EXT_texture_filter_anisotropic")) {
				let extension = extensions.get("EXT_texture_filter_anisotropic");
				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
			} else maxAnisotropy = 0;
			return maxAnisotropy
		},
		getMaxPrecision: getMaxPrecision,
		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,
		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,
		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,
		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: vertexTextures && floatFragmentTextures,
		maxSamples: maxSamples
	}
}

function WebGLClipping(properties) {
	let scope = this,
		globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = !1,
		renderingShadows = !1,
		plane = new Plane,
		viewNormalMatrix = new Matrix3,
		uniform = {
			value: null,
			needsUpdate: !1
		};

	function projectPlanes(planes, camera, dstOffset, skipTransform) {
		let nPlanes = null !== planes ? planes.length : 0,
			dstArray = null;
		if (0 !== nPlanes) {
			if (dstArray = uniform.value, !0 !== skipTransform || null === dstArray) {
				let flatSize = dstOffset + 4 * nPlanes,
					viewMatrix = camera.matrixWorldInverse;
				viewNormalMatrix.getNormalMatrix(viewMatrix), (null === dstArray || dstArray.length < flatSize) && (dstArray = new Float32Array(flatSize));
				for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix), plane.normal.toArray(dstArray, i4), dstArray[i4 + 3] = plane.constant
			}
			uniform.value = dstArray, uniform.needsUpdate = !0
		}
		return scope.numPlanes = nPlanes, scope.numIntersection = 0, dstArray
	}
	this.uniform = uniform, this.numPlanes = 0, this.numIntersection = 0, this.init = function(planes, enableLocalClipping) {
		let enabled = 0 !== planes.length || enableLocalClipping || 0 !== numGlobalPlanes || localClippingEnabled;
		return localClippingEnabled = enableLocalClipping, numGlobalPlanes = planes.length, enabled
	}, this.beginShadows = function() {
		renderingShadows = !0, projectPlanes(null)
	}, this.endShadows = function() {
		renderingShadows = !1
	}, this.setGlobalState = function(planes, camera) {
		globalState = projectPlanes(planes, camera, 0)
	}, this.setState = function(material, camera, useCache) {
		let planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows,
			materialProperties = properties.get(material);
		if (localClippingEnabled && null !== planes && 0 !== planes.length && (!renderingShadows || clipShadows)) {
			let nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = 4 * nGlobal,
				dstArray = materialProperties.clippingState || null;
			uniform.value = dstArray, dstArray = projectPlanes(planes, camera, lGlobal, useCache);
			for (let i = 0; i !== lGlobal; ++i) dstArray[i] = globalState[i];
			materialProperties.clippingState = dstArray, this.numIntersection = clipIntersection ? this.numPlanes : 0, this.numPlanes += nGlobal
		} else renderingShadows ? projectPlanes(null) : (uniform.value !== globalState && (uniform.value = globalState, uniform.needsUpdate = numGlobalPlanes > 0), scope.numPlanes = numGlobalPlanes, scope.numIntersection = 0)
	}
}

function WebGLCubeMaps(renderer) {
	let cubemaps = new WeakMap;

	function mapTextureMapping(texture, mapping) {
		return 303 === mapping ? texture.mapping = 301 : 304 === mapping && (texture.mapping = 302), texture
	}

	function onTextureDispose(event) {
		let texture = event.target;
		texture.removeEventListener("dispose", onTextureDispose);
		let cubemap = cubemaps.get(texture);
		void 0 !== cubemap && (cubemaps.delete(texture), cubemap.dispose())
	}
	return {
		get: function(texture) {
			if (texture && texture.isTexture) {
				let mapping = texture.mapping;
				if (303 === mapping || 304 === mapping) {
					if (cubemaps.has(texture)) return mapTextureMapping(cubemaps.get(texture).texture, texture.mapping);
					{
						let image = texture.image;
						if (!image || !(image.height > 0)) return null;
						{
							let renderTarget = new WebGLCubeRenderTarget(image.height / 2);
							return renderTarget.fromEquirectangularTexture(renderer, texture), cubemaps.set(texture, renderTarget), texture.addEventListener("dispose", onTextureDispose), mapTextureMapping(renderTarget.texture, texture.mapping)
						}
					}
				}
			}
			return texture
		},
		dispose: function() {
			cubemaps = new WeakMap
		}
	}
}
class OrthographicCamera extends Camera {
	constructor(left = -1, right = 1, top = 1, bottom = -1, near = .1, far = 2e3) {
		super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = left, this.right = right, this.top = top, this.bottom = bottom, this.near = near, this.far = far, this.updateProjectionMatrix()
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.left = source.left, this.right = source.right, this.top = source.top, this.bottom = source.bottom, this.near = source.near, this.far = source.far, this.zoom = source.zoom, this.view = null === source.view ? null : Object.assign({}, source.view), this
	}
	setViewOffset(fullWidth, fullHeight, x, y, width, height) {
		null === this.view && (this.view = {
			enabled: !0,
			fullWidth: 1,
			fullHeight: 1,
			offsetX: 0,
			offsetY: 0,
			width: 1,
			height: 1
		}), this.view.enabled = !0, this.view.fullWidth = fullWidth, this.view.fullHeight = fullHeight, this.view.offsetX = x, this.view.offsetY = y, this.view.width = width, this.view.height = height, this.updateProjectionMatrix()
	}
	clearViewOffset() {
		null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
	}
	updateProjectionMatrix() {
		let dx = (this.right - this.left) / (2 * this.zoom),
			dy = (this.top - this.bottom) / (2 * this.zoom),
			cx = (this.right + this.left) / 2,
			cy = (this.top + this.bottom) / 2,
			left = cx - dx,
			right = cx + dx,
			top = cy + dy,
			bottom = cy - dy;
		if (null !== this.view && this.view.enabled) {
			let scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom,
				scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
			left += scaleW * this.view.offsetX, right = left + scaleW * this.view.width, top -= scaleH * this.view.offsetY, bottom = top - scaleH * this.view.height
		}
		this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
	}
	toJSON(meta) {
		let data = super.toJSON(meta);
		return data.object.zoom = this.zoom, data.object.left = this.left, data.object.right = this.right, data.object.top = this.top, data.object.bottom = this.bottom, data.object.near = this.near, data.object.far = this.far, null !== this.view && (data.object.view = Object.assign({}, this.view)), data
	}
}
let EXTRA_LOD_SIGMA = [.125, .215, .35, .446, .526, .582],
	_flatCamera = new OrthographicCamera,
	_clearColor = new Color,
	_oldTarget = null,
	_oldActiveCubeFace = 0,
	_oldActiveMipmapLevel = 0,
	PHI = (1 + Math.sqrt(5)) / 2,
	INV_PHI = 1 / PHI,
	_axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)];
class PMREMGenerator {
	constructor(renderer) {
		this._renderer = renderer, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
	}
	fromScene(scene, sigma = 0, near = .1, far = 100) {
		_oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel(), this._setSize(256);
		let cubeUVRenderTarget = this._allocateTargets();
		return cubeUVRenderTarget.depthBuffer = !0, this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget), sigma > 0 && this._blur(cubeUVRenderTarget, 0, 0, sigma), this._applyPMREM(cubeUVRenderTarget), this._cleanup(cubeUVRenderTarget), cubeUVRenderTarget
	}
	fromEquirectangular(equirectangular, renderTarget = null) {
		return this._fromTexture(equirectangular, renderTarget)
	}
	fromCubemap(cubemap, renderTarget = null) {
		return this._fromTexture(cubemap, renderTarget)
	}
	compileCubemapShader() {
		null === this._cubemapMaterial && (this._cubemapMaterial = _getCubemapMaterial(), this._compileMaterial(this._cubemapMaterial))
	}
	compileEquirectangularShader() {
		null === this._equirectMaterial && (this._equirectMaterial = _getEquirectMaterial(), this._compileMaterial(this._equirectMaterial))
	}
	dispose() {
		this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
	}
	_setSize(cubeSize) {
		this._lodMax = Math.floor(Math.log2(cubeSize)), this._cubeSize = Math.pow(2, this._lodMax)
	}
	_dispose() {
		null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
		for (let i = 0; i < this._lodPlanes.length; i++) this._lodPlanes[i].dispose()
	}
	_cleanup(outputTarget) {
		this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel), outputTarget.scissorTest = !1, _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height)
	}
	_fromTexture(texture, renderTarget) {
		301 === texture.mapping || 302 === texture.mapping ? this._setSize(0 === texture.image.length ? 16 : texture.image[0].width || texture.image[0].image.width) : this._setSize(texture.image.width / 4), _oldTarget = this._renderer.getRenderTarget(), _oldActiveCubeFace = this._renderer.getActiveCubeFace(), _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
		let cubeUVRenderTarget = renderTarget || this._allocateTargets();
		return this._textureToCubeUV(texture, cubeUVRenderTarget), this._applyPMREM(cubeUVRenderTarget), this._cleanup(cubeUVRenderTarget), cubeUVRenderTarget
	}
	_allocateTargets() {
		let width = 3 * Math.max(this._cubeSize, 112),
			height = 4 * this._cubeSize,
			params = {
				magFilter: 1006,
				minFilter: 1006,
				generateMipmaps: !1,
				type: 1016,
				format: 1023,
				colorSpace: LinearSRGBColorSpace,
				depthBuffer: !1
			},
			cubeUVRenderTarget = _createRenderTarget(width, height, params);
		if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
			null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = _createRenderTarget(width, height, params);
			let {
				_lodMax
			} = this;
			({
				sizeLods: this._sizeLods,
				lodPlanes: this._lodPlanes,
				sigmas: this._sigmas
			} = function(lodMax) {
				let lodPlanes = [],
					sizeLods = [],
					sigmas = [],
					lod = lodMax,
					totalLods = lodMax - 4 + 1 + EXTRA_LOD_SIGMA.length;
				for (let i = 0; i < totalLods; i++) {
					let sizeLod = Math.pow(2, lod);
					sizeLods.push(sizeLod);
					let sigma = 1 / sizeLod;
					i > lodMax - 4 ? sigma = EXTRA_LOD_SIGMA[i - lodMax + 4 - 1] : 0 === i && (sigma = 0), sigmas.push(sigma);
					let texelSize = 1 / (sizeLod - 2),
						min = -texelSize,
						max = 1 + texelSize,
						uv1 = [min, min, max, min, max, max, min, min, max, max, min, max],
						position = new Float32Array(108),
						uv = new Float32Array(72),
						faceIndex = new Float32Array(36);
					for (let face = 0; face < 6; face++) {
						let x = face % 3 * 2 / 3 - 1,
							y = face > 2 ? 0 : -1,
							coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
						position.set(coordinates, 18 * face), uv.set(uv1, 12 * face);
						let fill = [face, face, face, face, face, face];
						faceIndex.set(fill, 6 * face)
					}
					let planes = new BufferGeometry;
					planes.setAttribute("position", new BufferAttribute(position, 3)), planes.setAttribute("uv", new BufferAttribute(uv, 2)), planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, 1)), lodPlanes.push(planes), lod > 4 && lod--
				}
				return {
					lodPlanes,
					sizeLods,
					sigmas
				}
			}(_lodMax)), this._blurMaterial = new ShaderMaterial({
				name: "SphericalGaussianBlur",
				defines: {
					n: 20,
					CUBEUV_TEXEL_WIDTH: 1 / width,
					CUBEUV_TEXEL_HEIGHT: 1 / height,
					CUBEUV_MAX_MIP: `${_lodMax}.0`
				},
				uniforms: {
					envMap: {
						value: null
					},
					samples: {
						value: 1
					},
					weights: {
						value: new Float32Array(20)
					},
					latitudinal: {
						value: !1
					},
					dTheta: {
						value: 0
					},
					mipInt: {
						value: 0
					},
					poleAxis: {
						value: new Vector3(0, 1, 0)
					}
				},
				vertexShader: _getCommonVertexShader(),
				fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
				blending: 0,
				depthTest: !1,
				depthWrite: !1
			})
		}
		return cubeUVRenderTarget
	}
	_compileMaterial(material) {
		let tmpMesh = new Mesh(this._lodPlanes[0], material);
		this._renderer.compile(tmpMesh, _flatCamera)
	}
	_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
		let cubeCamera = new PerspectiveCamera(90, 1, near, far),
			upSign = [1, -1, 1, 1, 1, 1],
			forwardSign = [1, 1, 1, -1, -1, -1],
			renderer = this._renderer,
			originalAutoClear = renderer.autoClear,
			toneMapping = renderer.toneMapping;
		renderer.getClearColor(_clearColor), renderer.toneMapping = 0, renderer.autoClear = !1;
		let backgroundMaterial = new MeshBasicMaterial({
				name: "PMREM.Background",
				side: 1,
				depthWrite: !1,
				depthTest: !1
			}),
			backgroundBox = new Mesh(new BoxGeometry, backgroundMaterial),
			useSolidColor = !1,
			background = scene.background;
		background ? background.isColor && (backgroundMaterial.color.copy(background), scene.background = null, useSolidColor = !0) : (backgroundMaterial.color.copy(_clearColor), useSolidColor = !0);
		for (let i = 0; i < 6; i++) {
			let col = i % 3;
			0 === col ? (cubeCamera.up.set(0, upSign[i], 0), cubeCamera.lookAt(forwardSign[i], 0, 0)) : 1 === col ? (cubeCamera.up.set(0, 0, upSign[i]), cubeCamera.lookAt(0, forwardSign[i], 0)) : (cubeCamera.up.set(0, upSign[i], 0), cubeCamera.lookAt(0, 0, forwardSign[i]));
			let size = this._cubeSize;
			_setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size), renderer.setRenderTarget(cubeUVRenderTarget), useSolidColor && renderer.render(backgroundBox, cubeCamera), renderer.render(scene, cubeCamera)
		}
		backgroundBox.geometry.dispose(), backgroundBox.material.dispose(), renderer.toneMapping = toneMapping, renderer.autoClear = originalAutoClear, scene.background = background
	}
	_textureToCubeUV(texture, cubeUVRenderTarget) {
		let renderer = this._renderer,
			isCubeTexture = 301 === texture.mapping || 302 === texture.mapping;
		isCubeTexture ? (null === this._cubemapMaterial && (this._cubemapMaterial = _getCubemapMaterial()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === texture.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = _getEquirectMaterial());
		let material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial,
			mesh = new Mesh(this._lodPlanes[0], material);
		material.uniforms.envMap.value = texture;
		let size = this._cubeSize;
		_setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size), renderer.setRenderTarget(cubeUVRenderTarget), renderer.render(mesh, _flatCamera)
	}
	_applyPMREM(cubeUVRenderTarget) {
		let renderer = this._renderer,
			autoClear = renderer.autoClear;
		renderer.autoClear = !1;
		for (let i = 1; i < this._lodPlanes.length; i++) {
			let sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]),
				poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
			this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis)
		}
		renderer.autoClear = autoClear
	}
	_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
		let pingPongRenderTarget = this._pingPongRenderTarget;
		this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis), this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis)
	}
	_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
		let renderer = this._renderer,
			blurMaterial = this._blurMaterial;
		"latitudinal" !== direction && "longitudinal" !== direction && console.error("blur direction must be either latitudinal or longitudinal!");
		let blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial),
			blurUniforms = blurMaterial.uniforms,
			pixels = this._sizeLods[lodIn] - 1,
			radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / 39,
			sigmaPixels = sigmaRadians / radiansPerPixel,
			samples = isFinite(sigmaRadians) ? 1 + Math.floor(3 * sigmaPixels) : 20;
		samples > 20 && console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to 20`);
		let weights = [],
			sum = 0;
		for (let i = 0; i < 20; ++i) {
			let x = i / sigmaPixels,
				weight = Math.exp(-x * x / 2);
			weights.push(weight), 0 === i ? sum += weight : i < samples && (sum += 2 * weight)
		}
		for (let i = 0; i < weights.length; i++) weights[i] = weights[i] / sum;
		blurUniforms.envMap.value = targetIn.texture, blurUniforms.samples.value = samples, blurUniforms.weights.value = weights, blurUniforms.latitudinal.value = "latitudinal" === direction, poleAxis && (blurUniforms.poleAxis.value = poleAxis);
		let {
			_lodMax
		} = this;
		blurUniforms.dTheta.value = radiansPerPixel, blurUniforms.mipInt.value = _lodMax - lodIn;
		let outputSize = this._sizeLods[lodOut],
			y = 4 * (this._cubeSize - outputSize);
		_setViewport(targetOut, 3 * outputSize * (lodOut > _lodMax - 4 ? lodOut - _lodMax + 4 : 0), y, 3 * outputSize, 2 * outputSize), renderer.setRenderTarget(targetOut), renderer.render(blurMesh, _flatCamera)
	}
}

function _createRenderTarget(width, height, params) {
	let cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
	return cubeUVRenderTarget.texture.mapping = 306, cubeUVRenderTarget.texture.name = "PMREM.cubeUv", cubeUVRenderTarget.scissorTest = !0, cubeUVRenderTarget
}

function _setViewport(target, x, y, width, height) {
	target.viewport.set(x, y, width, height), target.scissor.set(x, y, width, height)
}

function _getEquirectMaterial() {
	return new ShaderMaterial({
		name: "EquirectangularToCubeUV",
		uniforms: {
			envMap: {
				value: null
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
		blending: 0,
		depthTest: !1,
		depthWrite: !1
	})
}

function _getCubemapMaterial() {
	return new ShaderMaterial({
		name: "CubemapToCubeUV",
		uniforms: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			}
		},
		vertexShader: _getCommonVertexShader(),
		fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
		blending: 0,
		depthTest: !1,
		depthWrite: !1
	})
}

function _getCommonVertexShader() {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function WebGLCubeUVMaps(renderer) {
	let cubeUVmaps = new WeakMap,
		pmremGenerator = null;

	function onTextureDispose(event) {
		let texture = event.target;
		texture.removeEventListener("dispose", onTextureDispose);
		let cubemapUV = cubeUVmaps.get(texture);
		void 0 !== cubemapUV && (cubeUVmaps.delete(texture), cubemapUV.dispose())
	}
	return {
		get: function(texture) {
			if (texture && texture.isTexture) {
				let mapping = texture.mapping,
					isEquirectMap = 303 === mapping || 304 === mapping,
					isCubeMap = 301 === mapping || 302 === mapping;
				if (isEquirectMap || isCubeMap) {
					if (texture.isRenderTargetTexture && !0 === texture.needsPMREMUpdate) {
						texture.needsPMREMUpdate = !1;
						let renderTarget = cubeUVmaps.get(texture);
						return null === pmremGenerator && (pmremGenerator = new PMREMGenerator(renderer)), renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget), cubeUVmaps.set(texture, renderTarget), renderTarget.texture
					}
					if (cubeUVmaps.has(texture)) return cubeUVmaps.get(texture).texture;
					{
						let image = texture.image;
						if (!(isEquirectMap && image && image.height > 0 || isCubeMap && image && function(image) {
								let count = 0;
								for (let i = 0; i < 6; i++) void 0 !== image[i] && count++;
								return 6 === count
							}(image))) return null;
						{
							null === pmremGenerator && (pmremGenerator = new PMREMGenerator(renderer));
							let renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
							return cubeUVmaps.set(texture, renderTarget), texture.addEventListener("dispose", onTextureDispose), renderTarget.texture
						}
					}
				}
			}
			return texture
		},
		dispose: function() {
			cubeUVmaps = new WeakMap, null !== pmremGenerator && (pmremGenerator.dispose(), pmremGenerator = null)
		}
	}
}

function WebGLExtensions(gl) {
	let extensions = {};

	function getExtension(name) {
		let extension;
		if (void 0 !== extensions[name]) return extensions[name];
		switch (name) {
			case "WEBGL_depth_texture":
				extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
				break;
			case "EXT_texture_filter_anisotropic":
				extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
				break;
			case "WEBGL_compressed_texture_s3tc":
				extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
				break;
			case "WEBGL_compressed_texture_pvrtc":
				extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
				break;
			default:
				extension = gl.getExtension(name)
		}
		return extensions[name] = extension, extension
	}
	return {
		has: function(name) {
			return null !== getExtension(name)
		},
		init: function(capabilities) {
			capabilities.isWebGL2 ? (getExtension("EXT_color_buffer_float"), getExtension("WEBGL_clip_cull_distance")) : (getExtension("WEBGL_depth_texture"), getExtension("OES_texture_float"), getExtension("OES_texture_half_float"), getExtension("OES_texture_half_float_linear"), getExtension("OES_standard_derivatives"), getExtension("OES_element_index_uint"), getExtension("OES_vertex_array_object"), getExtension("ANGLE_instanced_arrays")), getExtension("OES_texture_float_linear"), getExtension("EXT_color_buffer_half_float"), getExtension("WEBGL_multisampled_render_to_texture")
		},
		get: function(name) {
			let extension = getExtension(name);
			return null === extension && console.warn("THREE.WebGLRenderer: " + name + " extension not supported."), extension
		}
	}
}

function WebGLGeometries(gl, attributes, info, bindingStates) {
	let geometries = {},
		wireframeAttributes = new WeakMap;

	function onGeometryDispose(event) {
		let geometry = event.target;
		for (let name in null !== geometry.index && attributes.remove(geometry.index), geometry.attributes) attributes.remove(geometry.attributes[name]);
		for (let name in geometry.morphAttributes) {
			let array = geometry.morphAttributes[name];
			for (let i = 0, l = array.length; i < l; i++) attributes.remove(array[i])
		}
		geometry.removeEventListener("dispose", onGeometryDispose), delete geometries[geometry.id];
		let attribute = wireframeAttributes.get(geometry);
		attribute && (attributes.remove(attribute), wireframeAttributes.delete(geometry)), bindingStates.releaseStatesOfGeometry(geometry), !0 === geometry.isInstancedBufferGeometry && delete geometry._maxInstanceCount, info.memory.geometries--
	}

	function updateWireframeAttribute(geometry) {
		let indices = [],
			geometryIndex = geometry.index,
			geometryPosition = geometry.attributes.position,
			version = 0;
		if (null !== geometryIndex) {
			let array = geometryIndex.array;
			version = geometryIndex.version;
			for (let i = 0, l = array.length; i < l; i += 3) {
				let a = array[i + 0],
					b = array[i + 1],
					c = array[i + 2];
				indices.push(a, b, b, c, c, a)
			}
		} else {
			if (void 0 === geometryPosition) return;
			let array = geometryPosition.array;
			version = geometryPosition.version;
			for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
				let a = i + 0,
					b = i + 1,
					c = i + 2;
				indices.push(a, b, b, c, c, a)
			}
		}
		let attribute = new(arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
		attribute.version = version;
		let previousAttribute = wireframeAttributes.get(geometry);
		previousAttribute && attributes.remove(previousAttribute), wireframeAttributes.set(geometry, attribute)
	}
	return {
		get: function(object, geometry) {
			return !0 === geometries[geometry.id] || (geometry.addEventListener("dispose", onGeometryDispose), geometries[geometry.id] = !0, info.memory.geometries++), geometry
		},
		update: function(geometry) {
			let geometryAttributes = geometry.attributes;
			for (let name in geometryAttributes) attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
			let morphAttributes = geometry.morphAttributes;
			for (let name in morphAttributes) {
				let array = morphAttributes[name];
				for (let i = 0, l = array.length; i < l; i++) attributes.update(array[i], gl.ARRAY_BUFFER)
			}
		},
		getWireframeAttribute: function(geometry) {
			let currentAttribute = wireframeAttributes.get(geometry);
			if (currentAttribute) {
				let geometryIndex = geometry.index;
				null !== geometryIndex && currentAttribute.version < geometryIndex.version && updateWireframeAttribute(geometry)
			} else updateWireframeAttribute(geometry);
			return wireframeAttributes.get(geometry)
		}
	}
}

function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
	let mode, type, bytesPerElement;
	let isWebGL2 = capabilities.isWebGL2;
	this.setMode = function(value) {
		mode = value
	}, this.setIndex = function(value) {
		type = value.type, bytesPerElement = value.bytesPerElement
	}, this.render = function(start, count) {
		gl.drawElements(mode, count, type, start * bytesPerElement), info.update(count, mode, 1)
	}, this.renderInstances = function(start, count, primcount) {
		let extension, methodName;
		if (0 !== primcount) {
			if (isWebGL2) extension = gl, methodName = "drawElementsInstanced";
			else if (extension = extensions.get("ANGLE_instanced_arrays"), methodName = "drawElementsInstancedANGLE", null === extension) {
				console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				return
			}
			extension[methodName](mode, count, type, start * bytesPerElement, primcount), info.update(count, mode, primcount)
		}
	}, this.renderMultiDraw = function(starts, counts, drawCount) {
		if (0 === drawCount) return;
		let extension = extensions.get("WEBGL_multi_draw");
		if (null === extension)
			for (let i = 0; i < drawCount; i++) this.render(starts[i] / bytesPerElement, counts[i]);
		else {
			extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
			let elementCount = 0;
			for (let i = 0; i < drawCount; i++) elementCount += counts[i];
			info.update(elementCount, mode, 1)
		}
	}
}

function WebGLInfo(gl) {
	let render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};
	return {
		memory: {
			geometries: 0,
			textures: 0
		},
		render: render,
		programs: null,
		autoReset: !0,
		reset: function() {
			render.calls = 0, render.triangles = 0, render.points = 0, render.lines = 0
		},
		update: function(count, mode, instanceCount) {
			switch (render.calls++, mode) {
				case gl.TRIANGLES:
					render.triangles += count / 3 * instanceCount;
					break;
				case gl.LINES:
					render.lines += count / 2 * instanceCount;
					break;
				case gl.LINE_STRIP:
					render.lines += instanceCount * (count - 1);
					break;
				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;
				case gl.POINTS:
					render.points += instanceCount * count;
					break;
				default:
					console.error("THREE.WebGLInfo: Unknown draw mode:", mode)
			}
		}
	}
}

function numericalSort(a, b) {
	return a[0] - b[0]
}

function absNumericalSort(a, b) {
	return Math.abs(b[1]) - Math.abs(a[1])
}

function WebGLMorphtargets(gl, capabilities, textures) {
	let influencesList = {},
		morphInfluences = new Float32Array(8),
		morphTextures = new WeakMap,
		morph = new Vector4,
		workInfluences = [];
	for (let i = 0; i < 8; i++) workInfluences[i] = [i, 0];
	return {
		update: function(object, geometry, program) {
			let objectInfluences = object.morphTargetInfluences;
			if (!0 === capabilities.isWebGL2) {
				let morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color,
					morphTargetsCount = void 0 !== morphAttribute ? morphAttribute.length : 0,
					entry = morphTextures.get(geometry);
				if (void 0 === entry || entry.count !== morphTargetsCount) {
					void 0 !== entry && entry.texture.dispose();
					let hasMorphPosition = void 0 !== geometry.morphAttributes.position,
						hasMorphNormals = void 0 !== geometry.morphAttributes.normal,
						hasMorphColors = void 0 !== geometry.morphAttributes.color,
						morphTargets = geometry.morphAttributes.position || [],
						morphNormals = geometry.morphAttributes.normal || [],
						morphColors = geometry.morphAttributes.color || [],
						vertexDataCount = 0;
					!0 === hasMorphPosition && (vertexDataCount = 1), !0 === hasMorphNormals && (vertexDataCount = 2), !0 === hasMorphColors && (vertexDataCount = 3);
					let width = geometry.attributes.position.count * vertexDataCount,
						height = 1;
					width > capabilities.maxTextureSize && (height = Math.ceil(width / capabilities.maxTextureSize), width = capabilities.maxTextureSize);
					let buffer = new Float32Array(width * height * 4 * morphTargetsCount),
						texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
					texture.type = 1015, texture.needsUpdate = !0;
					let vertexDataStride = 4 * vertexDataCount;
					for (let i = 0; i < morphTargetsCount; i++) {
						let morphTarget = morphTargets[i],
							morphNormal = morphNormals[i],
							morphColor = morphColors[i],
							offset = width * height * 4 * i;
						for (let j = 0; j < morphTarget.count; j++) {
							let stride = j * vertexDataStride;
							!0 === hasMorphPosition && (morph.fromBufferAttribute(morphTarget, j), buffer[offset + stride + 0] = morph.x, buffer[offset + stride + 1] = morph.y, buffer[offset + stride + 2] = morph.z, buffer[offset + stride + 3] = 0), !0 === hasMorphNormals && (morph.fromBufferAttribute(morphNormal, j), buffer[offset + stride + 4] = morph.x, buffer[offset + stride + 5] = morph.y, buffer[offset + stride + 6] = morph.z, buffer[offset + stride + 7] = 0), !0 === hasMorphColors && (morph.fromBufferAttribute(morphColor, j), buffer[offset + stride + 8] = morph.x, buffer[offset + stride + 9] = morph.y, buffer[offset + stride + 10] = morph.z, buffer[offset + stride + 11] = 4 === morphColor.itemSize ? morph.w : 1)
						}
					}
					entry = {
						count: morphTargetsCount,
						texture: texture,
						size: new Vector2(width, height)
					}, morphTextures.set(geometry, entry), geometry.addEventListener("dispose", function disposeTexture() {
						texture.dispose(), morphTextures.delete(geometry), geometry.removeEventListener("dispose", disposeTexture)
					})
				}
				let morphInfluencesSum = 0;
				for (let i = 0; i < objectInfluences.length; i++) morphInfluencesSum += objectInfluences[i];
				let morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
				program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence), program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences), program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures), program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size)
			} else {
				let length = void 0 === objectInfluences ? 0 : objectInfluences.length,
					influences = influencesList[geometry.id];
				if (void 0 === influences || influences.length !== length) {
					influences = [];
					for (let i = 0; i < length; i++) influences[i] = [i, 0];
					influencesList[geometry.id] = influences
				}
				for (let i = 0; i < length; i++) {
					let influence = influences[i];
					influence[0] = i, influence[1] = objectInfluences[i]
				}
				influences.sort(absNumericalSort);
				for (let i = 0; i < 8; i++) i < length && influences[i][1] ? (workInfluences[i][0] = influences[i][0], workInfluences[i][1] = influences[i][1]) : (workInfluences[i][0] = Number.MAX_SAFE_INTEGER, workInfluences[i][1] = 0);
				workInfluences.sort(numericalSort);
				let morphTargets = geometry.morphAttributes.position,
					morphNormals = geometry.morphAttributes.normal,
					morphInfluencesSum = 0;
				for (let i = 0; i < 8; i++) {
					let influence = workInfluences[i],
						index = influence[0],
						value = influence[1];
					index !== Number.MAX_SAFE_INTEGER && value ? (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index] && geometry.setAttribute("morphTarget" + i, morphTargets[index]), morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index] && geometry.setAttribute("morphNormal" + i, morphNormals[index]), morphInfluences[i] = value, morphInfluencesSum += value) : (morphTargets && !0 === geometry.hasAttribute("morphTarget" + i) && geometry.deleteAttribute("morphTarget" + i), morphNormals && !0 === geometry.hasAttribute("morphNormal" + i) && geometry.deleteAttribute("morphNormal" + i), morphInfluences[i] = 0)
				}
				let morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
				program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence), program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences)
			}
		}
	}
}

function WebGLObjects(gl, geometries, attributes, info) {
	let updateMap = new WeakMap;

	function onInstancedMeshDispose(event) {
		let instancedMesh = event.target;
		instancedMesh.removeEventListener("dispose", onInstancedMeshDispose), attributes.remove(instancedMesh.instanceMatrix), null !== instancedMesh.instanceColor && attributes.remove(instancedMesh.instanceColor)
	}
	return {
		update: function(object) {
			let frame = info.render.frame,
				geometry = object.geometry,
				buffergeometry = geometries.get(object, geometry);
			if (updateMap.get(buffergeometry) !== frame && (geometries.update(buffergeometry), updateMap.set(buffergeometry, frame)), object.isInstancedMesh && (!1 === object.hasEventListener("dispose", onInstancedMeshDispose) && object.addEventListener("dispose", onInstancedMeshDispose), updateMap.get(object) !== frame && (attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER), null !== object.instanceColor && attributes.update(object.instanceColor, gl.ARRAY_BUFFER), updateMap.set(object, frame))), object.isSkinnedMesh) {
				let skeleton = object.skeleton;
				updateMap.get(skeleton) !== frame && (skeleton.update(), updateMap.set(skeleton, frame))
			}
			return buffergeometry
		},
		dispose: function() {
			updateMap = new WeakMap
		}
	}
}
class DepthTexture extends Texture$1 {
	constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
		if (1026 !== (format = void 0 !== format ? format : 1026) && 1027 !== format) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
		void 0 === type && 1026 === format && (type = 1014), void 0 === type && 1027 === format && (type = 1020), super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy), this.isDepthTexture = !0, this.image = {
			width: width,
			height: height
		}, this.magFilter = void 0 !== magFilter ? magFilter : NearestFilter, this.minFilter = void 0 !== minFilter ? minFilter : NearestFilter, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
	}
	copy(source) {
		return super.copy(source), this.compareFunction = source.compareFunction, this
	}
	toJSON(meta) {
		let data = super.toJSON(meta);
		return null !== this.compareFunction && (data.compareFunction = this.compareFunction), data
	}
}
let emptyTexture = new Texture$1,
	emptyShadowTexture = new DepthTexture(1, 1);
emptyShadowTexture.compareFunction = 515;
let emptyArrayTexture = new DataArrayTexture,
	empty3dTexture = new Data3DTexture,
	emptyCubeTexture = new CubeTexture,
	arrayCacheF32 = [],
	arrayCacheI32 = [],
	mat4array = new Float32Array(16),
	mat3array = new Float32Array(9),
	mat2array = new Float32Array(4);

function flatten(array, nBlocks, blockSize) {
	let firstElem = array[0];
	if (firstElem <= 0 || firstElem > 0) return array;
	let n = nBlocks * blockSize,
		r = arrayCacheF32[n];
	if (void 0 === r && (r = new Float32Array(n), arrayCacheF32[n] = r), 0 !== nBlocks) {
		firstElem.toArray(r, 0);
		for (let i = 1, offset = 0; i !== nBlocks; ++i) offset += blockSize, array[i].toArray(r, offset)
	}
	return r
}

function arraysEqual(a, b) {
	if (a.length !== b.length) return !1;
	for (let i = 0, l = a.length; i < l; i++)
		if (a[i] !== b[i]) return !1;
	return !0
}

function copyArray(a, b) {
	for (let i = 0, l = b.length; i < l; i++) a[i] = b[i]
}

function allocTexUnits(textures, n) {
	let r = arrayCacheI32[n];
	void 0 === r && (r = new Int32Array(n), arrayCacheI32[n] = r);
	for (let i = 0; i !== n; ++i) r[i] = textures.allocateTextureUnit();
	return r
}

function setValueV1f(gl, v) {
	let cache = this.cache;
	cache[0] !== v && (gl.uniform1f(this.addr, v), cache[0] = v)
}

function setValueV2f(gl, v) {
	let cache = this.cache;
	if (void 0 !== v.x)(cache[0] !== v.x || cache[1] !== v.y) && (gl.uniform2f(this.addr, v.x, v.y), cache[0] = v.x, cache[1] = v.y);
	else {
		if (arraysEqual(cache, v)) return;
		gl.uniform2fv(this.addr, v), copyArray(cache, v)
	}
}

function setValueV3f(gl, v) {
	let cache = this.cache;
	if (void 0 !== v.x)(cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) && (gl.uniform3f(this.addr, v.x, v.y, v.z), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z);
	else if (void 0 !== v.r)(cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) && (gl.uniform3f(this.addr, v.r, v.g, v.b), cache[0] = v.r, cache[1] = v.g, cache[2] = v.b);
	else {
		if (arraysEqual(cache, v)) return;
		gl.uniform3fv(this.addr, v), copyArray(cache, v)
	}
}

function setValueV4f(gl, v) {
	let cache = this.cache;
	if (void 0 !== v.x)(cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) && (gl.uniform4f(this.addr, v.x, v.y, v.z, v.w), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z, cache[3] = v.w);
	else {
		if (arraysEqual(cache, v)) return;
		gl.uniform4fv(this.addr, v), copyArray(cache, v)
	}
}

function setValueM2(gl, v) {
	let cache = this.cache,
		elements = v.elements;
	if (void 0 === elements) {
		if (arraysEqual(cache, v)) return;
		gl.uniformMatrix2fv(this.addr, !1, v), copyArray(cache, v)
	} else {
		if (arraysEqual(cache, elements)) return;
		mat2array.set(elements), gl.uniformMatrix2fv(this.addr, !1, mat2array), copyArray(cache, elements)
	}
}

function setValueM3(gl, v) {
	let cache = this.cache,
		elements = v.elements;
	if (void 0 === elements) {
		if (arraysEqual(cache, v)) return;
		gl.uniformMatrix3fv(this.addr, !1, v), copyArray(cache, v)
	} else {
		if (arraysEqual(cache, elements)) return;
		mat3array.set(elements), gl.uniformMatrix3fv(this.addr, !1, mat3array), copyArray(cache, elements)
	}
}

function setValueM4(gl, v) {
	let cache = this.cache,
		elements = v.elements;
	if (void 0 === elements) {
		if (arraysEqual(cache, v)) return;
		gl.uniformMatrix4fv(this.addr, !1, v), copyArray(cache, v)
	} else {
		if (arraysEqual(cache, elements)) return;
		mat4array.set(elements), gl.uniformMatrix4fv(this.addr, !1, mat4array), copyArray(cache, elements)
	}
}

function setValueV1i(gl, v) {
	let cache = this.cache;
	cache[0] !== v && (gl.uniform1i(this.addr, v), cache[0] = v)
}

function setValueV2i(gl, v) {
	let cache = this.cache;
	if (void 0 !== v.x)(cache[0] !== v.x || cache[1] !== v.y) && (gl.uniform2i(this.addr, v.x, v.y), cache[0] = v.x, cache[1] = v.y);
	else {
		if (arraysEqual(cache, v)) return;
		gl.uniform2iv(this.addr, v), copyArray(cache, v)
	}
}

function setValueV3i(gl, v) {
	let cache = this.cache;
	if (void 0 !== v.x)(cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) && (gl.uniform3i(this.addr, v.x, v.y, v.z), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z);
	else {
		if (arraysEqual(cache, v)) return;
		gl.uniform3iv(this.addr, v), copyArray(cache, v)
	}
}

function setValueV4i(gl, v) {
	let cache = this.cache;
	if (void 0 !== v.x)(cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) && (gl.uniform4i(this.addr, v.x, v.y, v.z, v.w), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z, cache[3] = v.w);
	else {
		if (arraysEqual(cache, v)) return;
		gl.uniform4iv(this.addr, v), copyArray(cache, v)
	}
}

function setValueV1ui(gl, v) {
	let cache = this.cache;
	cache[0] !== v && (gl.uniform1ui(this.addr, v), cache[0] = v)
}

function setValueV2ui(gl, v) {
	let cache = this.cache;
	if (void 0 !== v.x)(cache[0] !== v.x || cache[1] !== v.y) && (gl.uniform2ui(this.addr, v.x, v.y), cache[0] = v.x, cache[1] = v.y);
	else {
		if (arraysEqual(cache, v)) return;
		gl.uniform2uiv(this.addr, v), copyArray(cache, v)
	}
}

function setValueV3ui(gl, v) {
	let cache = this.cache;
	if (void 0 !== v.x)(cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) && (gl.uniform3ui(this.addr, v.x, v.y, v.z), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z);
	else {
		if (arraysEqual(cache, v)) return;
		gl.uniform3uiv(this.addr, v), copyArray(cache, v)
	}
}

function setValueV4ui(gl, v) {
	let cache = this.cache;
	if (void 0 !== v.x)(cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) && (gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w), cache[0] = v.x, cache[1] = v.y, cache[2] = v.z, cache[3] = v.w);
	else {
		if (arraysEqual(cache, v)) return;
		gl.uniform4uiv(this.addr, v), copyArray(cache, v)
	}
}

function setValueT1(gl, v, textures) {
	let cache = this.cache,
		unit = textures.allocateTextureUnit();
	cache[0] !== unit && (gl.uniform1i(this.addr, unit), cache[0] = unit);
	let emptyTexture2D = this.type === gl.SAMPLER_2D_SHADOW ? emptyShadowTexture : emptyTexture;
	textures.setTexture2D(v || emptyTexture2D, unit)
}

function setValueT3D1(gl, v, textures) {
	let cache = this.cache,
		unit = textures.allocateTextureUnit();
	cache[0] !== unit && (gl.uniform1i(this.addr, unit), cache[0] = unit), textures.setTexture3D(v || empty3dTexture, unit)
}

function setValueT6(gl, v, textures) {
	let cache = this.cache,
		unit = textures.allocateTextureUnit();
	cache[0] !== unit && (gl.uniform1i(this.addr, unit), cache[0] = unit), textures.setTextureCube(v || emptyCubeTexture, unit)
}

function setValueT2DArray1(gl, v, textures) {
	let cache = this.cache,
		unit = textures.allocateTextureUnit();
	cache[0] !== unit && (gl.uniform1i(this.addr, unit), cache[0] = unit), textures.setTexture2DArray(v || emptyArrayTexture, unit)
}

function setValueV1fArray(gl, v) {
	gl.uniform1fv(this.addr, v)
}

function setValueV2fArray(gl, v) {
	let data = flatten(v, this.size, 2);
	gl.uniform2fv(this.addr, data)
}

function setValueV3fArray(gl, v) {
	let data = flatten(v, this.size, 3);
	gl.uniform3fv(this.addr, data)
}

function setValueV4fArray(gl, v) {
	let data = flatten(v, this.size, 4);
	gl.uniform4fv(this.addr, data)
}

function setValueM2Array(gl, v) {
	let data = flatten(v, this.size, 4);
	gl.uniformMatrix2fv(this.addr, !1, data)
}

function setValueM3Array(gl, v) {
	let data = flatten(v, this.size, 9);
	gl.uniformMatrix3fv(this.addr, !1, data)
}

function setValueM4Array(gl, v) {
	let data = flatten(v, this.size, 16);
	gl.uniformMatrix4fv(this.addr, !1, data)
}

function setValueV1iArray(gl, v) {
	gl.uniform1iv(this.addr, v)
}

function setValueV2iArray(gl, v) {
	gl.uniform2iv(this.addr, v)
}

function setValueV3iArray(gl, v) {
	gl.uniform3iv(this.addr, v)
}

function setValueV4iArray(gl, v) {
	gl.uniform4iv(this.addr, v)
}

function setValueV1uiArray(gl, v) {
	gl.uniform1uiv(this.addr, v)
}

function setValueV2uiArray(gl, v) {
	gl.uniform2uiv(this.addr, v)
}

function setValueV3uiArray(gl, v) {
	gl.uniform3uiv(this.addr, v)
}

function setValueV4uiArray(gl, v) {
	gl.uniform4uiv(this.addr, v)
}

function setValueT1Array(gl, v, textures) {
	let cache = this.cache,
		n = v.length,
		units = allocTexUnits(textures, n);
	arraysEqual(cache, units) || (gl.uniform1iv(this.addr, units), copyArray(cache, units));
	for (let i = 0; i !== n; ++i) textures.setTexture2D(v[i] || emptyTexture, units[i])
}

function setValueT3DArray(gl, v, textures) {
	let cache = this.cache,
		n = v.length,
		units = allocTexUnits(textures, n);
	arraysEqual(cache, units) || (gl.uniform1iv(this.addr, units), copyArray(cache, units));
	for (let i = 0; i !== n; ++i) textures.setTexture3D(v[i] || empty3dTexture, units[i])
}

function setValueT6Array(gl, v, textures) {
	let cache = this.cache,
		n = v.length,
		units = allocTexUnits(textures, n);
	arraysEqual(cache, units) || (gl.uniform1iv(this.addr, units), copyArray(cache, units));
	for (let i = 0; i !== n; ++i) textures.setTextureCube(v[i] || emptyCubeTexture, units[i])
}

function setValueT2DArrayArray(gl, v, textures) {
	let cache = this.cache,
		n = v.length,
		units = allocTexUnits(textures, n);
	arraysEqual(cache, units) || (gl.uniform1iv(this.addr, units), copyArray(cache, units));
	for (let i = 0; i !== n; ++i) textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i])
}
class SingleUniform {
	constructor(id, activeInfo, addr) {
		this.id = id, this.addr = addr, this.cache = [], this.type = activeInfo.type, this.setValue = function(type) {
			switch (type) {
				case 5126:
					return setValueV1f;
				case 35664:
					return setValueV2f;
				case 35665:
					return setValueV3f;
				case 35666:
					return setValueV4f;
				case 35674:
					return setValueM2;
				case 35675:
					return setValueM3;
				case 35676:
					return setValueM4;
				case 5124:
				case 35670:
					return setValueV1i;
				case 35667:
				case 35671:
					return setValueV2i;
				case 35668:
				case 35672:
					return setValueV3i;
				case 35669:
				case 35673:
					return setValueV4i;
				case 5125:
					return setValueV1ui;
				case 36294:
					return setValueV2ui;
				case 36295:
					return setValueV3ui;
				case 36296:
					return setValueV4ui;
				case 35678:
				case 36198:
				case 36298:
				case 36306:
				case 35682:
					return setValueT1;
				case 35679:
				case 36299:
				case 36307:
					return setValueT3D1;
				case 35680:
				case 36300:
				case 36308:
				case 36293:
					return setValueT6;
				case 36289:
				case 36303:
				case 36311:
				case 36292:
					return setValueT2DArray1
			}
		}(activeInfo.type)
	}
}
class PureArrayUniform {
	constructor(id, activeInfo, addr) {
		this.id = id, this.addr = addr, this.cache = [], this.type = activeInfo.type, this.size = activeInfo.size, this.setValue = function(type) {
			switch (type) {
				case 5126:
					return setValueV1fArray;
				case 35664:
					return setValueV2fArray;
				case 35665:
					return setValueV3fArray;
				case 35666:
					return setValueV4fArray;
				case 35674:
					return setValueM2Array;
				case 35675:
					return setValueM3Array;
				case 35676:
					return setValueM4Array;
				case 5124:
				case 35670:
					return setValueV1iArray;
				case 35667:
				case 35671:
					return setValueV2iArray;
				case 35668:
				case 35672:
					return setValueV3iArray;
				case 35669:
				case 35673:
					return setValueV4iArray;
				case 5125:
					return setValueV1uiArray;
				case 36294:
					return setValueV2uiArray;
				case 36295:
					return setValueV3uiArray;
				case 36296:
					return setValueV4uiArray;
				case 35678:
				case 36198:
				case 36298:
				case 36306:
				case 35682:
					return setValueT1Array;
				case 35679:
				case 36299:
				case 36307:
					return setValueT3DArray;
				case 35680:
				case 36300:
				case 36308:
				case 36293:
					return setValueT6Array;
				case 36289:
				case 36303:
				case 36311:
				case 36292:
					return setValueT2DArrayArray
			}
		}(activeInfo.type)
	}
}
class StructuredUniform {
	constructor(id) {
		this.id = id, this.seq = [], this.map = {}
	}
	setValue(gl, value, textures) {
		let seq = this.seq;
		for (let i = 0, n = seq.length; i !== n; ++i) {
			let u = seq[i];
			u.setValue(gl, value[u.id], textures)
		}
	}
}
let RePathPart = /(\w+)(\])?(\[|\.)?/g;

function addUniform(container, uniformObject) {
	container.seq.push(uniformObject), container.map[uniformObject.id] = uniformObject
}
class WebGLUniforms {
	constructor(gl, program) {
		this.seq = [], this.map = {};
		let n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		for (let i = 0; i < n; ++i) {
			let info = gl.getActiveUniform(program, i),
				addr = gl.getUniformLocation(program, info.name);
			! function(activeInfo, addr, container) {
				let path = activeInfo.name,
					pathLength = path.length;
				for (RePathPart.lastIndex = 0;;) {
					let match = RePathPart.exec(path),
						matchEnd = RePathPart.lastIndex,
						id = match[1],
						idIsIndex = "]" === match[2],
						subscript = match[3];
					if (idIsIndex && (id |= 0), void 0 === subscript || "[" === subscript && matchEnd + 2 === pathLength) {
						addUniform(container, void 0 === subscript ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
						break
					} {
						let next = container.map[id];
						void 0 === next && addUniform(container, next = new StructuredUniform(id)), container = next
					}
				}
			}(info, addr, this)
		}
	}
	setValue(gl, name, value, textures) {
		let u = this.map[name];
		void 0 !== u && u.setValue(gl, value, textures)
	}
	setOptional(gl, object, name) {
		let v = object[name];
		void 0 !== v && this.setValue(gl, name, v)
	}
	static upload(gl, seq, values, textures) {
		for (let i = 0, n = seq.length; i !== n; ++i) {
			let u = seq[i],
				v = values[u.id];
			!1 !== v.needsUpdate && u.setValue(gl, v.value, textures)
		}
	}
	static seqWithValue(seq, values) {
		let r = [];
		for (let i = 0, n = seq.length; i !== n; ++i) {
			let u = seq[i];
			u.id in values && r.push(u)
		}
		return r
	}
}

function WebGLShader(gl, type, string) {
	let shader = gl.createShader(type);
	return gl.shaderSource(shader, string), gl.compileShader(shader), shader
}
let programIdCount = 0;

function getShaderErrors(gl, shader, type) {
	let status = gl.getShaderParameter(shader, gl.COMPILE_STATUS),
		errors = gl.getShaderInfoLog(shader).trim();
	if (status && "" === errors) return "";
	let errorMatches = /ERROR: 0:(\d+)/.exec(errors);
	if (!errorMatches) return errors;
	{
		let errorLine = parseInt(errorMatches[1]);
		return type.toUpperCase() + "\n\n" + errors + "\n\n" + function(string, errorLine) {
			let lines = string.split("\n"),
				lines2 = [],
				from = Math.max(errorLine - 6, 0),
				to = Math.min(errorLine + 6, lines.length);
			for (let i = from; i < to; i++) {
				let line = i + 1;
				lines2.push(`${line===errorLine?">":" "} ${line}: ${lines[i]}`)
			}
			return lines2.join("\n")
		}(gl.getShaderSource(shader), errorLine)
	}
}

function filterEmptyLine(string) {
	return "" !== string
}

function replaceLightNums(string, parameters) {
	let numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
	return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows)
}

function replaceClippingPlaneNums(string, parameters) {
	return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection)
}
let includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes(string) {
	return string.replace(includePattern, includeReplacer)
}
let shaderChunkMap = new Map([
	["encodings_fragment", "colorspace_fragment"],
	["encodings_pars_fragment", "colorspace_pars_fragment"],
	["output_fragment", "opaque_fragment"]
]);

function includeReplacer(match, include) {
	let string = ShaderChunk[include];
	if (void 0 === string) {
		let newInclude = shaderChunkMap.get(include);
		if (void 0 !== newInclude) string = ShaderChunk[newInclude], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
		else throw Error("Can not resolve #include <" + include + ">")
	}
	return resolveIncludes(string)
}
let unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops(string) {
	return string.replace(unrollLoopPattern, loopReplacer)
}

function loopReplacer(match, start, end, snippet) {
	let string = "";
	for (let i = parseInt(start); i < parseInt(end); i++) string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
	return string
}

function generatePrecision(parameters) {
	let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
	return "highp" === parameters.precision ? precisionstring += "\n#define HIGH_PRECISION" : "mediump" === parameters.precision ? precisionstring += "\n#define MEDIUM_PRECISION" : "lowp" === parameters.precision && (precisionstring += "\n#define LOW_PRECISION"), precisionstring
}

function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
	let prefixVertex, prefixFragment, cachedUniforms, cachedAttributes, shadowMapTypeDefine, envMapModeDefine;
	let gl = renderer.getContext(),
		defines = parameters.defines,
		vertexShader = parameters.vertexShader,
		fragmentShader = parameters.fragmentShader,
		shadowMapTypeDefine1 = (shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC", 1 === parameters.shadowMapType ? shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF" : 2 === parameters.shadowMapType ? shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === parameters.shadowMapType && (shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM"), shadowMapTypeDefine),
		envMapTypeDefine = function(parameters) {
			let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
			if (parameters.envMap) switch (parameters.envMapMode) {
				case 301:
				case 302:
					envMapTypeDefine = "ENVMAP_TYPE_CUBE";
					break;
				case 306:
					envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV"
			}
			return envMapTypeDefine
		}(parameters),
		envMapModeDefine1 = (envMapModeDefine = "ENVMAP_MODE_REFLECTION", parameters.envMap && 302 === parameters.envMapMode && (envMapModeDefine = "ENVMAP_MODE_REFRACTION"), envMapModeDefine),
		envMapBlendingDefine = function(parameters) {
			let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
			if (parameters.envMap) switch (parameters.combine) {
				case 0:
					envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
					break;
				case 1:
					envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
					break;
				case 2:
					envMapBlendingDefine = "ENVMAP_BLENDING_ADD"
			}
			return envMapBlendingDefine
		}(parameters),
		envMapCubeUVSize = function(parameters) {
			let imageHeight = parameters.envMapCubeUVHeight;
			if (null === imageHeight) return null;
			let maxMip = Math.log2(imageHeight) - 2;
			return {
				texelWidth: 1 / (3 * Math.max(Math.pow(2, maxMip), 112)),
				texelHeight: 1 / imageHeight,
				maxMip
			}
		}(parameters),
		customExtensions = parameters.isWebGL2 ? "" : [parameters.extensionDerivatives || parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.normalMapTangentSpace || parameters.clearcoatNormalMap || parameters.flatShading || "physical" === parameters.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(filterEmptyLine).join("\n"),
		customVertexExtensions = [parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : ""].filter(filterEmptyLine).join("\n"),
		customDefines = function(defines) {
			let chunks = [];
			for (let name in defines) {
				let value = defines[name];
				!1 !== value && chunks.push("#define " + name + " " + value)
			}
			return chunks.join("\n")
		}(defines),
		program = gl.createProgram(),
		versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
	parameters.isRawShaderMaterial ? ((prefixVertex = ["#define SHADER_TYPE " + parameters.shaderType, "#define SHADER_NAME " + parameters.shaderName, customDefines].filter(filterEmptyLine).join("\n")).length > 0 && (prefixVertex += "\n"), (prefixFragment = [customExtensions, "#define SHADER_TYPE " + parameters.shaderType, "#define SHADER_NAME " + parameters.shaderName, customDefines].filter(filterEmptyLine).join("\n")).length > 0 && (prefixFragment += "\n")) : (prefixVertex = [generatePrecision(parameters), "#define SHADER_TYPE " + parameters.shaderType, "#define SHADER_NAME " + parameters.shaderName, customDefines, parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", parameters.batching ? "#define USE_BATCHING" : "", parameters.instancing ? "#define USE_INSTANCING" : "", parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "", parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine1 : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.anisotropy ? "#define USE_ANISOTROPY" : "", parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.alphaHash ? "#define USE_ALPHAHASH" : "", parameters.transmission ? "#define USE_TRANSMISSION" : "", parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "", parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "", parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "", parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "", parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "", parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "", parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "", parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "", parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "", parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "", parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "", parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "", parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "", parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "", parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "", parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "", parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "", parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "", parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "", parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "", parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "", parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "", parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "", parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "", parameters.vertexTangents && !1 === parameters.flatShading ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", parameters.vertexUv1s ? "#define USE_UV1" : "", parameters.vertexUv2s ? "#define USE_UV2" : "", parameters.vertexUv3s ? "#define USE_UV3" : "", parameters.pointsUvs ? "#define USE_POINTS_UV" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && !1 === parameters.flatShading ? "#define USE_MORPHNORMALS" : "", parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "", parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "", parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine1 : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n"), prefixFragment = [customExtensions, generatePrecision(parameters), "#define SHADER_TYPE " + parameters.shaderType, "#define SHADER_NAME " + parameters.shaderName, customDefines, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.matcap ? "#define USE_MATCAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine1 : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "", envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "", envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.anisotropy ? "#define USE_ANISOTROPY" : "", parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", parameters.clearcoat ? "#define USE_CLEARCOAT" : "", parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.iridescence ? "#define USE_IRIDESCENCE" : "", parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.alphaTest ? "#define USE_ALPHATEST" : "", parameters.alphaHash ? "#define USE_ALPHAHASH" : "", parameters.sheen ? "#define USE_SHEEN" : "", parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", parameters.transmission ? "#define USE_TRANSMISSION" : "", parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "", parameters.vertexTangents && !1 === parameters.flatShading ? "#define USE_TANGENT" : "", parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "", parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", parameters.vertexUv1s ? "#define USE_UV1" : "", parameters.vertexUv2s ? "#define USE_UV2" : "", parameters.vertexUv3s ? "#define USE_UV3" : "", parameters.pointsUvs ? "#define USE_POINTS_UV" : "", parameters.gradientMap ? "#define USE_GRADIENTMAP" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine1 : "", parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "", parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== parameters.toneMapping ? "#define TONE_MAPPING" : "", 0 !== parameters.toneMapping ? ShaderChunk.tonemapping_pars_fragment : "", 0 !== parameters.toneMapping ? function(functionName, toneMapping) {
		let toneMappingName;
		switch (toneMapping) {
			case 1:
				toneMappingName = "Linear";
				break;
			case 2:
				toneMappingName = "Reinhard";
				break;
			case 3:
				toneMappingName = "OptimizedCineon";
				break;
			case 4:
				toneMappingName = "ACESFilmic";
				break;
			case 6:
				toneMappingName = "AgX";
				break;
			case 5:
				toneMappingName = "Custom";
				break;
			default:
				console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping), toneMappingName = "Linear"
		}
		return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }"
	}("toneMapping", parameters.toneMapping) : "", parameters.dithering ? "#define DITHERING" : "", parameters.opaque ? "#define OPAQUE" : "", ShaderChunk.colorspace_pars_fragment, function(functionName, colorSpace1) {
		let components = function(colorSpace1) {
			let gamutMapping;
			let workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
				encodingPrimaries = ColorManagement.getPrimaries(colorSpace1);
			switch (workingPrimaries === encodingPrimaries ? gamutMapping = "" : "p3" === workingPrimaries && encodingPrimaries === Rec709Primaries ? gamutMapping = "LinearDisplayP3ToLinearSRGB" : workingPrimaries === Rec709Primaries && "p3" === encodingPrimaries && (gamutMapping = "LinearSRGBToLinearDisplayP3"), colorSpace1) {
				case LinearSRGBColorSpace:
				case LinearDisplayP3ColorSpace:
					return [gamutMapping, "LinearTransferOETF"];
				case SRGBColorSpace:
				case DisplayP3ColorSpace:
					return [gamutMapping, "sRGBTransferOETF"];
				default:
					return console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace1), [gamutMapping, "LinearTransferOETF"]
			}
		}(colorSpace1);
		return `vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`
	}("linearToOutputTexel", parameters.outputColorSpace), parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "", "\n"].filter(filterEmptyLine).join("\n")), vertexShader = replaceClippingPlaneNums(vertexShader = replaceLightNums(vertexShader = resolveIncludes(vertexShader), parameters), parameters), fragmentShader = replaceClippingPlaneNums(fragmentShader = replaceLightNums(fragmentShader = resolveIncludes(fragmentShader), parameters), parameters), vertexShader = unrollLoops(vertexShader), fragmentShader = unrollLoops(fragmentShader), parameters.isWebGL2 && !0 !== parameters.isRawShaderMaterial && (versionString = "#version 300 es\n", prefixVertex = [customVertexExtensions, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + prefixVertex, prefixFragment = ["precision mediump sampler2DArray;", "#define varying in", parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + prefixFragment);
	let vertexGlsl = versionString + prefixVertex + vertexShader,
		fragmentGlsl = versionString + prefixFragment + fragmentShader,
		glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl),
		glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);

	function onFirstUse(self1) {
		if (renderer.debug.checkShaderErrors) {
			let programLog = gl.getProgramInfoLog(program).trim(),
				vertexLog = gl.getShaderInfoLog(glVertexShader).trim(),
				fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim(),
				runnable = !0,
				haveDiagnostics = !0;
			if (!1 === gl.getProgramParameter(program, gl.LINK_STATUS)) {
				if (runnable = !1, "function" == typeof renderer.debug.onShaderError) renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
				else {
					let vertexErrors = getShaderErrors(gl, glVertexShader, "vertex"),
						fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
					console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors)
				}
			} else "" !== programLog ? console.warn("THREE.WebGLProgram: Program Info Log:", programLog) : ("" === vertexLog || "" === fragmentLog) && (haveDiagnostics = !1);
			haveDiagnostics && (self1.diagnostics = {
				runnable: runnable,
				programLog: programLog,
				vertexShader: {
					log: vertexLog,
					prefix: prefixVertex
				},
				fragmentShader: {
					log: fragmentLog,
					prefix: prefixFragment
				}
			})
		}
		gl.deleteShader(glVertexShader), gl.deleteShader(glFragmentShader), cachedUniforms = new WebGLUniforms(gl, program), cachedAttributes = function(gl, program) {
			let attributes = {},
				n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
			for (let i = 0; i < n; i++) {
				let info = gl.getActiveAttrib(program, i),
					name = info.name,
					locationSize = 1;
				info.type === gl.FLOAT_MAT2 && (locationSize = 2), info.type === gl.FLOAT_MAT3 && (locationSize = 3), info.type === gl.FLOAT_MAT4 && (locationSize = 4), attributes[name] = {
					type: info.type,
					location: gl.getAttribLocation(program, name),
					locationSize: locationSize
				}
			}
			return attributes
		}(gl, program)
	}
	gl.attachShader(program, glVertexShader), gl.attachShader(program, glFragmentShader), void 0 !== parameters.index0AttributeName ? gl.bindAttribLocation(program, 0, parameters.index0AttributeName) : !0 === parameters.morphTargets && gl.bindAttribLocation(program, 0, "position"), gl.linkProgram(program), this.getUniforms = function() {
		return void 0 === cachedUniforms && onFirstUse(this), cachedUniforms
	}, this.getAttributes = function() {
		return void 0 === cachedAttributes && onFirstUse(this), cachedAttributes
	};
	let programReady = !1 === parameters.rendererExtensionParallelShaderCompile;
	return this.isReady = function() {
		return !1 === programReady && (programReady = gl.getProgramParameter(program, 37297)), programReady
	}, this.destroy = function() {
		bindingStates.releaseStatesOfProgram(this), gl.deleteProgram(program), this.program = void 0
	}, this.type = parameters.shaderType, this.name = parameters.shaderName, this.id = programIdCount++, this.cacheKey = cacheKey, this.usedTimes = 1, this.program = program, this.vertexShader = glVertexShader, this.fragmentShader = glFragmentShader, this
}
let _id$1 = 0;
class WebGLShaderCache {
	constructor() {
		this.shaderCache = new Map, this.materialCache = new Map
	}
	update(material) {
		let vertexShader = material.vertexShader,
			fragmentShader = material.fragmentShader,
			vertexShaderStage = this._getShaderStage(vertexShader),
			fragmentShaderStage = this._getShaderStage(fragmentShader),
			materialShaders = this._getShaderCacheForMaterial(material);
		return !1 === materialShaders.has(vertexShaderStage) && (materialShaders.add(vertexShaderStage), vertexShaderStage.usedTimes++), !1 === materialShaders.has(fragmentShaderStage) && (materialShaders.add(fragmentShaderStage), fragmentShaderStage.usedTimes++), this
	}
	remove(material) {
		for (let shaderStage of this.materialCache.get(material)) shaderStage.usedTimes--, 0 === shaderStage.usedTimes && this.shaderCache.delete(shaderStage.code);
		return this.materialCache.delete(material), this
	}
	getVertexShaderID(material) {
		return this._getShaderStage(material.vertexShader).id
	}
	getFragmentShaderID(material) {
		return this._getShaderStage(material.fragmentShader).id
	}
	dispose() {
		this.shaderCache.clear(), this.materialCache.clear()
	}
	_getShaderCacheForMaterial(material) {
		let cache = this.materialCache,
			set = cache.get(material);
		return void 0 === set && (set = new Set, cache.set(material, set)), set
	}
	_getShaderStage(code) {
		let cache = this.shaderCache,
			stage = cache.get(code);
		return void 0 === stage && (stage = new WebGLShaderStage(code), cache.set(code, stage)), stage
	}
}
class WebGLShaderStage {
	constructor(code) {
		this.id = _id$1++, this.code = code, this.usedTimes = 0
	}
}

function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
	let _programLayers = new Layers,
		_customShaders = new WebGLShaderCache,
		programs = [],
		IS_WEBGL2 = capabilities.isWebGL2,
		logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer,
		SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures,
		precision = capabilities.precision,
		shaderIDs = {
			MeshDepthMaterial: "depth",
			MeshDistanceMaterial: "distanceRGBA",
			MeshNormalMaterial: "normal",
			MeshBasicMaterial: "basic",
			MeshLambertMaterial: "lambert",
			MeshPhongMaterial: "phong",
			MeshToonMaterial: "toon",
			MeshStandardMaterial: "physical",
			MeshPhysicalMaterial: "physical",
			MeshMatcapMaterial: "matcap",
			LineBasicMaterial: "basic",
			LineDashedMaterial: "dashed",
			PointsMaterial: "points",
			ShadowMaterial: "shadow",
			SpriteMaterial: "sprite"
		};

	function getChannel(value) {
		return 0 === value ? "uv" : `uv${value}`
	}
	return {
		getParameters: function(material, lights, shadows, scene, object) {
			let vertexShader, fragmentShader, customVertexShaderID, customFragmentShaderID;
			let fog = scene.fog,
				geometry = object.geometry,
				environment = material.isMeshStandardMaterial ? scene.environment : null,
				envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment),
				envMapCubeUVHeight = envMap && 306 === envMap.mapping ? envMap.image.height : null,
				shaderID = shaderIDs[material.type];
			null !== material.precision && (precision = capabilities.getMaxPrecision(material.precision)) !== material.precision && console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
			let morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color,
				morphTargetsCount = void 0 !== morphAttribute ? morphAttribute.length : 0,
				morphTextureStride = 0;
			if (void 0 !== geometry.morphAttributes.position && (morphTextureStride = 1), void 0 !== geometry.morphAttributes.normal && (morphTextureStride = 2), void 0 !== geometry.morphAttributes.color && (morphTextureStride = 3), shaderID) {
				let shader = ShaderLib[shaderID];
				vertexShader = shader.vertexShader, fragmentShader = shader.fragmentShader
			} else vertexShader = material.vertexShader, fragmentShader = material.fragmentShader, _customShaders.update(material), customVertexShaderID = _customShaders.getVertexShaderID(material), customFragmentShaderID = _customShaders.getFragmentShaderID(material);
			let currentRenderTarget = renderer.getRenderTarget(),
				IS_INSTANCEDMESH = !0 === object.isInstancedMesh,
				IS_BATCHEDMESH = !0 === object.isBatchedMesh,
				HAS_MAP = !!material.map,
				HAS_MATCAP = !!material.matcap,
				HAS_ENVMAP = !!envMap,
				HAS_AOMAP = !!material.aoMap,
				HAS_LIGHTMAP = !!material.lightMap,
				HAS_BUMPMAP = !!material.bumpMap,
				HAS_NORMALMAP = !!material.normalMap,
				HAS_DISPLACEMENTMAP = !!material.displacementMap,
				HAS_EMISSIVEMAP = !!material.emissiveMap,
				HAS_METALNESSMAP = !!material.metalnessMap,
				HAS_ROUGHNESSMAP = !!material.roughnessMap,
				HAS_ANISOTROPY = material.anisotropy > 0,
				HAS_CLEARCOAT = material.clearcoat > 0,
				HAS_IRIDESCENCE = material.iridescence > 0,
				HAS_SHEEN = material.sheen > 0,
				HAS_TRANSMISSION = material.transmission > 0,
				HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap,
				HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap,
				HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap,
				HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap,
				HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap,
				HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap,
				HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap,
				HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap,
				HAS_SPECULARMAP = !!material.specularMap,
				HAS_SPECULAR_COLORMAP = !!material.specularColorMap,
				HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap,
				HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap,
				HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap,
				HAS_GRADIENTMAP = !!material.gradientMap,
				HAS_ALPHAMAP = !!material.alphaMap,
				HAS_ALPHATEST = material.alphaTest > 0,
				HAS_ALPHAHASH = !!material.alphaHash,
				HAS_EXTENSIONS = !!material.extensions,
				HAS_ATTRIBUTE_UV1 = !!geometry.attributes.uv1,
				HAS_ATTRIBUTE_UV2 = !!geometry.attributes.uv2,
				HAS_ATTRIBUTE_UV3 = !!geometry.attributes.uv3,
				toneMapping = 0;
			return material.toneMapped && (null === currentRenderTarget || !0 === currentRenderTarget.isXRRenderTarget) && (toneMapping = renderer.toneMapping), {
				isWebGL2: IS_WEBGL2,
				shaderID: shaderID,
				shaderType: material.type,
				shaderName: material.name,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,
				customVertexShaderID: customVertexShaderID,
				customFragmentShaderID: customFragmentShaderID,
				isRawShaderMaterial: !0 === material.isRawShaderMaterial,
				glslVersion: material.glslVersion,
				precision: precision,
				batching: IS_BATCHEDMESH,
				instancing: IS_INSTANCEDMESH,
				instancingColor: IS_INSTANCEDMESH && null !== object.instanceColor,
				supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
				outputColorSpace: null === currentRenderTarget ? renderer.outputColorSpace : !0 === currentRenderTarget.isXRRenderTarget ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
				map: HAS_MAP,
				matcap: HAS_MATCAP,
				envMap: HAS_ENVMAP,
				envMapMode: HAS_ENVMAP && envMap.mapping,
				envMapCubeUVHeight: envMapCubeUVHeight,
				aoMap: HAS_AOMAP,
				lightMap: HAS_LIGHTMAP,
				bumpMap: HAS_BUMPMAP,
				normalMap: HAS_NORMALMAP,
				displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
				emissiveMap: HAS_EMISSIVEMAP,
				normalMapObjectSpace: HAS_NORMALMAP && 1 === material.normalMapType,
				normalMapTangentSpace: HAS_NORMALMAP && 0 === material.normalMapType,
				metalnessMap: HAS_METALNESSMAP,
				roughnessMap: HAS_ROUGHNESSMAP,
				anisotropy: HAS_ANISOTROPY,
				anisotropyMap: HAS_ANISOTROPYMAP,
				clearcoat: HAS_CLEARCOAT,
				clearcoatMap: HAS_CLEARCOATMAP,
				clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
				clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
				iridescence: HAS_IRIDESCENCE,
				iridescenceMap: HAS_IRIDESCENCEMAP,
				iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
				sheen: HAS_SHEEN,
				sheenColorMap: HAS_SHEEN_COLORMAP,
				sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
				specularMap: HAS_SPECULARMAP,
				specularColorMap: HAS_SPECULAR_COLORMAP,
				specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
				transmission: HAS_TRANSMISSION,
				transmissionMap: HAS_TRANSMISSIONMAP,
				thicknessMap: HAS_THICKNESSMAP,
				gradientMap: HAS_GRADIENTMAP,
				opaque: !1 === material.transparent && 1 === material.blending,
				alphaMap: HAS_ALPHAMAP,
				alphaTest: HAS_ALPHATEST,
				alphaHash: HAS_ALPHAHASH,
				combine: material.combine,
				mapUv: HAS_MAP && getChannel(material.map.channel),
				aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
				lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
				bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
				normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
				displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
				emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
				metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
				roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
				anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
				clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
				clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
				clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
				iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
				iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
				sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
				sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
				specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
				specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
				specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
				transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
				thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
				alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
				vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
				vertexColors: material.vertexColors,
				vertexAlphas: !0 === material.vertexColors && !!geometry.attributes.color && 4 === geometry.attributes.color.itemSize,
				vertexUv1s: HAS_ATTRIBUTE_UV1,
				vertexUv2s: HAS_ATTRIBUTE_UV2,
				vertexUv3s: HAS_ATTRIBUTE_UV3,
				pointsUvs: !0 === object.isPoints && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
				fog: !!fog,
				useFog: !0 === material.fog,
				fogExp2: fog && fog.isFogExp2,
				flatShading: !0 === material.flatShading,
				sizeAttenuation: !0 === material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
				skinning: !0 === object.isSkinnedMesh,
				morphTargets: void 0 !== geometry.morphAttributes.position,
				morphNormals: void 0 !== geometry.morphAttributes.normal,
				morphColors: void 0 !== geometry.morphAttributes.color,
				morphTargetsCount: morphTargetsCount,
				morphTextureStride: morphTextureStride,
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numSpotLightMaps: lights.spotLightMap.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
				numLightProbes: lights.numLightProbes,
				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,
				dithering: material.dithering,
				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
				toneMapping: toneMapping,
				useLegacyLights: renderer._useLegacyLights,
				decodeVideoTexture: HAS_MAP && !0 === material.map.isVideoTexture && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
				premultipliedAlpha: material.premultipliedAlpha,
				doubleSided: 2 === material.side,
				flipSided: 1 === material.side,
				useDepthPacking: material.depthPacking >= 0,
				depthPacking: material.depthPacking || 0,
				index0AttributeName: material.index0AttributeName,
				extensionDerivatives: HAS_EXTENSIONS && !0 === material.extensions.derivatives,
				extensionFragDepth: HAS_EXTENSIONS && !0 === material.extensions.fragDepth,
				extensionDrawBuffers: HAS_EXTENSIONS && !0 === material.extensions.drawBuffers,
				extensionShaderTextureLOD: HAS_EXTENSIONS && !0 === material.extensions.shaderTextureLOD,
				extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance && extensions.has("WEBGL_clip_cull_distance"),
				rendererExtensionFragDepth: IS_WEBGL2 || extensions.has("EXT_frag_depth"),
				rendererExtensionDrawBuffers: IS_WEBGL2 || extensions.has("WEBGL_draw_buffers"),
				rendererExtensionShaderTextureLod: IS_WEBGL2 || extensions.has("EXT_shader_texture_lod"),
				rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
				customProgramCacheKey: material.customProgramCacheKey()
			}
		},
		getProgramCacheKey: function(parameters) {
			let array = [];
			if (parameters.shaderID ? array.push(parameters.shaderID) : (array.push(parameters.customVertexShaderID), array.push(parameters.customFragmentShaderID)), void 0 !== parameters.defines)
				for (let name in parameters.defines) array.push(name), array.push(parameters.defines[name]);
			return !1 === parameters.isRawShaderMaterial && (array.push(parameters.precision), array.push(parameters.outputColorSpace), array.push(parameters.envMapMode), array.push(parameters.envMapCubeUVHeight), array.push(parameters.mapUv), array.push(parameters.alphaMapUv), array.push(parameters.lightMapUv), array.push(parameters.aoMapUv), array.push(parameters.bumpMapUv), array.push(parameters.normalMapUv), array.push(parameters.displacementMapUv), array.push(parameters.emissiveMapUv), array.push(parameters.metalnessMapUv), array.push(parameters.roughnessMapUv), array.push(parameters.anisotropyMapUv), array.push(parameters.clearcoatMapUv), array.push(parameters.clearcoatNormalMapUv), array.push(parameters.clearcoatRoughnessMapUv), array.push(parameters.iridescenceMapUv), array.push(parameters.iridescenceThicknessMapUv), array.push(parameters.sheenColorMapUv), array.push(parameters.sheenRoughnessMapUv), array.push(parameters.specularMapUv), array.push(parameters.specularColorMapUv), array.push(parameters.specularIntensityMapUv), array.push(parameters.transmissionMapUv), array.push(parameters.thicknessMapUv), array.push(parameters.combine), array.push(parameters.fogExp2), array.push(parameters.sizeAttenuation), array.push(parameters.morphTargetsCount), array.push(parameters.morphAttributeCount), array.push(parameters.numDirLights), array.push(parameters.numPointLights), array.push(parameters.numSpotLights), array.push(parameters.numSpotLightMaps), array.push(parameters.numHemiLights), array.push(parameters.numRectAreaLights), array.push(parameters.numDirLightShadows), array.push(parameters.numPointLightShadows), array.push(parameters.numSpotLightShadows), array.push(parameters.numSpotLightShadowsWithMaps), array.push(parameters.numLightProbes), array.push(parameters.shadowMapType), array.push(parameters.toneMapping), array.push(parameters.numClippingPlanes), array.push(parameters.numClipIntersection), array.push(parameters.depthPacking), _programLayers.disableAll(), parameters.isWebGL2 && _programLayers.enable(0), parameters.supportsVertexTextures && _programLayers.enable(1), parameters.instancing && _programLayers.enable(2), parameters.instancingColor && _programLayers.enable(3), parameters.matcap && _programLayers.enable(4), parameters.envMap && _programLayers.enable(5), parameters.normalMapObjectSpace && _programLayers.enable(6), parameters.normalMapTangentSpace && _programLayers.enable(7), parameters.clearcoat && _programLayers.enable(8), parameters.iridescence && _programLayers.enable(9), parameters.alphaTest && _programLayers.enable(10), parameters.vertexColors && _programLayers.enable(11), parameters.vertexAlphas && _programLayers.enable(12), parameters.vertexUv1s && _programLayers.enable(13), parameters.vertexUv2s && _programLayers.enable(14), parameters.vertexUv3s && _programLayers.enable(15), parameters.vertexTangents && _programLayers.enable(16), parameters.anisotropy && _programLayers.enable(17), parameters.alphaHash && _programLayers.enable(18), parameters.batching && _programLayers.enable(19), array.push(_programLayers.mask), _programLayers.disableAll(), parameters.fog && _programLayers.enable(0), parameters.useFog && _programLayers.enable(1), parameters.flatShading && _programLayers.enable(2), parameters.logarithmicDepthBuffer && _programLayers.enable(3), parameters.skinning && _programLayers.enable(4), parameters.morphTargets && _programLayers.enable(5), parameters.morphNormals && _programLayers.enable(6), parameters.morphColors && _programLayers.enable(7), parameters.premultipliedAlpha && _programLayers.enable(8), parameters.shadowMapEnabled && _programLayers.enable(9), parameters.useLegacyLights && _programLayers.enable(10), parameters.doubleSided && _programLayers.enable(11), parameters.flipSided && _programLayers.enable(12), parameters.useDepthPacking && _programLayers.enable(13), parameters.dithering && _programLayers.enable(14), parameters.transmission && _programLayers.enable(15), parameters.sheen && _programLayers.enable(16), parameters.opaque && _programLayers.enable(17), parameters.pointsUvs && _programLayers.enable(18), parameters.decodeVideoTexture && _programLayers.enable(19), array.push(_programLayers.mask), array.push(renderer.outputColorSpace)), array.push(parameters.customProgramCacheKey), array.join()
		},
		getUniforms: function(material) {
			let uniforms;
			let shaderID = shaderIDs[material.type];
			if (shaderID) {
				let shader = ShaderLib[shaderID];
				uniforms = UniformsUtils.clone(shader.uniforms)
			} else uniforms = material.uniforms;
			return uniforms
		},
		acquireProgram: function(parameters, cacheKey) {
			let program;
			for (let p = 0, pl = programs.length; p < pl; p++) {
				let preexistingProgram = programs[p];
				if (preexistingProgram.cacheKey === cacheKey) {
					program = preexistingProgram, ++program.usedTimes;
					break
				}
			}
			return void 0 === program && (program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates), programs.push(program)), program
		},
		releaseProgram: function(program) {
			if (0 == --program.usedTimes) {
				let i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1], programs.pop(), program.destroy()
			}
		},
		releaseShaderCache: function(material) {
			_customShaders.remove(material)
		},
		programs: programs,
		dispose: function() {
			_customShaders.dispose()
		}
	}
}

function WebGLProperties() {
	let properties = new WeakMap;
	return {
		get: function(object) {
			let map = properties.get(object);
			return void 0 === map && (map = {}, properties.set(object, map)), map
		},
		remove: function(object) {
			properties.delete(object)
		},
		update: function(object, key, value) {
			properties.get(object)[key] = value
		},
		dispose: function() {
			properties = new WeakMap
		}
	}
}

function painterSortStable(a, b) {
	return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
}

function reversePainterSortStable(a, b) {
	return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
}

function WebGLRenderList() {
	let renderItems = [],
		renderItemsIndex = 0,
		opaque = [],
		transmissive = [],
		transparent = [];

	function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
		let renderItem = renderItems[renderItemsIndex];
		return void 0 === renderItem ? (renderItem = {
			id: object.id,
			object: object,
			geometry: geometry,
			material: material,
			groupOrder: groupOrder,
			renderOrder: object.renderOrder,
			z: z,
			group: group
		}, renderItems[renderItemsIndex] = renderItem) : (renderItem.id = object.id, renderItem.object = object, renderItem.geometry = geometry, renderItem.material = material, renderItem.groupOrder = groupOrder, renderItem.renderOrder = object.renderOrder, renderItem.z = z, renderItem.group = group), renderItemsIndex++, renderItem
	}
	return {
		opaque: opaque,
		transmissive: transmissive,
		transparent: transparent,
		init: function() {
			renderItemsIndex = 0, opaque.length = 0, transmissive.length = 0, transparent.length = 0
		},
		push: function(object, geometry, material, groupOrder, z, group) {
			let renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
			material.transmission > 0 ? transmissive.push(renderItem) : !0 === material.transparent ? transparent.push(renderItem) : opaque.push(renderItem)
		},
		unshift: function(object, geometry, material, groupOrder, z, group) {
			let renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
			material.transmission > 0 ? transmissive.unshift(renderItem) : !0 === material.transparent ? transparent.unshift(renderItem) : opaque.unshift(renderItem)
		},
		finish: function() {
			for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
				let renderItem = renderItems[i];
				if (null === renderItem.id) break;
				renderItem.id = null, renderItem.object = null, renderItem.geometry = null, renderItem.material = null, renderItem.group = null
			}
		},
		sort: function(customOpaqueSort, customTransparentSort) {
			opaque.length > 1 && opaque.sort(customOpaqueSort || painterSortStable), transmissive.length > 1 && transmissive.sort(customTransparentSort || reversePainterSortStable), transparent.length > 1 && transparent.sort(customTransparentSort || reversePainterSortStable)
		}
	}
}

function WebGLRenderLists() {
	let lists = new WeakMap;
	return {
		get: function(scene, renderCallDepth) {
			let list;
			let listArray = lists.get(scene);
			return void 0 === listArray ? (list = new WebGLRenderList, lists.set(scene, [list])) : renderCallDepth >= listArray.length ? (list = new WebGLRenderList, listArray.push(list)) : list = listArray[renderCallDepth], list
		},
		dispose: function() {
			lists = new WeakMap
		}
	}
}

function UniformsCache() {
	let lights = {};
	return {
		get: function(light) {
			let uniforms;
			if (void 0 !== lights[light.id]) return lights[light.id];
			switch (light.type) {
				case "DirectionalLight":
					uniforms = {
						direction: new Vector3,
						color: new Color
					};
					break;
				case "SpotLight":
					uniforms = {
						position: new Vector3,
						direction: new Vector3,
						color: new Color,
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;
				case "PointLight":
					uniforms = {
						position: new Vector3,
						color: new Color,
						distance: 0,
						decay: 0
					};
					break;
				case "HemisphereLight":
					uniforms = {
						direction: new Vector3,
						skyColor: new Color,
						groundColor: new Color
					};
					break;
				case "RectAreaLight":
					uniforms = {
						color: new Color,
						position: new Vector3,
						halfWidth: new Vector3,
						halfHeight: new Vector3
					}
			}
			return lights[light.id] = uniforms, uniforms
		}
	}
}
let nextVersion = 0;

function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
	return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0)
}

function WebGLLights(extensions, capabilities) {
	let cache = new UniformsCache,
		shadowCache = function() {
			let lights = {};
			return {
				get: function(light) {
					let uniforms;
					if (void 0 !== lights[light.id]) return lights[light.id];
					switch (light.type) {
						case "DirectionalLight":
						case "SpotLight":
							uniforms = {
								shadowBias: 0,
								shadowNormalBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2
							};
							break;
						case "PointLight":
							uniforms = {
								shadowBias: 0,
								shadowNormalBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2,
								shadowCameraNear: 1,
								shadowCameraFar: 1e3
							}
					}
					return lights[light.id] = uniforms, uniforms
				}
			}
		}(),
		state = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1,
				numSpotMaps: -1,
				numLightProbes: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotLightMap: [],
			spotShadow: [],
			spotShadowMap: [],
			spotLightMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
			numSpotLightShadowsWithMaps: 0,
			numLightProbes: 0
		};
	for (let i = 0; i < 9; i++) state.probe.push(new Vector3);
	let vector3 = new Vector3,
		matrix4 = new Matrix4,
		matrix42 = new Matrix4;
	return {
		setup: function(lights, useLegacyLights) {
			let r = 0,
				g = 0,
				b = 0;
			for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
			let directionalLength = 0,
				pointLength = 0,
				spotLength = 0,
				rectAreaLength = 0,
				hemiLength = 0,
				numDirectionalShadows = 0,
				numPointShadows = 0,
				numSpotShadows = 0,
				numSpotMaps = 0,
				numSpotShadowsWithMaps = 0,
				numLightProbes = 0;
			lights.sort(shadowCastingAndTexturingLightsFirst);
			let scaleFactor = !0 === useLegacyLights ? Math.PI : 1;
			for (let i = 0, l = lights.length; i < l; i++) {
				let light = lights[i],
					color = light.color,
					intensity = light.intensity,
					distance = light.distance,
					shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
				if (light.isAmbientLight) r += color.r * intensity * scaleFactor, g += color.g * intensity * scaleFactor, b += color.b * intensity * scaleFactor;
				else if (light.isLightProbe) {
					for (let j = 0; j < 9; j++) state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
					numLightProbes++
				} else if (light.isDirectionalLight) {
					let uniforms = cache.get(light);
					if (uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor), light.castShadow) {
						let shadow = light.shadow,
							shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias, shadowUniforms.shadowNormalBias = shadow.normalBias, shadowUniforms.shadowRadius = shadow.radius, shadowUniforms.shadowMapSize = shadow.mapSize, state.directionalShadow[directionalLength] = shadowUniforms, state.directionalShadowMap[directionalLength] = shadowMap, state.directionalShadowMatrix[directionalLength] = light.shadow.matrix, numDirectionalShadows++
					}
					state.directional[directionalLength] = uniforms, directionalLength++
				} else if (light.isSpotLight) {
					let uniforms = cache.get(light);
					uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor), uniforms.distance = distance, uniforms.coneCos = Math.cos(light.angle), uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra)), uniforms.decay = light.decay, state.spot[spotLength] = uniforms;
					let shadow = light.shadow;
					if (light.map && (state.spotLightMap[numSpotMaps] = light.map, numSpotMaps++, shadow.updateMatrices(light), light.castShadow && numSpotShadowsWithMaps++), state.spotLightMatrix[spotLength] = shadow.matrix, light.castShadow) {
						let shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias, shadowUniforms.shadowNormalBias = shadow.normalBias, shadowUniforms.shadowRadius = shadow.radius, shadowUniforms.shadowMapSize = shadow.mapSize, state.spotShadow[spotLength] = shadowUniforms, state.spotShadowMap[spotLength] = shadowMap, numSpotShadows++
					}
					spotLength++
				} else if (light.isRectAreaLight) {
					let uniforms = cache.get(light);
					uniforms.color.copy(color).multiplyScalar(intensity), uniforms.halfWidth.set(.5 * light.width, 0, 0), uniforms.halfHeight.set(0, .5 * light.height, 0), state.rectArea[rectAreaLength] = uniforms, rectAreaLength++
				} else if (light.isPointLight) {
					let uniforms = cache.get(light);
					if (uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor), uniforms.distance = light.distance, uniforms.decay = light.decay, light.castShadow) {
						let shadow = light.shadow,
							shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias, shadowUniforms.shadowNormalBias = shadow.normalBias, shadowUniforms.shadowRadius = shadow.radius, shadowUniforms.shadowMapSize = shadow.mapSize, shadowUniforms.shadowCameraNear = shadow.camera.near, shadowUniforms.shadowCameraFar = shadow.camera.far, state.pointShadow[pointLength] = shadowUniforms, state.pointShadowMap[pointLength] = shadowMap, state.pointShadowMatrix[pointLength] = light.shadow.matrix, numPointShadows++
					}
					state.point[pointLength] = uniforms, pointLength++
				} else if (light.isHemisphereLight) {
					let uniforms = cache.get(light);
					uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor), uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor), state.hemi[hemiLength] = uniforms, hemiLength++
				}
			}
			rectAreaLength > 0 && (capabilities.isWebGL2 ? !0 === extensions.has("OES_texture_float_linear") ? (state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : (state.rectAreaLTC1 = UniformsLib.LTC_HALF_1, state.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : !0 === extensions.has("OES_texture_float_linear") ? (state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1, state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2) : !0 === extensions.has("OES_texture_half_float_linear") ? (state.rectAreaLTC1 = UniformsLib.LTC_HALF_1, state.rectAreaLTC2 = UniformsLib.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), state.ambient[0] = r, state.ambient[1] = g, state.ambient[2] = b;
			let hash = state.hash;
			(hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) && (state.directional.length = directionalLength, state.spot.length = spotLength, state.rectArea.length = rectAreaLength, state.point.length = pointLength, state.hemi.length = hemiLength, state.directionalShadow.length = numDirectionalShadows, state.directionalShadowMap.length = numDirectionalShadows, state.pointShadow.length = numPointShadows, state.pointShadowMap.length = numPointShadows, state.spotShadow.length = numSpotShadows, state.spotShadowMap.length = numSpotShadows, state.directionalShadowMatrix.length = numDirectionalShadows, state.pointShadowMatrix.length = numPointShadows, state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps, state.spotLightMap.length = numSpotMaps, state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps, state.numLightProbes = numLightProbes, hash.directionalLength = directionalLength, hash.pointLength = pointLength, hash.spotLength = spotLength, hash.rectAreaLength = rectAreaLength, hash.hemiLength = hemiLength, hash.numDirectionalShadows = numDirectionalShadows, hash.numPointShadows = numPointShadows, hash.numSpotShadows = numSpotShadows, hash.numSpotMaps = numSpotMaps, hash.numLightProbes = numLightProbes, state.version = nextVersion++)
		},
		setupView: function(lights, camera) {
			let directionalLength = 0,
				pointLength = 0,
				spotLength = 0,
				rectAreaLength = 0,
				hemiLength = 0,
				viewMatrix = camera.matrixWorldInverse;
			for (let i = 0, l = lights.length; i < l; i++) {
				let light = lights[i];
				if (light.isDirectionalLight) {
					let uniforms = state.directional[directionalLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld), vector3.setFromMatrixPosition(light.target.matrixWorld), uniforms.direction.sub(vector3), uniforms.direction.transformDirection(viewMatrix), directionalLength++
				} else if (light.isSpotLight) {
					let uniforms = state.spot[spotLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), uniforms.direction.setFromMatrixPosition(light.matrixWorld), vector3.setFromMatrixPosition(light.target.matrixWorld), uniforms.direction.sub(vector3), uniforms.direction.transformDirection(viewMatrix), spotLength++
				} else if (light.isRectAreaLight) {
					let uniforms = state.rectArea[rectAreaLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), matrix42.identity(), matrix4.copy(light.matrixWorld), matrix4.premultiply(viewMatrix), matrix42.extractRotation(matrix4), uniforms.halfWidth.set(.5 * light.width, 0, 0), uniforms.halfHeight.set(0, .5 * light.height, 0), uniforms.halfWidth.applyMatrix4(matrix42), uniforms.halfHeight.applyMatrix4(matrix42), rectAreaLength++
				} else if (light.isPointLight) {
					let uniforms = state.point[pointLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld), uniforms.position.applyMatrix4(viewMatrix), pointLength++
				} else if (light.isHemisphereLight) {
					let uniforms = state.hemi[hemiLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld), uniforms.direction.transformDirection(viewMatrix), hemiLength++
				}
			}
		},
		state: state
	}
}

function WebGLRenderState(extensions, capabilities) {
	let lights = new WebGLLights(extensions, capabilities),
		lightsArray = [],
		shadowsArray = [];
	return {
		init: function() {
			lightsArray.length = 0, shadowsArray.length = 0
		},
		state: {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			lights: lights
		},
		setupLights: function(useLegacyLights) {
			lights.setup(lightsArray, useLegacyLights)
		},
		setupLightsView: function(camera) {
			lights.setupView(lightsArray, camera)
		},
		pushLight: function(light) {
			lightsArray.push(light)
		},
		pushShadow: function(shadowLight) {
			shadowsArray.push(shadowLight)
		}
	}
}

function WebGLRenderStates(extensions, capabilities) {
	let renderStates = new WeakMap;
	return {
		get: function(scene, renderCallDepth = 0) {
			let renderState;
			let renderStateArray = renderStates.get(scene);
			return void 0 === renderStateArray ? (renderState = new WebGLRenderState(extensions, capabilities), renderStates.set(scene, [renderState])) : renderCallDepth >= renderStateArray.length ? (renderState = new WebGLRenderState(extensions, capabilities), renderStateArray.push(renderState)) : renderState = renderStateArray[renderCallDepth], renderState
		},
		dispose: function() {
			renderStates = new WeakMap
		}
	}
}
class MeshDepthMaterial extends Material$1 {
	constructor(parameters) {
		super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(parameters)
	}
	copy(source) {
		return super.copy(source), this.depthPacking = source.depthPacking, this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this
	}
}
class MeshDistanceMaterial extends Material$1 {
	constructor(parameters) {
		super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(parameters)
	}
	copy(source) {
		return super.copy(source), this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this
	}
}

function WebGLShadowMap(_renderer, _objects, _capabilities) {
	let _frustum = new Frustum,
		_shadowMapSize = new Vector2,
		_viewportSize = new Vector2,
		_viewport = new Vector4,
		_depthMaterial = new MeshDepthMaterial({
			depthPacking: 3201
		}),
		_distanceMaterial = new MeshDistanceMaterial,
		_materialCache = {},
		_maxTextureSize = _capabilities.maxTextureSize,
		shadowSide = {
			0: 1,
			1: 0,
			2: 2
		},
		shadowMaterialVertical = new ShaderMaterial({
			defines: {
				VSM_SAMPLES: 8
			},
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Vector2
				},
				radius: {
					value: 4
				}
			},
			vertexShader: "void main() {\n	gl_Position = vec4( position, 1.0 );\n}",
			fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
		}),
		shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
	let fullScreenTri = new BufferGeometry;
	fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
	let fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical),
		scope = this;
	this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1;
	let _previousType = this.type;

	function getDepthMaterial(object, material, light, type) {
		let result = null,
			customMaterial = !0 === light.isPointLight ? object.customDistanceMaterial : object.customDepthMaterial;
		if (void 0 !== customMaterial) result = customMaterial;
		else if (result = !0 === light.isPointLight ? _distanceMaterial : _depthMaterial, _renderer.localClippingEnabled && !0 === material.clipShadows && Array.isArray(material.clippingPlanes) && 0 !== material.clippingPlanes.length || material.displacementMap && 0 !== material.displacementScale || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
			let keyA = result.uuid,
				keyB = material.uuid,
				materialsForVariant = _materialCache[keyA];
			void 0 === materialsForVariant && (materialsForVariant = {}, _materialCache[keyA] = materialsForVariant);
			let cachedMaterial = materialsForVariant[keyB];
			void 0 === cachedMaterial && (cachedMaterial = result.clone(), materialsForVariant[keyB] = cachedMaterial, material.addEventListener("dispose", onMaterialDispose)), result = cachedMaterial
		}
		return result.visible = material.visible, result.wireframe = material.wireframe, 3 === type ? result.side = null !== material.shadowSide ? material.shadowSide : material.side : result.side = null !== material.shadowSide ? material.shadowSide : shadowSide[material.side], result.alphaMap = material.alphaMap, result.alphaTest = material.alphaTest, result.map = material.map, result.clipShadows = material.clipShadows, result.clippingPlanes = material.clippingPlanes, result.clipIntersection = material.clipIntersection, result.displacementMap = material.displacementMap, result.displacementScale = material.displacementScale, result.displacementBias = material.displacementBias, result.wireframeLinewidth = material.wireframeLinewidth, result.linewidth = material.linewidth, !0 === light.isPointLight && !0 === result.isMeshDistanceMaterial && (_renderer.properties.get(result).light = light), result
	}

	function onMaterialDispose(event) {
		for (let id in event.target.removeEventListener("dispose", onMaterialDispose), _materialCache) {
			let cache = _materialCache[id],
				uuid = event.target.uuid;
			uuid in cache && (cache[uuid].dispose(), delete cache[uuid])
		}
	}
	this.render = function(lights, scene, camera) {
		if (!1 === scope.enabled || !1 === scope.autoUpdate && !1 === scope.needsUpdate || 0 === lights.length) return;
		let currentRenderTarget = _renderer.getRenderTarget(),
			activeCubeFace = _renderer.getActiveCubeFace(),
			activeMipmapLevel = _renderer.getActiveMipmapLevel(),
			_state = _renderer.state;
		_state.setBlending(0), _state.buffers.color.setClear(1, 1, 1, 1), _state.buffers.depth.setTest(!0), _state.setScissorTest(!1);
		let toVSM = 3 !== _previousType && 3 === this.type,
			fromVSM = 3 === _previousType && 3 !== this.type;
		for (let i = 0, il = lights.length; i < il; i++) {
			let light = lights[i],
				shadow = light.shadow;
			if (void 0 === shadow) {
				console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
				continue
			}
			if (!1 === shadow.autoUpdate && !1 === shadow.needsUpdate) continue;
			_shadowMapSize.copy(shadow.mapSize);
			let shadowFrameExtents = shadow.getFrameExtents();
			if (_shadowMapSize.multiply(shadowFrameExtents), _viewportSize.copy(shadow.mapSize), (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) && (_shadowMapSize.x > _maxTextureSize && (_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x), _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x, shadow.mapSize.x = _viewportSize.x), _shadowMapSize.y > _maxTextureSize && (_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y), _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y, shadow.mapSize.y = _viewportSize.y)), null === shadow.map || !0 === toVSM || !0 === fromVSM) {
				let pars = 3 !== this.type ? {
					minFilter: NearestFilter,
					magFilter: NearestFilter
				} : {};
				null !== shadow.map && shadow.map.dispose(), shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars), shadow.map.texture.name = light.name + ".shadowMap", shadow.camera.updateProjectionMatrix()
			}
			_renderer.setRenderTarget(shadow.map), _renderer.clear();
			let viewportCount = shadow.getViewportCount();
			for (let vp = 0; vp < viewportCount; vp++) {
				let viewport = shadow.getViewport(vp);
				_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w), _state.viewport(_viewport), shadow.updateMatrices(light, vp), _frustum = shadow.getFrustum(),
					function renderObject(object, camera, shadowCamera, light, type) {
						if (!1 === object.visible) return;
						if (object.layers.test(camera.layers) && (object.isMesh || object.isLine || object.isPoints) && (object.castShadow || object.receiveShadow && 3 === type) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
							object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
							let geometry = _objects.update(object),
								material = object.material;
							if (Array.isArray(material)) {
								let groups = geometry.groups;
								for (let k = 0, kl = groups.length; k < kl; k++) {
									let group = groups[k],
										groupMaterial = material[group.materialIndex];
									if (groupMaterial && groupMaterial.visible) {
										let depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
										object.onBeforeShadow(_renderer, object, camera, shadowCamera, geometry, depthMaterial, group), _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group), object.onAfterShadow(_renderer, object, camera, shadowCamera, geometry, depthMaterial, group)
									}
								}
							} else if (material.visible) {
								let depthMaterial = getDepthMaterial(object, material, light, type);
								object.onBeforeShadow(_renderer, object, camera, shadowCamera, geometry, depthMaterial, null), _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null), object.onAfterShadow(_renderer, object, camera, shadowCamera, geometry, depthMaterial, null)
							}
						}
						let children = object.children;
						for (let i = 0, l = children.length; i < l; i++) renderObject(children[i], camera, shadowCamera, light, type)
					}(scene, camera, shadow.camera, light, this.type)
			}!0 !== shadow.isPointLightShadow && 3 === this.type && function(shadow, camera) {
				let geometry = _objects.update(fullScreenMesh);
				shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples && (shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples, shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples, shadowMaterialVertical.needsUpdate = !0, shadowMaterialHorizontal.needsUpdate = !0), null === shadow.mapPass && (shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y)), shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture, shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize, shadowMaterialVertical.uniforms.radius.value = shadow.radius, _renderer.setRenderTarget(shadow.mapPass), _renderer.clear(), _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null), shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture, shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize, shadowMaterialHorizontal.uniforms.radius.value = shadow.radius, _renderer.setRenderTarget(shadow.map), _renderer.clear(), _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null)
			}(shadow, camera), shadow.needsUpdate = !1
		}
		_previousType = this.type, scope.needsUpdate = !1, _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel)
	}
}

function WebGLState(gl, extensions, capabilities) {
	let isWebGL2 = capabilities.isWebGL2,
		colorBuffer = new function() {
			let locked = !1,
				color = new Vector4,
				currentColorMask = null,
				currentColorClear = new Vector4(0, 0, 0, 0);
			return {
				setMask: function(colorMask) {
					currentColorMask === colorMask || locked || (gl.colorMask(colorMask, colorMask, colorMask, colorMask), currentColorMask = colorMask)
				},
				setLocked: function(lock) {
					locked = lock
				},
				setClear: function(r, g, b, a, premultipliedAlpha) {
					!0 === premultipliedAlpha && (r *= a, g *= a, b *= a), color.set(r, g, b, a), !1 === currentColorClear.equals(color) && (gl.clearColor(r, g, b, a), currentColorClear.copy(color))
				},
				reset: function() {
					locked = !1, currentColorMask = null, currentColorClear.set(-1, 0, 0, 0)
				}
			}
		},
		depthBuffer = new function() {
			let locked = !1,
				currentDepthMask = null,
				currentDepthFunc = null,
				currentDepthClear = null;
			return {
				setTest: function(depthTest) {
					depthTest ? enable(gl.DEPTH_TEST) : disable(gl.DEPTH_TEST)
				},
				setMask: function(depthMask) {
					currentDepthMask === depthMask || locked || (gl.depthMask(depthMask), currentDepthMask = depthMask)
				},
				setFunc: function(depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						switch (depthFunc) {
							case 0:
								gl.depthFunc(gl.NEVER);
								break;
							case 1:
								gl.depthFunc(gl.ALWAYS);
								break;
							case 2:
								gl.depthFunc(gl.LESS);
								break;
							case 3:
							default:
								gl.depthFunc(gl.LEQUAL);
								break;
							case 4:
								gl.depthFunc(gl.EQUAL);
								break;
							case 5:
								gl.depthFunc(gl.GEQUAL);
								break;
							case 6:
								gl.depthFunc(gl.GREATER);
								break;
							case 7:
								gl.depthFunc(gl.NOTEQUAL)
						}
						currentDepthFunc = depthFunc
					}
				},
				setLocked: function(lock) {
					locked = lock
				},
				setClear: function(depth) {
					currentDepthClear !== depth && (gl.clearDepth(depth), currentDepthClear = depth)
				},
				reset: function() {
					locked = !1, currentDepthMask = null, currentDepthFunc = null, currentDepthClear = null
				}
			}
		},
		stencilBuffer = new function() {
			let locked = !1,
				currentStencilMask = null,
				currentStencilFunc = null,
				currentStencilRef = null,
				currentStencilFuncMask = null,
				currentStencilFail = null,
				currentStencilZFail = null,
				currentStencilZPass = null,
				currentStencilClear = null;
			return {
				setTest: function(stencilTest) {
					locked || (stencilTest ? enable(gl.STENCIL_TEST) : disable(gl.STENCIL_TEST))
				},
				setMask: function(stencilMask) {
					currentStencilMask === stencilMask || locked || (gl.stencilMask(stencilMask), currentStencilMask = stencilMask)
				},
				setFunc: function(stencilFunc, stencilRef, stencilMask) {
					(currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) && (gl.stencilFunc(stencilFunc, stencilRef, stencilMask), currentStencilFunc = stencilFunc, currentStencilRef = stencilRef, currentStencilFuncMask = stencilMask)
				},
				setOp: function(stencilFail, stencilZFail, stencilZPass) {
					(currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) && (gl.stencilOp(stencilFail, stencilZFail, stencilZPass), currentStencilFail = stencilFail, currentStencilZFail = stencilZFail, currentStencilZPass = stencilZPass)
				},
				setLocked: function(lock) {
					locked = lock
				},
				setClear: function(stencil) {
					currentStencilClear !== stencil && (gl.clearStencil(stencil), currentStencilClear = stencil)
				},
				reset: function() {
					locked = !1, currentStencilMask = null, currentStencilFunc = null, currentStencilRef = null, currentStencilFuncMask = null, currentStencilFail = null, currentStencilZFail = null, currentStencilZPass = null, currentStencilClear = null
				}
			}
		},
		uboBindings = new WeakMap,
		uboProgramMap = new WeakMap,
		enabledCapabilities = {},
		currentBoundFramebuffers = {},
		currentDrawbuffers = new WeakMap,
		defaultDrawbuffers = [],
		currentProgram = null,
		currentBlendingEnabled = !1,
		currentBlending = null,
		currentBlendEquation = null,
		currentBlendSrc = null,
		currentBlendDst = null,
		currentBlendEquationAlpha = null,
		currentBlendSrcAlpha = null,
		currentBlendDstAlpha = null,
		currentBlendColor = new Color(0, 0, 0),
		currentBlendAlpha = 0,
		currentPremultipledAlpha = !1,
		currentFlipSided = null,
		currentCullFace = null,
		currentLineWidth = null,
		currentPolygonOffsetFactor = null,
		currentPolygonOffsetUnits = null,
		maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
		lineWidthAvailable = !1,
		glVersion = gl.getParameter(gl.VERSION); - 1 !== glVersion.indexOf("WebGL") ? lineWidthAvailable = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]) >= 1 : -1 !== glVersion.indexOf("OpenGL ES") && (lineWidthAvailable = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]) >= 2);
	let currentTextureSlot = null,
		currentBoundTextures = {},
		scissorParam = gl.getParameter(gl.SCISSOR_BOX),
		viewportParam = gl.getParameter(gl.VIEWPORT),
		currentScissor = new Vector4().fromArray(scissorParam),
		currentViewport = new Vector4().fromArray(viewportParam);

	function createTexture(type, target, count, dimensions) {
		let data = new Uint8Array(4),
			texture = gl.createTexture();
		gl.bindTexture(type, texture), gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST), gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		for (let i = 0; i < count; i++) isWebGL2 && (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) ? gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data) : gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
		return texture
	}
	let emptyTextures = {};

	function enable(id) {
		!0 !== enabledCapabilities[id] && (gl.enable(id), enabledCapabilities[id] = !0)
	}

	function disable(id) {
		!1 !== enabledCapabilities[id] && (gl.disable(id), enabledCapabilities[id] = !1)
	}
	emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1), emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6), isWebGL2 && (emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1), emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1)), colorBuffer.setClear(0, 0, 0, 1), depthBuffer.setClear(1), stencilBuffer.setClear(0), enable(gl.DEPTH_TEST), depthBuffer.setFunc(3), setFlipSided(!1), setCullFace(1), enable(gl.CULL_FACE), setBlending(0);
	let equationToGL = {
		100: gl.FUNC_ADD,
		101: gl.FUNC_SUBTRACT,
		102: gl.FUNC_REVERSE_SUBTRACT
	};
	if (isWebGL2) equationToGL[103] = gl.MIN, equationToGL[104] = gl.MAX;
	else {
		let extension = extensions.get("EXT_blend_minmax");
		null !== extension && (equationToGL[103] = extension.MIN_EXT, equationToGL[104] = extension.MAX_EXT)
	}
	let factorToGL = {
		200: gl.ZERO,
		201: gl.ONE,
		202: gl.SRC_COLOR,
		204: gl.SRC_ALPHA,
		210: gl.SRC_ALPHA_SATURATE,
		208: gl.DST_COLOR,
		206: gl.DST_ALPHA,
		203: gl.ONE_MINUS_SRC_COLOR,
		205: gl.ONE_MINUS_SRC_ALPHA,
		209: gl.ONE_MINUS_DST_COLOR,
		207: gl.ONE_MINUS_DST_ALPHA,
		211: gl.CONSTANT_COLOR,
		212: gl.ONE_MINUS_CONSTANT_COLOR,
		213: gl.CONSTANT_ALPHA,
		214: gl.ONE_MINUS_CONSTANT_ALPHA
	};

	function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
		if (0 === blending) {
			!0 === currentBlendingEnabled && (disable(gl.BLEND), currentBlendingEnabled = !1);
			return
		}
		if (!1 === currentBlendingEnabled && (enable(gl.BLEND), currentBlendingEnabled = !0), 5 !== blending) {
			if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
				if ((100 !== currentBlendEquation || 100 !== currentBlendEquationAlpha) && (gl.blendEquation(gl.FUNC_ADD), currentBlendEquation = 100, currentBlendEquationAlpha = 100), premultipliedAlpha) switch (blending) {
					case 1:
						gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
						break;
					case 2:
						gl.blendFunc(gl.ONE, gl.ONE);
						break;
					case 3:
						gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
						break;
					case 4:
						gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
						break;
					default:
						console.error("THREE.WebGLState: Invalid blending: ", blending)
				} else switch (blending) {
					case 1:
						gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
						break;
					case 2:
						gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
						break;
					case 3:
						gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
						break;
					case 4:
						gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
						break;
					default:
						console.error("THREE.WebGLState: Invalid blending: ", blending)
				}
				currentBlendSrc = null, currentBlendDst = null, currentBlendSrcAlpha = null, currentBlendDstAlpha = null, currentBlendColor.set(0, 0, 0), currentBlendAlpha = 0, currentBlending = blending, currentPremultipledAlpha = premultipliedAlpha
			}
			return
		}
		blendEquationAlpha = blendEquationAlpha || blendEquation, blendSrcAlpha = blendSrcAlpha || blendSrc, blendDstAlpha = blendDstAlpha || blendDst, (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) && (gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]), currentBlendEquation = blendEquation, currentBlendEquationAlpha = blendEquationAlpha), (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) && (gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]), currentBlendSrc = blendSrc, currentBlendDst = blendDst, currentBlendSrcAlpha = blendSrcAlpha, currentBlendDstAlpha = blendDstAlpha), (!1 === blendColor.equals(currentBlendColor) || blendAlpha !== currentBlendAlpha) && (gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha), currentBlendColor.copy(blendColor), currentBlendAlpha = blendAlpha), currentBlending = blending, currentPremultipledAlpha = !1
	}

	function setFlipSided(flipSided) {
		currentFlipSided !== flipSided && (flipSided ? gl.frontFace(gl.CW) : gl.frontFace(gl.CCW), currentFlipSided = flipSided)
	}

	function setCullFace(cullFace) {
		0 !== cullFace ? (enable(gl.CULL_FACE), cullFace !== currentCullFace && (1 === cullFace ? gl.cullFace(gl.BACK) : 2 === cullFace ? gl.cullFace(gl.FRONT) : gl.cullFace(gl.FRONT_AND_BACK))) : disable(gl.CULL_FACE), currentCullFace = cullFace
	}

	function setPolygonOffset(polygonOffset, factor, units) {
		polygonOffset ? (enable(gl.POLYGON_OFFSET_FILL), (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) && (gl.polygonOffset(factor, units), currentPolygonOffsetFactor = factor, currentPolygonOffsetUnits = units)) : disable(gl.POLYGON_OFFSET_FILL)
	}
	return {
		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},
		enable: enable,
		disable: disable,
		bindFramebuffer: function(target, framebuffer) {
			return currentBoundFramebuffers[target] !== framebuffer && (gl.bindFramebuffer(target, framebuffer), currentBoundFramebuffers[target] = framebuffer, isWebGL2 && (target === gl.DRAW_FRAMEBUFFER && (currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer), target === gl.FRAMEBUFFER && (currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer)), !0)
		},
		drawBuffers: function(renderTarget, framebuffer) {
			let drawBuffers = defaultDrawbuffers,
				needsUpdate = !1;
			if (renderTarget) {
				if (void 0 === (drawBuffers = currentDrawbuffers.get(framebuffer)) && (drawBuffers = [], currentDrawbuffers.set(framebuffer, drawBuffers)), renderTarget.isWebGLMultipleRenderTargets) {
					let textures = renderTarget.texture;
					if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
						for (let i = 0, il = textures.length; i < il; i++) drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
						drawBuffers.length = textures.length, needsUpdate = !0
					}
				} else drawBuffers[0] !== gl.COLOR_ATTACHMENT0 && (drawBuffers[0] = gl.COLOR_ATTACHMENT0, needsUpdate = !0)
			} else drawBuffers[0] !== gl.BACK && (drawBuffers[0] = gl.BACK, needsUpdate = !0);
			needsUpdate && (capabilities.isWebGL2 ? gl.drawBuffers(drawBuffers) : extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers))
		},
		useProgram: function(program) {
			return currentProgram !== program && (gl.useProgram(program), currentProgram = program, !0)
		},
		setBlending: setBlending,
		setMaterial: function(material, frontFaceCW) {
			2 === material.side ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
			let flipSided = 1 === material.side;
			frontFaceCW && (flipSided = !flipSided), setFlipSided(flipSided), 1 === material.blending && !1 === material.transparent ? setBlending(0) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha), depthBuffer.setFunc(material.depthFunc), depthBuffer.setTest(material.depthTest), depthBuffer.setMask(material.depthWrite), colorBuffer.setMask(material.colorWrite);
			let stencilWrite = material.stencilWrite;
			stencilBuffer.setTest(stencilWrite), stencilWrite && (stencilBuffer.setMask(material.stencilWriteMask), stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask), stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass)), setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits), !0 === material.alphaToCoverage ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE)
		},
		setFlipSided: setFlipSided,
		setCullFace: setCullFace,
		setLineWidth: function(width) {
			width !== currentLineWidth && (lineWidthAvailable && gl.lineWidth(width), currentLineWidth = width)
		},
		setPolygonOffset: setPolygonOffset,
		setScissorTest: function(scissorTest) {
			scissorTest ? enable(gl.SCISSOR_TEST) : disable(gl.SCISSOR_TEST)
		},
		activeTexture: function(webglSlot) {
			void 0 === webglSlot && (webglSlot = gl.TEXTURE0 + maxTextures - 1), currentTextureSlot !== webglSlot && (gl.activeTexture(webglSlot), currentTextureSlot = webglSlot)
		},
		bindTexture: function(webglType, webglTexture, webglSlot) {
			void 0 === webglSlot && (webglSlot = null === currentTextureSlot ? gl.TEXTURE0 + maxTextures - 1 : currentTextureSlot);
			let boundTexture = currentBoundTextures[webglSlot];
			void 0 === boundTexture && (boundTexture = {
				type: void 0,
				texture: void 0
			}, currentBoundTextures[webglSlot] = boundTexture), (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) && (currentTextureSlot !== webglSlot && (gl.activeTexture(webglSlot), currentTextureSlot = webglSlot), gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]), boundTexture.type = webglType, boundTexture.texture = webglTexture)
		},
		unbindTexture: function() {
			let boundTexture = currentBoundTextures[currentTextureSlot];
			void 0 !== boundTexture && void 0 !== boundTexture.type && (gl.bindTexture(boundTexture.type, null), boundTexture.type = void 0, boundTexture.texture = void 0)
		},
		compressedTexImage2D: function() {
			try {
				gl.compressedTexImage2D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		compressedTexImage3D: function() {
			try {
				gl.compressedTexImage3D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		texImage2D: function() {
			try {
				gl.texImage2D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		texImage3D: function() {
			try {
				gl.texImage3D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		updateUBOMapping: function(uniformsGroup, program) {
			let mapping = uboProgramMap.get(program);
			void 0 === mapping && (mapping = new WeakMap, uboProgramMap.set(program, mapping));
			let blockIndex = mapping.get(uniformsGroup);
			void 0 === blockIndex && (blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name), mapping.set(uniformsGroup, blockIndex))
		},
		uniformBlockBinding: function(uniformsGroup, program) {
			let blockIndex = uboProgramMap.get(program).get(uniformsGroup);
			uboBindings.get(program) !== blockIndex && (gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex), uboBindings.set(program, blockIndex))
		},
		texStorage2D: function() {
			try {
				gl.texStorage2D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		texStorage3D: function() {
			try {
				gl.texStorage3D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		texSubImage2D: function() {
			try {
				gl.texSubImage2D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		texSubImage3D: function() {
			try {
				gl.texSubImage3D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		compressedTexSubImage2D: function() {
			try {
				gl.compressedTexSubImage2D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		compressedTexSubImage3D: function() {
			try {
				gl.compressedTexSubImage3D.apply(gl, arguments)
			} catch (error) {
				console.error("THREE.WebGLState:", error)
			}
		},
		scissor: function(scissor) {
			!1 === currentScissor.equals(scissor) && (gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w), currentScissor.copy(scissor))
		},
		viewport: function(viewport) {
			!1 === currentViewport.equals(viewport) && (gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w), currentViewport.copy(viewport))
		},
		reset: function() {
			gl.disable(gl.BLEND), gl.disable(gl.CULL_FACE), gl.disable(gl.DEPTH_TEST), gl.disable(gl.POLYGON_OFFSET_FILL), gl.disable(gl.SCISSOR_TEST), gl.disable(gl.STENCIL_TEST), gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE), gl.blendEquation(gl.FUNC_ADD), gl.blendFunc(gl.ONE, gl.ZERO), gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO), gl.blendColor(0, 0, 0, 0), gl.colorMask(!0, !0, !0, !0), gl.clearColor(0, 0, 0, 0), gl.depthMask(!0), gl.depthFunc(gl.LESS), gl.clearDepth(1), gl.stencilMask(4294967295), gl.stencilFunc(gl.ALWAYS, 0, 4294967295), gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP), gl.clearStencil(0), gl.cullFace(gl.BACK), gl.frontFace(gl.CCW), gl.polygonOffset(0, 0), gl.activeTexture(gl.TEXTURE0), gl.bindFramebuffer(gl.FRAMEBUFFER, null), !0 === isWebGL2 && (gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null), gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null)), gl.useProgram(null), gl.lineWidth(1), gl.scissor(0, 0, gl.canvas.width, gl.canvas.height), gl.viewport(0, 0, gl.canvas.width, gl.canvas.height), enabledCapabilities = {}, currentTextureSlot = null, currentBoundTextures = {}, currentBoundFramebuffers = {}, currentDrawbuffers = new WeakMap, defaultDrawbuffers = [], currentProgram = null, currentBlendingEnabled = !1, currentBlending = null, currentBlendEquation = null, currentBlendSrc = null, currentBlendDst = null, currentBlendEquationAlpha = null, currentBlendSrcAlpha = null, currentBlendDstAlpha = null, currentBlendColor = new Color(0, 0, 0), currentBlendAlpha = 0, currentPremultipledAlpha = !1, currentFlipSided = null, currentCullFace = null, currentLineWidth = null, currentPolygonOffsetFactor = null, currentPolygonOffsetUnits = null, currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height), currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height), colorBuffer.reset(), depthBuffer.reset(), stencilBuffer.reset()
		}
	}
}

function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
	let _canvas;
	let isWebGL2 = capabilities.isWebGL2,
		multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null,
		supportsInvalidateFramebuffer = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
		_videoTextures = new WeakMap,
		_sources = new WeakMap,
		useOffscreenCanvas = !1;
	try {
		useOffscreenCanvas = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
	} catch (err) {}

	function createCanvas(width, height) {
		return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas")
	}

	function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
		let scale = 1;
		if ((image.width > maxSize || image.height > maxSize) && (scale = maxSize / Math.max(image.width, image.height)), scale < 1 || !0 === needsPowerOfTwo) {
			if ("undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap) {
				let floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor,
					width = floor(scale * image.width),
					height = floor(scale * image.height);
				void 0 === _canvas && (_canvas = createCanvas(width, height));
				let canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
				return canvas.width = width, canvas.height = height, canvas.getContext("2d").drawImage(image, 0, 0, width, height), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ")."), canvas
			}
			"data" in image && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").")
		}
		return image
	}

	function isPowerOfTwo$1(image) {
		return isPowerOfTwo(image.width) && isPowerOfTwo(image.height)
	}

	function textureNeedsGenerateMipmaps(texture, supportsMips) {
		return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && 1006 !== texture.minFilter
	}

	function generateMipmap(target) {
		_gl.generateMipmap(target)
	}

	function getInternalFormat(internalFormatName, glFormat, glType, colorSpace1, forceLinearTransfer = !1) {
		if (!1 === isWebGL2) return glFormat;
		if (null !== internalFormatName) {
			if (void 0 !== _gl[internalFormatName]) return _gl[internalFormatName];
			console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'")
		}
		let internalFormat = glFormat;
		if (glFormat === _gl.RED && (glType === _gl.FLOAT && (internalFormat = _gl.R32F), glType === _gl.HALF_FLOAT && (internalFormat = _gl.R16F), glType === _gl.UNSIGNED_BYTE && (internalFormat = _gl.R8)), glFormat === _gl.RED_INTEGER && (glType === _gl.UNSIGNED_BYTE && (internalFormat = _gl.R8UI), glType === _gl.UNSIGNED_SHORT && (internalFormat = _gl.R16UI), glType === _gl.UNSIGNED_INT && (internalFormat = _gl.R32UI), glType === _gl.BYTE && (internalFormat = _gl.R8I), glType === _gl.SHORT && (internalFormat = _gl.R16I), glType === _gl.INT && (internalFormat = _gl.R32I)), glFormat === _gl.RG && (glType === _gl.FLOAT && (internalFormat = _gl.RG32F), glType === _gl.HALF_FLOAT && (internalFormat = _gl.RG16F), glType === _gl.UNSIGNED_BYTE && (internalFormat = _gl.RG8)), glFormat === _gl.RGBA) {
			let transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace1);
			glType === _gl.FLOAT && (internalFormat = _gl.RGBA32F), glType === _gl.HALF_FLOAT && (internalFormat = _gl.RGBA16F), glType === _gl.UNSIGNED_BYTE && (internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8), glType === _gl.UNSIGNED_SHORT_4_4_4_4 && (internalFormat = _gl.RGBA4), glType === _gl.UNSIGNED_SHORT_5_5_5_1 && (internalFormat = _gl.RGB5_A1)
		}
		return (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) && extensions.get("EXT_color_buffer_float"), internalFormat
	}

	function getMipLevels(texture, image, supportsMips) {
		return !0 === textureNeedsGenerateMipmaps(texture, supportsMips) || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && 1006 !== texture.minFilter ? Math.log2(Math.max(image.width, image.height)) + 1 : void 0 !== texture.mipmaps && texture.mipmaps.length > 0 ? texture.mipmaps.length : texture.isCompressedTexture && Array.isArray(texture.image) ? image.mipmaps.length : 1
	}

	function filterFallback(f) {
		return f === NearestFilter || 1004 === f || 1005 === f ? _gl.NEAREST : _gl.LINEAR
	}

	function onTextureDispose(event) {
		let texture = event.target;
		texture.removeEventListener("dispose", onTextureDispose),
			function(texture) {
				let textureProperties = properties.get(texture);
				if (void 0 === textureProperties.__webglInit) return;
				let source = texture.source,
					webglTextures = _sources.get(source);
				if (webglTextures) {
					let webglTexture = webglTextures[textureProperties.__cacheKey];
					webglTexture.usedTimes--, 0 === webglTexture.usedTimes && deleteTexture(texture), 0 === Object.keys(webglTextures).length && _sources.delete(source)
				}
				properties.remove(texture)
			}(texture), texture.isVideoTexture && _videoTextures.delete(texture)
	}

	function onRenderTargetDispose(event) {
		let renderTarget = event.target;
		renderTarget.removeEventListener("dispose", onRenderTargetDispose),
			function(renderTarget) {
				let texture = renderTarget.texture,
					renderTargetProperties = properties.get(renderTarget),
					textureProperties = properties.get(texture);
				if (void 0 !== textureProperties.__webglTexture && (_gl.deleteTexture(textureProperties.__webglTexture), info.memory.textures--), renderTarget.depthTexture && renderTarget.depthTexture.dispose(), renderTarget.isWebGLCubeRenderTarget)
					for (let i = 0; i < 6; i++) {
						if (Array.isArray(renderTargetProperties.__webglFramebuffer[i]))
							for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
						else _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
						renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i])
					} else {
						if (Array.isArray(renderTargetProperties.__webglFramebuffer))
							for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
						else _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
						if (renderTargetProperties.__webglDepthbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer), renderTargetProperties.__webglMultisampledFramebuffer && _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer), renderTargetProperties.__webglColorRenderbuffer)
							for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) renderTargetProperties.__webglColorRenderbuffer[i] && _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
						renderTargetProperties.__webglDepthRenderbuffer && _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer)
					}
				if (renderTarget.isWebGLMultipleRenderTargets)
					for (let i = 0, il = texture.length; i < il; i++) {
						let attachmentProperties = properties.get(texture[i]);
						attachmentProperties.__webglTexture && (_gl.deleteTexture(attachmentProperties.__webglTexture), info.memory.textures--), properties.remove(texture[i])
					}
				properties.remove(texture), properties.remove(renderTarget)
			}(renderTarget)
	}

	function deleteTexture(texture) {
		let textureProperties = properties.get(texture);
		_gl.deleteTexture(textureProperties.__webglTexture);
		let source = texture.source,
			webglTextures = _sources.get(source);
		delete webglTextures[textureProperties.__cacheKey], info.memory.textures--
	}
	let textureUnits = 0;

	function setTexture2D(texture, slot) {
		let textureProperties = properties.get(texture);
		if (texture.isVideoTexture && function(texture) {
				let frame = info.render.frame;
				_videoTextures.get(texture) !== frame && (_videoTextures.set(texture, frame), texture.update())
			}(texture), !1 === texture.isRenderTargetTexture && texture.version > 0 && textureProperties.__version !== texture.version) {
			let image = texture.image;
			if (null === image) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
			else if (!1 === image.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
			else {
				uploadTexture(textureProperties, texture, slot);
				return
			}
		}
		state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot)
	}
	let wrappingToGL = {
			1e3: _gl.REPEAT,
			1001: _gl.CLAMP_TO_EDGE,
			1002: _gl.MIRRORED_REPEAT
		},
		filterToGL = {
			[NearestFilter]: _gl.NEAREST,
			1004: _gl.NEAREST_MIPMAP_NEAREST,
			1005: _gl.NEAREST_MIPMAP_LINEAR,
			1006: _gl.LINEAR,
			1007: _gl.LINEAR_MIPMAP_NEAREST,
			1008: _gl.LINEAR_MIPMAP_LINEAR
		},
		compareToGL = {
			512: _gl.NEVER,
			519: _gl.ALWAYS,
			513: _gl.LESS,
			515: _gl.LEQUAL,
			514: _gl.EQUAL,
			518: _gl.GEQUAL,
			516: _gl.GREATER,
			517: _gl.NOTEQUAL
		};

	function setTextureParameters(textureType, texture, supportsMips) {
		if (supportsMips ? (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]), _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]), (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) && _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]), _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]), _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter])) : (_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE), _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE), (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) && _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE), (1001 !== texture.wrapS || 1001 !== texture.wrapT) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter)), _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter)), texture.minFilter !== NearestFilter && 1006 !== texture.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), texture.compareFunction && (_gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE), _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction])), !0 === extensions.has("EXT_texture_filter_anisotropic")) {
			let extension = extensions.get("EXT_texture_filter_anisotropic");
			texture.magFilter !== NearestFilter && (1005 === texture.minFilter || 1008 === texture.minFilter) && (1015 !== texture.type || !1 !== extensions.has("OES_texture_float_linear")) && (!1 !== isWebGL2 || 1016 !== texture.type || !1 !== extensions.has("OES_texture_half_float_linear")) && (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) && (_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy())), properties.get(texture).__currentAnisotropy = texture.anisotropy)
		}
	}

	function initTexture(textureProperties, texture) {
		let forceUpload = !1;
		void 0 === textureProperties.__webglInit && (textureProperties.__webglInit = !0, texture.addEventListener("dispose", onTextureDispose));
		let source = texture.source,
			webglTextures = _sources.get(source);
		void 0 === webglTextures && (webglTextures = {}, _sources.set(source, webglTextures));
		let textureCacheKey = function(texture) {
			let array = [];
			return array.push(texture.wrapS), array.push(texture.wrapT), array.push(texture.wrapR || 0), array.push(texture.magFilter), array.push(texture.minFilter), array.push(texture.anisotropy), array.push(texture.internalFormat), array.push(texture.format), array.push(texture.type), array.push(texture.generateMipmaps), array.push(texture.premultiplyAlpha), array.push(texture.flipY), array.push(texture.unpackAlignment), array.push(texture.colorSpace), array.join()
		}(texture);
		if (textureCacheKey !== textureProperties.__cacheKey) {
			void 0 === webglTextures[textureCacheKey] && (webglTextures[textureCacheKey] = {
				texture: _gl.createTexture(),
				usedTimes: 0
			}, info.memory.textures++, forceUpload = !0), webglTextures[textureCacheKey].usedTimes++;
			let webglTexture = webglTextures[textureProperties.__cacheKey];
			void 0 !== webglTexture && (webglTextures[textureProperties.__cacheKey].usedTimes--, 0 === webglTexture.usedTimes && deleteTexture(texture)), textureProperties.__cacheKey = textureCacheKey, textureProperties.__webglTexture = webglTextures[textureCacheKey].texture
		}
		return forceUpload
	}

	function uploadTexture(textureProperties, texture, slot) {
		let textureType = _gl.TEXTURE_2D;
		(texture.isDataArrayTexture || texture.isCompressedArrayTexture) && (textureType = _gl.TEXTURE_2D_ARRAY), texture.isData3DTexture && (textureType = _gl.TEXTURE_3D);
		let forceUpload = initTexture(textureProperties, texture),
			source = texture.source;
		state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
		let sourceProperties = properties.get(source);
		if (source.version !== sourceProperties.__version || !0 === forceUpload) {
			let mipmap;
			state.activeTexture(_gl.TEXTURE0 + slot);
			let workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
				texturePrimaries = "" === texture.colorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace),
				unpackConversion = "" === texture.colorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha), _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment), _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
			let needsPowerOfTwo = !isWebGL2 && (1001 !== texture.wrapS || 1001 !== texture.wrapT || texture.minFilter !== NearestFilter && 1006 !== texture.minFilter) && !1 === isPowerOfTwo$1(texture.image),
				image = resizeImage(texture.image, needsPowerOfTwo, !1, capabilities.maxTextureSize),
				supportsMips = isPowerOfTwo$1(image = verifyColorSpace(texture, image)) || isWebGL2,
				glFormat = utils.convert(texture.format, texture.colorSpace),
				glType = utils.convert(texture.type),
				glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
			setTextureParameters(textureType, texture, supportsMips);
			let mipmaps = texture.mipmaps,
				useTexStorage = isWebGL2 && !0 !== texture.isVideoTexture && 36196 !== glInternalFormat,
				allocateMemory = void 0 === sourceProperties.__version || !0 === forceUpload,
				levels = getMipLevels(texture, image, supportsMips);
			if (texture.isDepthTexture) glInternalFormat = _gl.DEPTH_COMPONENT, isWebGL2 ? glInternalFormat = 1015 === texture.type ? _gl.DEPTH_COMPONENT32F : 1014 === texture.type ? _gl.DEPTH_COMPONENT24 : 1020 === texture.type ? _gl.DEPTH24_STENCIL8 : _gl.DEPTH_COMPONENT16 : 1015 === texture.type && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), 1026 === texture.format && glInternalFormat === _gl.DEPTH_COMPONENT && 1012 !== texture.type && 1014 !== texture.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), texture.type = 1014, glType = utils.convert(texture.type)), 1027 === texture.format && glInternalFormat === _gl.DEPTH_COMPONENT && (glInternalFormat = _gl.DEPTH_STENCIL, 1020 !== texture.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), texture.type = 1020, glType = utils.convert(texture.type))), allocateMemory && (useTexStorage ? state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height) : state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null));
			else if (texture.isDataTexture) {
				if (mipmaps.length > 0 && supportsMips) {
					useTexStorage && allocateMemory && state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
					for (let i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i], useTexStorage ? state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data) : state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					texture.generateMipmaps = !1
				} else useTexStorage ? (allocateMemory && state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height), state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data)) : state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data)
			} else if (texture.isCompressedTexture) {
				if (texture.isCompressedArrayTexture) {
					useTexStorage && allocateMemory && state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
					for (let i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i], 1023 !== texture.format ? null !== glFormat ? useTexStorage ? state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0) : state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : useTexStorage ? state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data) : state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data)
				} else {
					useTexStorage && allocateMemory && state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
					for (let i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i], 1023 !== texture.format ? null !== glFormat ? useTexStorage ? state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data) : state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : useTexStorage ? state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data) : state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
				}
			} else if (texture.isDataArrayTexture) useTexStorage ? (allocateMemory && state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth), state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data)) : state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
			else if (texture.isData3DTexture) useTexStorage ? (allocateMemory && state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth), state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data)) : state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
			else if (texture.isFramebufferTexture) {
				if (allocateMemory) {
					if (useTexStorage) state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
					else {
						let width = image.width,
							height = image.height;
						for (let i = 0; i < levels; i++) state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null), width >>= 1, height >>= 1
					}
				}
			} else if (mipmaps.length > 0 && supportsMips) {
				useTexStorage && allocateMemory && state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
				for (let i = 0, il = mipmaps.length; i < il; i++) mipmap = mipmaps[i], useTexStorage ? state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap) : state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
				texture.generateMipmaps = !1
			} else useTexStorage ? (allocateMemory && state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height), state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image)) : state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
			textureNeedsGenerateMipmaps(texture, supportsMips) && generateMipmap(textureType), sourceProperties.__version = source.version, texture.onUpdate && texture.onUpdate(texture)
		}
		textureProperties.__version = texture.version
	}

	function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
		let glFormat = utils.convert(texture.format, texture.colorSpace),
			glType = utils.convert(texture.type),
			glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
		if (!properties.get(renderTarget).__hasExternalTextures) {
			let width = Math.max(1, renderTarget.width >> level),
				height = Math.max(1, renderTarget.height >> level);
			textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ? state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null) : state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null)
		}
		state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), useMultisampledRTT(renderTarget) ? multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget)) : (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) && _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level), state.bindFramebuffer(_gl.FRAMEBUFFER, null)
	}

	function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
		if (_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer), renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
			let glInternalFormat = !0 === isWebGL2 ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT16;
			if (isMultisample || useMultisampledRTT(renderTarget)) {
				let depthTexture = renderTarget.depthTexture;
				depthTexture && depthTexture.isDepthTexture && (1015 === depthTexture.type ? glInternalFormat = _gl.DEPTH_COMPONENT32F : 1014 === depthTexture.type && (glInternalFormat = _gl.DEPTH_COMPONENT24));
				let samples = getRenderTargetSamples(renderTarget);
				useMultisampledRTT(renderTarget) ? multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height) : _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height)
			} else _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
			_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)
		} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
			let samples = getRenderTargetSamples(renderTarget);
			isMultisample && !1 === useMultisampledRTT(renderTarget) ? _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height) : useMultisampledRTT(renderTarget) ? multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height) : _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height), _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer)
		} else {
			let textures = !0 === renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
			for (let i = 0; i < textures.length; i++) {
				let texture = textures[i],
					glFormat = utils.convert(texture.format, texture.colorSpace),
					glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace),
					samples = getRenderTargetSamples(renderTarget);
				isMultisample && !1 === useMultisampledRTT(renderTarget) ? _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height) : useMultisampledRTT(renderTarget) ? multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height) : _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height)
			}
		}
		_gl.bindRenderbuffer(_gl.RENDERBUFFER, null)
	}

	function setupDepthRenderbuffer(renderTarget) {
		let renderTargetProperties = properties.get(renderTarget),
			isCube = !0 === renderTarget.isWebGLCubeRenderTarget;
		if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
			if (isCube) throw Error("target.depthTexture not supported in Cube render targets");
			! function(framebuffer, renderTarget) {
				if (renderTarget && renderTarget.isWebGLCubeRenderTarget) throw Error("Depth Texture with cube render targets is not supported");
				if (state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer), !(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
				properties.get(renderTarget.depthTexture).__webglTexture && renderTarget.depthTexture.image.width === renderTarget.width && renderTarget.depthTexture.image.height === renderTarget.height || (renderTarget.depthTexture.image.width = renderTarget.width, renderTarget.depthTexture.image.height = renderTarget.height, renderTarget.depthTexture.needsUpdate = !0), setTexture2D(renderTarget.depthTexture, 0);
				let webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture,
					samples = getRenderTargetSamples(renderTarget);
				if (1026 === renderTarget.depthTexture.format) useMultisampledRTT(renderTarget) ? multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples) : _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
				else if (1027 === renderTarget.depthTexture.format) useMultisampledRTT(renderTarget) ? multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples) : _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
				else throw Error("Unknown depthTexture format")
			}(renderTargetProperties.__webglFramebuffer, renderTarget)
		} else if (isCube) {
			renderTargetProperties.__webglDepthbuffer = [];
			for (let i = 0; i < 6; i++) state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]), renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, !1)
		} else state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer), renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, !1);
		state.bindFramebuffer(_gl.FRAMEBUFFER, null)
	}

	function getRenderTargetSamples(renderTarget) {
		return Math.min(capabilities.maxSamples, renderTarget.samples)
	}

	function useMultisampledRTT(renderTarget) {
		let renderTargetProperties = properties.get(renderTarget);
		return isWebGL2 && renderTarget.samples > 0 && !0 === extensions.has("WEBGL_multisampled_render_to_texture") && !1 !== renderTargetProperties.__useRenderToTexture
	}

	function verifyColorSpace(texture, image) {
		let colorSpace1 = texture.colorSpace,
			format = texture.format,
			type = texture.type;
		return !0 === texture.isCompressedTexture || !0 === texture.isVideoTexture || 1035 === texture.format || colorSpace1 !== LinearSRGBColorSpace && "" !== colorSpace1 && (ColorManagement.getTransfer(colorSpace1) === SRGBTransfer ? !1 === isWebGL2 ? !0 === extensions.has("EXT_sRGB") && 1023 === format ? (texture.format = 1035, texture.minFilter = 1006, texture.generateMipmaps = !1) : image = ImageUtils.sRGBToLinear(image) : (1023 !== format || 1009 !== type) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace1)), image
	}
	this.allocateTextureUnit = function() {
		let textureUnit = textureUnits;
		return textureUnit >= capabilities.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures), textureUnits += 1, textureUnit
	}, this.resetTextureUnits = function() {
		textureUnits = 0
	}, this.setTexture2D = setTexture2D, this.setTexture2DArray = function(texture, slot) {
		let textureProperties = properties.get(texture);
		if (texture.version > 0 && textureProperties.__version !== texture.version) {
			uploadTexture(textureProperties, texture, slot);
			return
		}
		state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot)
	}, this.setTexture3D = function(texture, slot) {
		let textureProperties = properties.get(texture);
		if (texture.version > 0 && textureProperties.__version !== texture.version) {
			uploadTexture(textureProperties, texture, slot);
			return
		}
		state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot)
	}, this.setTextureCube = function(texture, slot) {
		let textureProperties = properties.get(texture);
		if (texture.version > 0 && textureProperties.__version !== texture.version) {
			(function(textureProperties, texture, slot) {
				if (6 !== texture.image.length) return;
				let forceUpload = initTexture(textureProperties, texture),
					source = texture.source;
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
				let sourceProperties = properties.get(source);
				if (source.version !== sourceProperties.__version || !0 === forceUpload) {
					let mipmaps;
					state.activeTexture(_gl.TEXTURE0 + slot);
					let workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace),
						texturePrimaries = "" === texture.colorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace),
						unpackConversion = "" === texture.colorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
					_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha), _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment), _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
					let isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture,
						isDataTexture = texture.image[0] && texture.image[0].isDataTexture,
						cubeImage = [];
					for (let i = 0; i < 6; i++) isCompressed || isDataTexture ? cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i] : cubeImage[i] = resizeImage(texture.image[i], !1, !0, capabilities.maxCubemapSize), cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
					let image = cubeImage[0],
						supportsMips = isPowerOfTwo$1(image) || isWebGL2,
						glFormat = utils.convert(texture.format, texture.colorSpace),
						glType = utils.convert(texture.type),
						glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace),
						useTexStorage = isWebGL2 && !0 !== texture.isVideoTexture,
						allocateMemory = void 0 === sourceProperties.__version || !0 === forceUpload,
						levels = getMipLevels(texture, image, supportsMips);
					if (setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips), isCompressed) {
						useTexStorage && allocateMemory && state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
						for (let i = 0; i < 6; i++) {
							mipmaps = cubeImage[i].mipmaps;
							for (let j = 0; j < mipmaps.length; j++) {
								let mipmap = mipmaps[j];
								1023 !== texture.format ? null !== glFormat ? useTexStorage ? state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data) : state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : useTexStorage ? state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
							}
						}
					} else {
						mipmaps = texture.mipmaps, useTexStorage && allocateMemory && (mipmaps.length > 0 && levels++, state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height));
						for (let i = 0; i < 6; i++)
							if (isDataTexture) {
								useTexStorage ? state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
								for (let j = 0; j < mipmaps.length; j++) {
									let mipmapImage = mipmaps[j].image[i].image;
									useTexStorage ? state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data)
								}
							} else {
								useTexStorage ? state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
								for (let j = 0; j < mipmaps.length; j++) {
									let mipmap = mipmaps[j];
									useTexStorage ? state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]) : state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i])
								}
							}
					}
					textureNeedsGenerateMipmaps(texture, supportsMips) && generateMipmap(_gl.TEXTURE_CUBE_MAP), sourceProperties.__version = source.version, texture.onUpdate && texture.onUpdate(texture)
				}
				textureProperties.__version = texture.version
			})(textureProperties, texture, slot);
			return
		}
		state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot)
	}, this.rebindTextures = function(renderTarget, colorTexture, depthTexture) {
		let renderTargetProperties = properties.get(renderTarget);
		void 0 !== colorTexture && setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0), void 0 !== depthTexture && setupDepthRenderbuffer(renderTarget)
	}, this.setupRenderTarget = function(renderTarget) {
		let texture = renderTarget.texture,
			renderTargetProperties = properties.get(renderTarget),
			textureProperties = properties.get(texture);
		renderTarget.addEventListener("dispose", onRenderTargetDispose), !0 !== renderTarget.isWebGLMultipleRenderTargets && (void 0 === textureProperties.__webglTexture && (textureProperties.__webglTexture = _gl.createTexture()), textureProperties.__version = texture.version, info.memory.textures++);
		let isCube = !0 === renderTarget.isWebGLCubeRenderTarget,
			isMultipleRenderTargets = !0 === renderTarget.isWebGLMultipleRenderTargets,
			supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
		if (isCube) {
			renderTargetProperties.__webglFramebuffer = [];
			for (let i = 0; i < 6; i++)
				if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
					renderTargetProperties.__webglFramebuffer[i] = [];
					for (let level = 0; level < texture.mipmaps.length; level++) renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer()
				} else renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer()
		} else {
			if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
				renderTargetProperties.__webglFramebuffer = [];
				for (let level = 0; level < texture.mipmaps.length; level++) renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer()
			} else renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
			if (isMultipleRenderTargets) {
				if (capabilities.drawBuffers) {
					let textures = renderTarget.texture;
					for (let i = 0, il = textures.length; i < il; i++) {
						let attachmentProperties = properties.get(textures[i]);
						void 0 === attachmentProperties.__webglTexture && (attachmentProperties.__webglTexture = _gl.createTexture(), info.memory.textures++)
					}
				} else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.")
			}
			if (isWebGL2 && renderTarget.samples > 0 && !1 === useMultisampledRTT(renderTarget)) {
				let textures = isMultipleRenderTargets ? texture : [texture];
				renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer(), renderTargetProperties.__webglColorRenderbuffer = [], state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				for (let i = 0; i < textures.length; i++) {
					let texture = textures[i];
					renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer(), _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					let glFormat = utils.convert(texture.format, texture.colorSpace),
						glType = utils.convert(texture.type),
						glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, !0 === renderTarget.isXRRenderTarget),
						samples = getRenderTargetSamples(renderTarget);
					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height), _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i])
				}
				_gl.bindRenderbuffer(_gl.RENDERBUFFER, null), renderTarget.depthBuffer && (renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer(), setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, !0)), state.bindFramebuffer(_gl.FRAMEBUFFER, null)
			}
		}
		if (isCube) {
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			for (let i = 0; i < 6; i++)
				if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0)
					for (let level = 0; level < texture.mipmaps.length; level++) setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);
				else setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
			textureNeedsGenerateMipmaps(texture, supportsMips) && generateMipmap(_gl.TEXTURE_CUBE_MAP), state.unbindTexture()
		} else if (isMultipleRenderTargets) {
			let textures = renderTarget.texture;
			for (let i = 0, il = textures.length; i < il; i++) {
				let attachment = textures[i],
					attachmentProperties = properties.get(attachment);
				state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture), setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips), setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0), textureNeedsGenerateMipmaps(attachment, supportsMips) && generateMipmap(_gl.TEXTURE_2D)
			}
			state.unbindTexture()
		} else {
			let glTextureType = _gl.TEXTURE_2D;
			if ((renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) && (isWebGL2 ? glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), state.bindTexture(glTextureType, textureProperties.__webglTexture), setTextureParameters(glTextureType, texture, supportsMips), isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0)
				for (let level = 0; level < texture.mipmaps.length; level++) setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
			else setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
			textureNeedsGenerateMipmaps(texture, supportsMips) && generateMipmap(glTextureType), state.unbindTexture()
		}
		renderTarget.depthBuffer && setupDepthRenderbuffer(renderTarget)
	}, this.updateRenderTargetMipmap = function(renderTarget) {
		let supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2,
			textures = !0 === renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
		for (let i = 0, il = textures.length; i < il; i++) {
			let texture = textures[i];
			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				let target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D,
					webglTexture = properties.get(texture).__webglTexture;
				state.bindTexture(target, webglTexture), generateMipmap(target), state.unbindTexture()
			}
		}
	}, this.updateMultisampleRenderTarget = function(renderTarget) {
		if (isWebGL2 && renderTarget.samples > 0 && !1 === useMultisampledRTT(renderTarget)) {
			let textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture],
				width = renderTarget.width,
				height = renderTarget.height,
				mask = _gl.COLOR_BUFFER_BIT,
				invalidationArray = [],
				depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT,
				renderTargetProperties = properties.get(renderTarget),
				isMultipleRenderTargets = !0 === renderTarget.isWebGLMultipleRenderTargets;
			if (isMultipleRenderTargets)
				for (let i = 0; i < textures.length; i++) state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer), _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null), state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer), _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
			state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer), state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
			for (let i = 0; i < textures.length; i++) {
				invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i), renderTarget.depthBuffer && invalidationArray.push(depthStyle);
				let ignoreDepthValues = void 0 !== renderTargetProperties.__ignoreDepthValues && renderTargetProperties.__ignoreDepthValues;
				if (!1 === ignoreDepthValues && (renderTarget.depthBuffer && (mask |= _gl.DEPTH_BUFFER_BIT), renderTarget.stencilBuffer && (mask |= _gl.STENCIL_BUFFER_BIT)), isMultipleRenderTargets && _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]), !0 === ignoreDepthValues && (_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]), _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle])), isMultipleRenderTargets) {
					let webglTexture = properties.get(textures[i]).__webglTexture;
					_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0)
				}
				_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST), supportsInvalidateFramebuffer && _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray)
			}
			if (state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null), state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null), isMultipleRenderTargets)
				for (let i = 0; i < textures.length; i++) {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer), _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
					let webglTexture = properties.get(textures[i]).__webglTexture;
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer), _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0)
				}
			state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer)
		}
	}, this.setupDepthRenderbuffer = setupDepthRenderbuffer, this.setupFrameBufferTexture = setupFrameBufferTexture, this.useMultisampledRTT = useMultisampledRTT
}

function WebGLUtils(gl, extensions, capabilities) {
	let isWebGL2 = capabilities.isWebGL2;
	return {
		convert: function(p, colorSpace1 = "") {
			let extension;
			let transfer = ColorManagement.getTransfer(colorSpace1);
			if (1009 === p) return gl.UNSIGNED_BYTE;
			if (1017 === p) return gl.UNSIGNED_SHORT_4_4_4_4;
			if (1018 === p) return gl.UNSIGNED_SHORT_5_5_5_1;
			if (1010 === p) return gl.BYTE;
			if (1011 === p) return gl.SHORT;
			if (1012 === p) return gl.UNSIGNED_SHORT;
			if (1013 === p) return gl.INT;
			if (1014 === p) return gl.UNSIGNED_INT;
			if (1015 === p) return gl.FLOAT;
			if (1016 === p) return isWebGL2 ? gl.HALF_FLOAT : null !== (extension = extensions.get("OES_texture_half_float")) ? extension.HALF_FLOAT_OES : null;
			if (1021 === p) return gl.ALPHA;
			if (1023 === p) return gl.RGBA;
			if (1024 === p) return gl.LUMINANCE;
			if (1025 === p) return gl.LUMINANCE_ALPHA;
			if (1026 === p) return gl.DEPTH_COMPONENT;
			if (1027 === p) return gl.DEPTH_STENCIL;
			if (1035 === p) return null !== (extension = extensions.get("EXT_sRGB")) ? extension.SRGB_ALPHA_EXT : null;
			if (1028 === p) return gl.RED;
			if (1029 === p) return gl.RED_INTEGER;
			if (1030 === p) return gl.RG;
			if (1031 === p) return gl.RG_INTEGER;
			if (1033 === p) return gl.RGBA_INTEGER;
			if (33776 === p || 33777 === p || 33778 === p || 33779 === p) {
				if (transfer === SRGBTransfer) {
					if (null === (extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb"))) return null;
					if (33776 === p) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
					if (33777 === p) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
					if (33778 === p) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
					if (33779 === p) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
				} else {
					if (null === (extension = extensions.get("WEBGL_compressed_texture_s3tc"))) return null;
					if (33776 === p) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (33777 === p) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (33778 === p) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (33779 === p) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT
				}
			}
			if (35840 === p || 35841 === p || 35842 === p || 35843 === p) {
				if (null === (extension = extensions.get("WEBGL_compressed_texture_pvrtc"))) return null;
				if (35840 === p) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if (35841 === p) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if (35842 === p) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if (35843 === p) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
			}
			if (36196 === p) return null !== (extension = extensions.get("WEBGL_compressed_texture_etc1")) ? extension.COMPRESSED_RGB_ETC1_WEBGL : null;
			if (37492 === p || 37496 === p) {
				if (null === (extension = extensions.get("WEBGL_compressed_texture_etc"))) return null;
				if (37492 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
				if (37496 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC
			}
			if (37808 === p || 37809 === p || 37810 === p || 37811 === p || 37812 === p || 37813 === p || 37814 === p || 37815 === p || 37816 === p || 37817 === p || 37818 === p || 37819 === p || 37820 === p || 37821 === p) {
				if (null === (extension = extensions.get("WEBGL_compressed_texture_astc"))) return null;
				if (37808 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
				if (37809 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
				if (37810 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
				if (37811 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
				if (37812 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
				if (37813 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
				if (37814 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
				if (37815 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
				if (37816 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
				if (37817 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
				if (37818 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
				if (37819 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
				if (37820 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
				if (37821 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR
			}
			if (36492 === p || 36494 === p || 36495 === p) {
				if (null === (extension = extensions.get("EXT_texture_compression_bptc"))) return null;
				if (36492 === p) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
				if (36494 === p) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
				if (36495 === p) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
			}
			if (36283 === p || 36284 === p || 36285 === p || 36286 === p) {
				if (null === (extension = extensions.get("EXT_texture_compression_rgtc"))) return null;
				if (36492 === p) return extension.COMPRESSED_RED_RGTC1_EXT;
				if (36284 === p) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
				if (36285 === p) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
				if (36286 === p) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
			}
			return 1020 === p ? isWebGL2 ? gl.UNSIGNED_INT_24_8 : null !== (extension = extensions.get("WEBGL_depth_texture")) ? extension.UNSIGNED_INT_24_8_WEBGL : null : void 0 !== gl[p] ? gl[p] : null
		}
	}
}
class ArrayCamera extends PerspectiveCamera {
	constructor(array = []) {
		super(), this.isArrayCamera = !0, this.cameras = array
	}
}
class Group extends Object3D {
	constructor() {
		super(), this.isGroup = !0, this.type = "Group"
	}
}
let _moveEvent = {
	type: "move"
};
class WebXRController {
	constructor() {
		this._targetRay = null, this._grip = null, this._hand = null
	}
	getHandSpace() {
		return null === this._hand && (this._hand = new Group, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
			pinching: !1
		}), this._hand
	}
	getTargetRaySpace() {
		return null === this._targetRay && (this._targetRay = new Group, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Vector3, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Vector3), this._targetRay
	}
	getGripSpace() {
		return null === this._grip && (this._grip = new Group, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Vector3, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Vector3), this._grip
	}
	dispatchEvent(event) {
		return null !== this._targetRay && this._targetRay.dispatchEvent(event), null !== this._grip && this._grip.dispatchEvent(event), null !== this._hand && this._hand.dispatchEvent(event), this
	}
	connect(inputSource) {
		if (inputSource && inputSource.hand) {
			let hand = this._hand;
			if (hand)
				for (let inputjoint of inputSource.hand.values()) this._getHandJoint(hand, inputjoint)
		}
		return this.dispatchEvent({
			type: "connected",
			data: inputSource
		}), this
	}
	disconnect(inputSource) {
		return this.dispatchEvent({
			type: "disconnected",
			data: inputSource
		}), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
	}
	update(inputSource, frame, referenceSpace) {
		let inputPose = null,
			gripPose = null,
			handPose = null,
			targetRay = this._targetRay,
			grip = this._grip,
			hand = this._hand;
		if (inputSource && "visible-blurred" !== frame.session.visibilityState) {
			if (hand && inputSource.hand) {
				for (let inputjoint of (handPose = !0, inputSource.hand.values())) {
					let jointPose = frame.getJointPose(inputjoint, referenceSpace),
						joint = this._getHandJoint(hand, inputjoint);
					null !== jointPose && (joint.matrix.fromArray(jointPose.transform.matrix), joint.matrix.decompose(joint.position, joint.rotation, joint.scale), joint.matrixWorldNeedsUpdate = !0, joint.jointRadius = jointPose.radius), joint.visible = null !== jointPose
				}
				let indexTip = hand.joints["index-finger-tip"],
					thumbTip = hand.joints["thumb-tip"],
					distance = indexTip.position.distanceTo(thumbTip.position);
				hand.inputState.pinching && distance > .025 ? (hand.inputState.pinching = !1, this.dispatchEvent({
					type: "pinchend",
					handedness: inputSource.handedness,
					target: this
				})) : !hand.inputState.pinching && distance <= .015 && (hand.inputState.pinching = !0, this.dispatchEvent({
					type: "pinchstart",
					handedness: inputSource.handedness,
					target: this
				}))
			} else null !== grip && inputSource.gripSpace && null !== (gripPose = frame.getPose(inputSource.gripSpace, referenceSpace)) && (grip.matrix.fromArray(gripPose.transform.matrix), grip.matrix.decompose(grip.position, grip.rotation, grip.scale), grip.matrixWorldNeedsUpdate = !0, gripPose.linearVelocity ? (grip.hasLinearVelocity = !0, grip.linearVelocity.copy(gripPose.linearVelocity)) : grip.hasLinearVelocity = !1, gripPose.angularVelocity ? (grip.hasAngularVelocity = !0, grip.angularVelocity.copy(gripPose.angularVelocity)) : grip.hasAngularVelocity = !1);
			null !== targetRay && (null === (inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace)) && null !== gripPose && (inputPose = gripPose), null !== inputPose && (targetRay.matrix.fromArray(inputPose.transform.matrix), targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale), targetRay.matrixWorldNeedsUpdate = !0, inputPose.linearVelocity ? (targetRay.hasLinearVelocity = !0, targetRay.linearVelocity.copy(inputPose.linearVelocity)) : targetRay.hasLinearVelocity = !1, inputPose.angularVelocity ? (targetRay.hasAngularVelocity = !0, targetRay.angularVelocity.copy(inputPose.angularVelocity)) : targetRay.hasAngularVelocity = !1, this.dispatchEvent(_moveEvent)))
		}
		return null !== targetRay && (targetRay.visible = null !== inputPose), null !== grip && (grip.visible = null !== gripPose), null !== hand && (hand.visible = null !== handPose), this
	}
	_getHandJoint(hand, inputjoint) {
		if (void 0 === hand.joints[inputjoint.jointName]) {
			let joint = new Group;
			joint.matrixAutoUpdate = !1, joint.visible = !1, hand.joints[inputjoint.jointName] = joint, hand.add(joint)
		}
		return hand.joints[inputjoint.jointName]
	}
}
class WebXRManager extends EventDispatcher {
	constructor(renderer, gl) {
		super();
		let scope = this,
			session = null,
			framebufferScaleFactor = 1,
			referenceSpace = null,
			referenceSpaceType = "local-floor",
			foveation = 1,
			customReferenceSpace = null,
			pose = null,
			glBinding = null,
			glProjLayer = null,
			glBaseLayer = null,
			xrFrame = null,
			attributes = gl.getContextAttributes(),
			initialRenderTarget = null,
			newRenderTarget = null,
			controllers = [],
			controllerInputSources = [],
			currentSize = new Vector2,
			currentPixelRatio = null,
			cameraL = new PerspectiveCamera;
		cameraL.layers.enable(1), cameraL.viewport = new Vector4;
		let cameraR = new PerspectiveCamera;
		cameraR.layers.enable(2), cameraR.viewport = new Vector4;
		let cameras = [cameraL, cameraR],
			cameraXR = new ArrayCamera;
		cameraXR.layers.enable(1), cameraXR.layers.enable(2);
		let _currentDepthNear = null,
			_currentDepthFar = null;

		function onSessionEvent(event) {
			let controllerIndex = controllerInputSources.indexOf(event.inputSource);
			if (-1 === controllerIndex) return;
			let controller = controllers[controllerIndex];
			void 0 !== controller && (controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace), controller.dispatchEvent({
				type: event.type,
				data: event.inputSource
			}))
		}

		function onSessionEnd() {
			session.removeEventListener("select", onSessionEvent), session.removeEventListener("selectstart", onSessionEvent), session.removeEventListener("selectend", onSessionEvent), session.removeEventListener("squeeze", onSessionEvent), session.removeEventListener("squeezestart", onSessionEvent), session.removeEventListener("squeezeend", onSessionEvent), session.removeEventListener("end", onSessionEnd), session.removeEventListener("inputsourceschange", onInputSourcesChange);
			for (let i = 0; i < controllers.length; i++) {
				let inputSource = controllerInputSources[i];
				null !== inputSource && (controllerInputSources[i] = null, controllers[i].disconnect(inputSource))
			}
			_currentDepthNear = null, _currentDepthFar = null, renderer.setRenderTarget(initialRenderTarget), glBaseLayer = null, glProjLayer = null, glBinding = null, session = null, newRenderTarget = null, animation.stop(), scope.isPresenting = !1, renderer.setPixelRatio(currentPixelRatio), renderer.setSize(currentSize.width, currentSize.height, !1), scope.dispatchEvent({
				type: "sessionend"
			})
		}

		function onInputSourcesChange(event) {
			for (let i = 0; i < event.removed.length; i++) {
				let inputSource = event.removed[i],
					index = controllerInputSources.indexOf(inputSource);
				index >= 0 && (controllerInputSources[index] = null, controllers[index].disconnect(inputSource))
			}
			for (let i = 0; i < event.added.length; i++) {
				let inputSource = event.added[i],
					controllerIndex = controllerInputSources.indexOf(inputSource);
				if (-1 === controllerIndex) {
					for (let i = 0; i < controllers.length; i++) {
						if (i >= controllerInputSources.length) {
							controllerInputSources.push(inputSource), controllerIndex = i;
							break
						}
						if (null === controllerInputSources[i]) {
							controllerInputSources[i] = inputSource, controllerIndex = i;
							break
						}
					}
					if (-1 === controllerIndex) break
				}
				let controller = controllers[controllerIndex];
				controller && controller.connect(inputSource)
			}
		}
		this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(index) {
			let controller = controllers[index];
			return void 0 === controller && (controller = new WebXRController, controllers[index] = controller), controller.getTargetRaySpace()
		}, this.getControllerGrip = function(index) {
			let controller = controllers[index];
			return void 0 === controller && (controller = new WebXRController, controllers[index] = controller), controller.getGripSpace()
		}, this.getHand = function(index) {
			let controller = controllers[index];
			return void 0 === controller && (controller = new WebXRController, controllers[index] = controller), controller.getHandSpace()
		}, this.setFramebufferScaleFactor = function(value) {
			framebufferScaleFactor = value, !0 === scope.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
		}, this.setReferenceSpaceType = function(value) {
			referenceSpaceType = value, !0 === scope.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
		}, this.getReferenceSpace = function() {
			return customReferenceSpace || referenceSpace
		}, this.setReferenceSpace = function(space) {
			customReferenceSpace = space
		}, this.getBaseLayer = function() {
			return null !== glProjLayer ? glProjLayer : glBaseLayer
		}, this.getBinding = function() {
			return glBinding
		}, this.getFrame = function() {
			return xrFrame
		}, this.getSession = function() {
			return session
		}, this.setSession = async function(value) {
			if (null !== (session = value)) {
				if (initialRenderTarget = renderer.getRenderTarget(), session.addEventListener("select", onSessionEvent), session.addEventListener("selectstart", onSessionEvent), session.addEventListener("selectend", onSessionEvent), session.addEventListener("squeeze", onSessionEvent), session.addEventListener("squeezestart", onSessionEvent), session.addEventListener("squeezeend", onSessionEvent), session.addEventListener("end", onSessionEnd), session.addEventListener("inputsourceschange", onInputSourcesChange), !0 !== attributes.xrCompatible && await gl.makeXRCompatible(), currentPixelRatio = renderer.getPixelRatio(), renderer.getSize(currentSize), void 0 === session.renderState.layers || !1 === renderer.capabilities.isWebGL2) {
					let layerInit = {
						antialias: void 0 !== session.renderState.layers || attributes.antialias,
						alpha: !0,
						depth: attributes.depth,
						stencil: attributes.stencil,
						framebufferScaleFactor: framebufferScaleFactor
					};
					glBaseLayer = new XRWebGLLayer(session, gl, layerInit), session.updateRenderState({
						baseLayer: glBaseLayer
					}), renderer.setPixelRatio(1), renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, !1), newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
						format: 1023,
						type: 1009,
						colorSpace: renderer.outputColorSpace,
						stencilBuffer: attributes.stencil
					})
				} else {
					let depthFormat = null,
						depthType = null,
						glDepthFormat = null;
					attributes.depth && (glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24, depthFormat = attributes.stencil ? 1027 : 1026, depthType = attributes.stencil ? 1020 : 1014);
					let projectionlayerInit = {
						colorFormat: gl.RGBA8,
						depthFormat: glDepthFormat,
						scaleFactor: framebufferScaleFactor
					};
					glProjLayer = (glBinding = new XRWebGLBinding(session, gl)).createProjectionLayer(projectionlayerInit), session.updateRenderState({
						layers: [glProjLayer]
					}), renderer.setPixelRatio(1), renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, !1), newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
						format: 1023,
						type: 1009,
						depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
						stencilBuffer: attributes.stencil,
						colorSpace: renderer.outputColorSpace,
						samples: attributes.antialias ? 4 : 0
					}), renderer.properties.get(newRenderTarget).__ignoreDepthValues = glProjLayer.ignoreDepthValues
				}
				newRenderTarget.isXRRenderTarget = !0, this.setFoveation(foveation), customReferenceSpace = null, referenceSpace = await session.requestReferenceSpace(referenceSpaceType), animation.setContext(session), animation.start(), scope.isPresenting = !0, scope.dispatchEvent({
					type: "sessionstart"
				})
			}
		}, this.getEnvironmentBlendMode = function() {
			if (null !== session) return session.environmentBlendMode
		};
		let cameraLPos = new Vector3,
			cameraRPos = new Vector3;

		function updateCamera(camera, parent) {
			null === parent ? camera.matrixWorld.copy(camera.matrix) : camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix), camera.matrixWorldInverse.copy(camera.matrixWorld).invert()
		}
		this.updateCamera = function(camera) {
			if (null === session) return;
			cameraXR.near = cameraR.near = cameraL.near = camera.near, cameraXR.far = cameraR.far = cameraL.far = camera.far, (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) && (session.updateRenderState({
				depthNear: cameraXR.near,
				depthFar: cameraXR.far
			}), _currentDepthNear = cameraXR.near, _currentDepthFar = cameraXR.far);
			let parent = camera.parent,
				cameras = cameraXR.cameras;
			updateCamera(cameraXR, parent);
			for (let i = 0; i < cameras.length; i++) updateCamera(cameras[i], parent);
			2 === cameras.length ? function(camera, cameraL, cameraR) {
				cameraLPos.setFromMatrixPosition(cameraL.matrixWorld), cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
				let ipd = cameraLPos.distanceTo(cameraRPos),
					projL = cameraL.projectionMatrix.elements,
					projR = cameraR.projectionMatrix.elements,
					near = projL[14] / (projL[10] - 1),
					far = projL[14] / (projL[10] + 1),
					topFov = (projL[9] + 1) / projL[5],
					bottomFov = (projL[9] - 1) / projL[5],
					leftFov = (projL[8] - 1) / projL[0],
					rightFov = (projR[8] + 1) / projR[0],
					zOffset = ipd / (-leftFov + rightFov),
					xOffset = -(zOffset * leftFov);
				cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale), camera.translateX(xOffset), camera.translateZ(zOffset), camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale), camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
				let near2 = near + zOffset,
					far2 = far + zOffset;
				camera.projectionMatrix.makePerspective(near * leftFov - xOffset, near * rightFov + (ipd - xOffset), topFov * far / far2 * near2, bottomFov * far / far2 * near2, near2, far2), camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert()
			}(cameraXR, cameraL, cameraR) : cameraXR.projectionMatrix.copy(cameraL.projectionMatrix), null === parent ? camera.matrix.copy(cameraXR.matrixWorld) : (camera.matrix.copy(parent.matrixWorld), camera.matrix.invert(), camera.matrix.multiply(cameraXR.matrixWorld)), camera.matrix.decompose(camera.position, camera.quaternion, camera.scale), camera.updateMatrixWorld(!0), camera.projectionMatrix.copy(cameraXR.projectionMatrix), camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse), camera.isPerspectiveCamera && (camera.fov = 2 * RAD2DEG * Math.atan(1 / camera.projectionMatrix.elements[5]), camera.zoom = 1)
		}, this.getCamera = function() {
			return cameraXR
		}, this.getFoveation = function() {
			if (null !== glProjLayer || null !== glBaseLayer) return foveation
		}, this.setFoveation = function(value) {
			foveation = value, null !== glProjLayer && (glProjLayer.fixedFoveation = value), null !== glBaseLayer && void 0 !== glBaseLayer.fixedFoveation && (glBaseLayer.fixedFoveation = value)
		};
		let onAnimationFrameCallback = null,
			animation = new WebGLAnimation;
		animation.setAnimationLoop(function(time, frame) {
			if (pose = frame.getViewerPose(customReferenceSpace || referenceSpace), xrFrame = frame, null !== pose) {
				let views = pose.views;
				null !== glBaseLayer && (renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer), renderer.setRenderTarget(newRenderTarget));
				let cameraXRNeedsUpdate = !1;
				views.length !== cameraXR.cameras.length && (cameraXR.cameras.length = 0, cameraXRNeedsUpdate = !0);
				for (let i = 0; i < views.length; i++) {
					let view = views[i],
						viewport = null;
					if (null !== glBaseLayer) viewport = glBaseLayer.getViewport(view);
					else {
						let glSubImage = glBinding.getViewSubImage(glProjLayer, view);
						viewport = glSubImage.viewport, 0 === i && (renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture), renderer.setRenderTarget(newRenderTarget))
					}
					let camera = cameras[i];
					void 0 === camera && ((camera = new PerspectiveCamera).layers.enable(i), camera.viewport = new Vector4, cameras[i] = camera), camera.matrix.fromArray(view.transform.matrix), camera.matrix.decompose(camera.position, camera.quaternion, camera.scale), camera.projectionMatrix.fromArray(view.projectionMatrix), camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert(), camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height), 0 === i && (cameraXR.matrix.copy(camera.matrix), cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale)), !0 === cameraXRNeedsUpdate && cameraXR.cameras.push(camera)
				}
			}
			for (let i = 0; i < controllers.length; i++) {
				let inputSource = controllerInputSources[i],
					controller = controllers[i];
				null !== inputSource && void 0 !== controller && controller.update(inputSource, frame, customReferenceSpace || referenceSpace)
			}
			onAnimationFrameCallback && onAnimationFrameCallback(time, frame), frame.detectedPlanes && scope.dispatchEvent({
				type: "planesdetected",
				data: frame
			}), xrFrame = null
		}), this.setAnimationLoop = function(callback) {
			onAnimationFrameCallback = callback
		}, this.dispose = function() {}
	}
}

function WebGLMaterials(renderer, properties) {
	function refreshTransformUniform(map, uniform) {
		!0 === map.matrixAutoUpdate && map.updateMatrix(), uniform.value.copy(map.matrix)
	}

	function refreshUniformsCommon(uniforms, material) {
		uniforms.opacity.value = material.opacity, material.color && uniforms.diffuse.value.copy(material.color), material.emissive && uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity), material.map && (uniforms.map.value = material.map, refreshTransformUniform(material.map, uniforms.mapTransform)), material.alphaMap && (uniforms.alphaMap.value = material.alphaMap, refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform)), material.bumpMap && (uniforms.bumpMap.value = material.bumpMap, refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform), uniforms.bumpScale.value = material.bumpScale, 1 === material.side && (uniforms.bumpScale.value *= -1)), material.normalMap && (uniforms.normalMap.value = material.normalMap, refreshTransformUniform(material.normalMap, uniforms.normalMapTransform), uniforms.normalScale.value.copy(material.normalScale), 1 === material.side && uniforms.normalScale.value.negate()), material.displacementMap && (uniforms.displacementMap.value = material.displacementMap, refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform), uniforms.displacementScale.value = material.displacementScale, uniforms.displacementBias.value = material.displacementBias), material.emissiveMap && (uniforms.emissiveMap.value = material.emissiveMap, refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform)), material.specularMap && (uniforms.specularMap.value = material.specularMap, refreshTransformUniform(material.specularMap, uniforms.specularMapTransform)), material.alphaTest > 0 && (uniforms.alphaTest.value = material.alphaTest);
		let envMap = properties.get(material).envMap;
		if (envMap && (uniforms.envMap.value = envMap, uniforms.flipEnvMap.value = envMap.isCubeTexture && !1 === envMap.isRenderTargetTexture ? -1 : 1, uniforms.reflectivity.value = material.reflectivity, uniforms.ior.value = material.ior, uniforms.refractionRatio.value = material.refractionRatio), material.lightMap) {
			uniforms.lightMap.value = material.lightMap;
			let scaleFactor = !0 === renderer._useLegacyLights ? Math.PI : 1;
			uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor, refreshTransformUniform(material.lightMap, uniforms.lightMapTransform)
		}
		material.aoMap && (uniforms.aoMap.value = material.aoMap, uniforms.aoMapIntensity.value = material.aoMapIntensity, refreshTransformUniform(material.aoMap, uniforms.aoMapTransform))
	}
	return {
		refreshFogUniforms: function(uniforms, fog) {
			fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer)), fog.isFog ? (uniforms.fogNear.value = fog.near, uniforms.fogFar.value = fog.far) : fog.isFogExp2 && (uniforms.fogDensity.value = fog.density)
		},
		refreshMaterialUniforms: function(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
			material.isMeshBasicMaterial ? refreshUniformsCommon(uniforms, material) : material.isMeshLambertMaterial ? refreshUniformsCommon(uniforms, material) : material.isMeshToonMaterial ? (refreshUniformsCommon(uniforms, material), material.gradientMap && (uniforms.gradientMap.value = material.gradientMap)) : material.isMeshPhongMaterial ? (refreshUniformsCommon(uniforms, material), uniforms.specular.value.copy(material.specular), uniforms.shininess.value = Math.max(material.shininess, 1e-4)) : material.isMeshStandardMaterial ? (refreshUniformsCommon(uniforms, material), uniforms.metalness.value = material.metalness, material.metalnessMap && (uniforms.metalnessMap.value = material.metalnessMap, refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform)), uniforms.roughness.value = material.roughness, material.roughnessMap && (uniforms.roughnessMap.value = material.roughnessMap, refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform)), properties.get(material).envMap && (uniforms.envMapIntensity.value = material.envMapIntensity), material.isMeshPhysicalMaterial && (uniforms.ior.value = material.ior, material.sheen > 0 && (uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen), uniforms.sheenRoughness.value = material.sheenRoughness, material.sheenColorMap && (uniforms.sheenColorMap.value = material.sheenColorMap, refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform)), material.sheenRoughnessMap && (uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap, refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform))), material.clearcoat > 0 && (uniforms.clearcoat.value = material.clearcoat, uniforms.clearcoatRoughness.value = material.clearcoatRoughness, material.clearcoatMap && (uniforms.clearcoatMap.value = material.clearcoatMap, refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform)), material.clearcoatRoughnessMap && (uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap, refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform)), material.clearcoatNormalMap && (uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap, refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform), uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale), 1 === material.side && uniforms.clearcoatNormalScale.value.negate())), material.iridescence > 0 && (uniforms.iridescence.value = material.iridescence, uniforms.iridescenceIOR.value = material.iridescenceIOR, uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0], uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1], material.iridescenceMap && (uniforms.iridescenceMap.value = material.iridescenceMap, refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform)), material.iridescenceThicknessMap && (uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap, refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform))), material.transmission > 0 && (uniforms.transmission.value = material.transmission, uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture, uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height), material.transmissionMap && (uniforms.transmissionMap.value = material.transmissionMap, refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform)), uniforms.thickness.value = material.thickness, material.thicknessMap && (uniforms.thicknessMap.value = material.thicknessMap, refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform)), uniforms.attenuationDistance.value = material.attenuationDistance, uniforms.attenuationColor.value.copy(material.attenuationColor)), material.anisotropy > 0 && (uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation)), material.anisotropyMap && (uniforms.anisotropyMap.value = material.anisotropyMap, refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform))), uniforms.specularIntensity.value = material.specularIntensity, uniforms.specularColor.value.copy(material.specularColor), material.specularColorMap && (uniforms.specularColorMap.value = material.specularColorMap, refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform)), material.specularIntensityMap && (uniforms.specularIntensityMap.value = material.specularIntensityMap, refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform)))) : material.isMeshMatcapMaterial ? (refreshUniformsCommon(uniforms, material), material.matcap && (uniforms.matcap.value = material.matcap)) : material.isMeshDepthMaterial ? refreshUniformsCommon(uniforms, material) : material.isMeshDistanceMaterial ? (refreshUniformsCommon(uniforms, material), function(uniforms, material) {
				let light = properties.get(material).light;
				uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld), uniforms.nearDistance.value = light.shadow.camera.near, uniforms.farDistance.value = light.shadow.camera.far
			}(uniforms, material)) : material.isMeshNormalMaterial ? refreshUniformsCommon(uniforms, material) : material.isLineBasicMaterial ? (uniforms.diffuse.value.copy(material.color), uniforms.opacity.value = material.opacity, material.map && (uniforms.map.value = material.map, refreshTransformUniform(material.map, uniforms.mapTransform)), material.isLineDashedMaterial && (uniforms.dashSize.value = material.dashSize, uniforms.totalSize.value = material.dashSize + material.gapSize, uniforms.scale.value = material.scale)) : material.isPointsMaterial ? (uniforms.diffuse.value.copy(material.color), uniforms.opacity.value = material.opacity, uniforms.size.value = material.size * pixelRatio, uniforms.scale.value = .5 * height, material.map && (uniforms.map.value = material.map, refreshTransformUniform(material.map, uniforms.uvTransform)), material.alphaMap && (uniforms.alphaMap.value = material.alphaMap, refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform)), material.alphaTest > 0 && (uniforms.alphaTest.value = material.alphaTest)) : material.isSpriteMaterial ? (uniforms.diffuse.value.copy(material.color), uniforms.opacity.value = material.opacity, uniforms.rotation.value = material.rotation, material.map && (uniforms.map.value = material.map, refreshTransformUniform(material.map, uniforms.mapTransform)), material.alphaMap && (uniforms.alphaMap.value = material.alphaMap, refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform)), material.alphaTest > 0 && (uniforms.alphaTest.value = material.alphaTest)) : material.isShadowMaterial ? (uniforms.color.value.copy(material.color), uniforms.opacity.value = material.opacity) : material.isShaderMaterial && (material.uniformsNeedUpdate = !1)
		}
	}
}

function WebGLUniformsGroups(gl, info, capabilities, state) {
	let buffers = {},
		updateList = {},
		allocatedBindingPoints = [],
		maxBindingPoints = capabilities.isWebGL2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

	function getUniformSize(value) {
		let info = {
			boundary: 0,
			storage: 0
		};
		return "number" == typeof value || "boolean" == typeof value ? (info.boundary = 4, info.storage = 4) : value.isVector2 ? (info.boundary = 8, info.storage = 8) : value.isVector3 || value.isColor ? (info.boundary = 16, info.storage = 12) : value.isVector4 ? (info.boundary = 16, info.storage = 16) : value.isMatrix3 ? (info.boundary = 48, info.storage = 48) : value.isMatrix4 ? (info.boundary = 64, info.storage = 64) : value.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value), info
	}

	function onUniformsGroupsDispose(event) {
		let uniformsGroup = event.target;
		uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
		let index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
		allocatedBindingPoints.splice(index, 1), gl.deleteBuffer(buffers[uniformsGroup.id]), delete buffers[uniformsGroup.id], delete updateList[uniformsGroup.id]
	}
	return {
		bind: function(uniformsGroup, program) {
			let webglProgram = program.program;
			state.uniformBlockBinding(uniformsGroup, webglProgram)
		},
		update: function(uniformsGroup, program) {
			let buffer = buffers[uniformsGroup.id];
			void 0 === buffer && (function(uniformsGroup) {
				let uniforms = uniformsGroup.uniforms,
					offset = 0;
				for (let i = 0, l = uniforms.length; i < l; i++) {
					let uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
					for (let j = 0, jl = uniformArray.length; j < jl; j++) {
						let uniform = uniformArray[j],
							values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
						for (let k = 0, kl = values.length; k < kl; k++) {
							let info = getUniformSize(values[k]),
								chunkOffsetUniform = offset % 16;
							0 !== chunkOffsetUniform && 16 - chunkOffsetUniform < info.boundary && (offset += 16 - chunkOffsetUniform), uniform.__data = new Float32Array(info.storage / Float32Array.BYTES_PER_ELEMENT), uniform.__offset = offset, offset += info.storage
						}
					}
				}
				let chunkOffset = offset % 16;
				chunkOffset > 0 && (offset += 16 - chunkOffset), uniformsGroup.__size = offset, uniformsGroup.__cache = {}
			}(uniformsGroup), buffer = function(uniformsGroup) {
				let bindingPointIndex = function() {
					for (let i = 0; i < maxBindingPoints; i++)
						if (-1 === allocatedBindingPoints.indexOf(i)) return allocatedBindingPoints.push(i), i;
					return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
				}();
				uniformsGroup.__bindingPointIndex = bindingPointIndex;
				let buffer = gl.createBuffer(),
					size = uniformsGroup.__size,
					usage = uniformsGroup.usage;
				return gl.bindBuffer(gl.UNIFORM_BUFFER, buffer), gl.bufferData(gl.UNIFORM_BUFFER, size, usage), gl.bindBuffer(gl.UNIFORM_BUFFER, null), gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer), buffer
			}(uniformsGroup), buffers[uniformsGroup.id] = buffer, uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose));
			let webglProgram = program.program;
			state.updateUBOMapping(uniformsGroup, webglProgram);
			let frame = info.render.frame;
			updateList[uniformsGroup.id] !== frame && (function(uniformsGroup) {
				let buffer = buffers[uniformsGroup.id],
					uniforms = uniformsGroup.uniforms,
					cache = uniformsGroup.__cache;
				gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
				for (let i = 0, il = uniforms.length; i < il; i++) {
					let uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
					for (let j = 0, jl = uniformArray.length; j < jl; j++) {
						let uniform = uniformArray[j];
						if (!0 === function(uniform, index, indexArray, cache) {
								let value = uniform.value,
									indexString = index + "_" + indexArray;
								if (void 0 === cache[indexString]) return "number" == typeof value || "boolean" == typeof value ? cache[indexString] = value : cache[indexString] = value.clone(), !0;
								{
									let cachedObject = cache[indexString];
									if ("number" == typeof value || "boolean" == typeof value) {
										if (cachedObject !== value) return cache[indexString] = value, !0
									} else if (!1 === cachedObject.equals(value)) return cachedObject.copy(value), !0
								}
								return !1
							}(uniform, i, j, cache)) {
							let offset = uniform.__offset,
								values = Array.isArray(uniform.value) ? uniform.value : [uniform.value],
								arrayOffset = 0;
							for (let k = 0; k < values.length; k++) {
								let value = values[k],
									info = getUniformSize(value);
								"number" == typeof value || "boolean" == typeof value ? (uniform.__data[0] = value, gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data)) : value.isMatrix3 ? (uniform.__data[0] = value.elements[0], uniform.__data[1] = value.elements[1], uniform.__data[2] = value.elements[2], uniform.__data[3] = 0, uniform.__data[4] = value.elements[3], uniform.__data[5] = value.elements[4], uniform.__data[6] = value.elements[5], uniform.__data[7] = 0, uniform.__data[8] = value.elements[6], uniform.__data[9] = value.elements[7], uniform.__data[10] = value.elements[8], uniform.__data[11] = 0) : (value.toArray(uniform.__data, arrayOffset), arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT)
							}
							gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data)
						}
					}
				}
				gl.bindBuffer(gl.UNIFORM_BUFFER, null)
			}(uniformsGroup), updateList[uniformsGroup.id] = frame)
		},
		dispose: function() {
			for (let id in buffers) gl.deleteBuffer(buffers[id]);
			allocatedBindingPoints = [], buffers = {}, updateList = {}
		}
	}
}
class WebGLRenderer {
	constructor(parameters = {}) {
		let _alpha, extensions, capabilities, state, info, properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects, programCache, materials, renderLists, renderStates, clipping, shadowMap, background, morphtargets, bufferRenderer, indexedBufferRenderer, utils, bindingStates, uniformsGroups;
		let {
			canvas = function() {
				let canvas = createElementNS("canvas");
				return canvas.style.display = "block", canvas
			}(), context = null, depth = !0, stencil = !0, alpha = !1, antialias = !1, premultipliedAlpha = !0, preserveDrawingBuffer = !1, powerPreference = "default", failIfMajorPerformanceCaveat = !1
		} = parameters;
		this.isWebGLRenderer = !0, _alpha = null !== context ? context.getContextAttributes().alpha : alpha;
		let uintClearColor = new Uint32Array(4),
			intClearColor = new Int32Array(4),
			currentRenderList = null,
			currentRenderState = null,
			renderListStack = [],
			renderStateStack = [];
		this.domElement = canvas, this.debug = {
			checkShaderErrors: !0,
			onShaderError: null
		}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = SRGBColorSpace, this._useLegacyLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
		let _this = this,
			_isContextLost = !1,
			_currentActiveCubeFace = 0,
			_currentActiveMipmapLevel = 0,
			_currentRenderTarget = null,
			_currentMaterialId = -1,
			_currentCamera = null,
			_currentViewport = new Vector4,
			_currentScissor = new Vector4,
			_currentScissorTest = null,
			_currentClearColor = new Color(0),
			_currentClearAlpha = 0,
			_width = canvas.width,
			_height = canvas.height,
			_pixelRatio = 1,
			_opaqueSort = null,
			_transparentSort = null,
			_viewport = new Vector4(0, 0, _width, _height),
			_scissor = new Vector4(0, 0, _width, _height),
			_scissorTest = !1,
			_frustum = new Frustum,
			_clippingEnabled = !1,
			_localClippingEnabled = !1,
			_transmissionRenderTarget = null,
			_projScreenMatrix = new Matrix4,
			_vector2 = new Vector2,
			_vector3 = new Vector3,
			_emptyScene = {
				background: null,
				fog: null,
				environment: null,
				overrideMaterial: null,
				isScene: !0
			};

		function getTargetPixelRatio() {
			return null === _currentRenderTarget ? _pixelRatio : 1
		}
		let _gl = context;

		function getContext(contextNames, contextAttributes) {
			for (let i = 0; i < contextNames.length; i++) {
				let contextName = contextNames[i],
					context = canvas.getContext(contextName, contextAttributes);
				if (null !== context) return context
			}
			return null
		}
		try {
			if ("setAttribute" in canvas && canvas.setAttribute("data-engine", "three.js r160"), canvas.addEventListener("webglcontextlost", onContextLost, !1), canvas.addEventListener("webglcontextrestored", onContextRestore, !1), canvas.addEventListener("webglcontextcreationerror", onContextCreationError, !1), null === _gl) {
				let contextNames = ["webgl2", "webgl", "experimental-webgl"];
				if (!0 === _this.isWebGL1Renderer && contextNames.shift(), _gl = getContext(contextNames, {
						alpha: !0,
						depth,
						stencil,
						antialias,
						premultipliedAlpha,
						preserveDrawingBuffer,
						powerPreference,
						failIfMajorPerformanceCaveat
					}), null === _gl) {
					if (getContext(contextNames)) throw Error("Error creating WebGL context with your selected attributes.");
					throw Error("Error creating WebGL context.")
				}
			}
			"undefined" != typeof WebGLRenderingContext && _gl instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === _gl.getShaderPrecisionFormat && (_gl.getShaderPrecisionFormat = function() {
				return {
					rangeMin: 1,
					rangeMax: 1,
					precision: 1
				}
			})
		} catch (error) {
			throw console.error("THREE.WebGLRenderer: " + error.message), error
		}

		function initGLContext() {
			extensions = new WebGLExtensions(_gl), capabilities = new WebGLCapabilities(_gl, extensions, parameters), extensions.init(capabilities), utils = new WebGLUtils(_gl, extensions, capabilities), state = new WebGLState(_gl, extensions, capabilities), info = new WebGLInfo(_gl), properties = new WebGLProperties, textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info), cubemaps = new WebGLCubeMaps(_this), cubeuvmaps = new WebGLCubeUVMaps(_this), attributes = new WebGLAttributes(_gl, capabilities), bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities), geometries = new WebGLGeometries(_gl, attributes, info, bindingStates), objects = new WebGLObjects(_gl, geometries, attributes, info), morphtargets = new WebGLMorphtargets(_gl, capabilities, textures), clipping = new WebGLClipping(properties), programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping), materials = new WebGLMaterials(_this, properties), renderLists = new WebGLRenderLists, renderStates = new WebGLRenderStates(extensions, capabilities), background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha), shadowMap = new WebGLShadowMap(_this, objects, capabilities), uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state), bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities), indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities), info.programs = programCache.programs, _this.capabilities = capabilities, _this.extensions = extensions, _this.properties = properties, _this.renderLists = renderLists, _this.shadowMap = shadowMap, _this.state = state, _this.info = info
		}
		initGLContext();
		let xr = new WebXRManager(_this, _gl);

		function onContextLost(event) {
			event.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), _isContextLost = !0
		}

		function onContextRestore() {
			console.log("THREE.WebGLRenderer: Context Restored."), _isContextLost = !1;
			let infoAutoReset = info.autoReset,
				shadowMapEnabled = shadowMap.enabled,
				shadowMapAutoUpdate = shadowMap.autoUpdate,
				shadowMapNeedsUpdate = shadowMap.needsUpdate,
				shadowMapType = shadowMap.type;
			initGLContext(), info.autoReset = infoAutoReset, shadowMap.enabled = shadowMapEnabled, shadowMap.autoUpdate = shadowMapAutoUpdate, shadowMap.needsUpdate = shadowMapNeedsUpdate, shadowMap.type = shadowMapType
		}

		function onContextCreationError(event) {
			console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage)
		}

		function onMaterialDispose(event) {
			let material = event.target;
			material.removeEventListener("dispose", onMaterialDispose),
				function(material) {
					let programs = properties.get(material).programs;
					void 0 !== programs && (programs.forEach(function(program) {
						programCache.releaseProgram(program)
					}), material.isShaderMaterial && programCache.releaseShaderCache(material))
				}(material), properties.remove(material)
		}

		function prepareMaterial(material, scene, object) {
			!0 === material.transparent && 2 === material.side && !1 === material.forceSinglePass ? (material.side = 1, material.needsUpdate = !0, getProgram(material, scene, object), material.side = 0, material.needsUpdate = !0, getProgram(material, scene, object), material.side = 2) : getProgram(material, scene, object)
		}
		this.xr = xr, this.getContext = function() {
			return _gl
		}, this.getContextAttributes = function() {
			return _gl.getContextAttributes()
		}, this.forceContextLoss = function() {
			let extension = extensions.get("WEBGL_lose_context");
			extension && extension.loseContext()
		}, this.forceContextRestore = function() {
			let extension = extensions.get("WEBGL_lose_context");
			extension && extension.restoreContext()
		}, this.getPixelRatio = function() {
			return _pixelRatio
		}, this.setPixelRatio = function(value) {
			void 0 !== value && (_pixelRatio = value, this.setSize(_width, _height, !1))
		}, this.getSize = function(target) {
			return target.set(_width, _height)
		}, this.setSize = function(width, height, updateStyle = !0) {
			if (xr.isPresenting) {
				console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
				return
			}
			_width = width, _height = height, canvas.width = Math.floor(width * _pixelRatio), canvas.height = Math.floor(height * _pixelRatio), !0 === updateStyle && (canvas.style.width = width + "px", canvas.style.height = height + "px"), this.setViewport(0, 0, width, height)
		}, this.getDrawingBufferSize = function(target) {
			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor()
		}, this.setDrawingBufferSize = function(width, height, pixelRatio) {
			_width = width, _height = height, _pixelRatio = pixelRatio, canvas.width = Math.floor(width * pixelRatio), canvas.height = Math.floor(height * pixelRatio), this.setViewport(0, 0, width, height)
		}, this.getCurrentViewport = function(target) {
			return target.copy(_currentViewport)
		}, this.getViewport = function(target) {
			return target.copy(_viewport)
		}, this.setViewport = function(x, y, width, height) {
			x.isVector4 ? _viewport.set(x.x, x.y, x.z, x.w) : _viewport.set(x, y, width, height), state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor())
		}, this.getScissor = function(target) {
			return target.copy(_scissor)
		}, this.setScissor = function(x, y, width, height) {
			x.isVector4 ? _scissor.set(x.x, x.y, x.z, x.w) : _scissor.set(x, y, width, height), state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor())
		}, this.getScissorTest = function() {
			return _scissorTest
		}, this.setScissorTest = function(boolean) {
			state.setScissorTest(_scissorTest = boolean)
		}, this.setOpaqueSort = function(method) {
			_opaqueSort = method
		}, this.setTransparentSort = function(method) {
			_transparentSort = method
		}, this.getClearColor = function(target) {
			return target.copy(background.getClearColor())
		}, this.setClearColor = function() {
			background.setClearColor.apply(background, arguments)
		}, this.getClearAlpha = function() {
			return background.getClearAlpha()
		}, this.setClearAlpha = function() {
			background.setClearAlpha.apply(background, arguments)
		}, this.clear = function(color = !0, depth = !0, stencil = !0) {
			let bits = 0;
			if (color) {
				let isIntegerFormat = !1;
				if (null !== _currentRenderTarget) {
					let targetFormat = _currentRenderTarget.texture.format;
					isIntegerFormat = 1033 === targetFormat || 1031 === targetFormat || 1029 === targetFormat
				}
				if (isIntegerFormat) {
					let targetType = _currentRenderTarget.texture.type,
						clearColor = background.getClearColor(),
						a = background.getClearAlpha(),
						r = clearColor.r,
						g = clearColor.g,
						b = clearColor.b;
					1009 === targetType || 1014 === targetType || 1012 === targetType || 1020 === targetType || 1017 === targetType || 1018 === targetType ? (uintClearColor[0] = r, uintClearColor[1] = g, uintClearColor[2] = b, uintClearColor[3] = a, _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor)) : (intClearColor[0] = r, intClearColor[1] = g, intClearColor[2] = b, intClearColor[3] = a, _gl.clearBufferiv(_gl.COLOR, 0, intClearColor))
				} else bits |= _gl.COLOR_BUFFER_BIT
			}
			depth && (bits |= _gl.DEPTH_BUFFER_BIT), stencil && (bits |= _gl.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), _gl.clear(bits)
		}, this.clearColor = function() {
			this.clear(!0, !1, !1)
		}, this.clearDepth = function() {
			this.clear(!1, !0, !1)
		}, this.clearStencil = function() {
			this.clear(!1, !1, !0)
		}, this.dispose = function() {
			canvas.removeEventListener("webglcontextlost", onContextLost, !1), canvas.removeEventListener("webglcontextrestored", onContextRestore, !1), canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, !1), renderLists.dispose(), renderStates.dispose(), properties.dispose(), cubemaps.dispose(), cubeuvmaps.dispose(), objects.dispose(), bindingStates.dispose(), uniformsGroups.dispose(), programCache.dispose(), xr.dispose(), xr.removeEventListener("sessionstart", onXRSessionStart), xr.removeEventListener("sessionend", onXRSessionEnd), _transmissionRenderTarget && (_transmissionRenderTarget.dispose(), _transmissionRenderTarget = null), animation.stop()
		}, this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
			let attribute;
			null === scene && (scene = _emptyScene);
			let frontFaceCW = object.isMesh && 0 > object.matrixWorld.determinant(),
				program = function(camera, scene, geometry, material, object) {
					var value;
					!0 !== scene.isScene && (scene = _emptyScene), textures.resetTextureUnits();
					let fog = scene.fog,
						environment = material.isMeshStandardMaterial ? scene.environment : null,
						colorSpace1 = null === _currentRenderTarget ? _this.outputColorSpace : !0 === _currentRenderTarget.isXRRenderTarget ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
						envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment),
						vertexAlphas = !0 === material.vertexColors && !!geometry.attributes.color && 4 === geometry.attributes.color.itemSize,
						vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0),
						morphTargets = !!geometry.morphAttributes.position,
						morphNormals = !!geometry.morphAttributes.normal,
						morphColors = !!geometry.morphAttributes.color,
						toneMapping = 0;
					material.toneMapped && (null === _currentRenderTarget || !0 === _currentRenderTarget.isXRRenderTarget) && (toneMapping = _this.toneMapping);
					let morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color,
						morphTargetsCount = void 0 !== morphAttribute ? morphAttribute.length : 0,
						materialProperties = properties.get(material),
						lights = currentRenderState.state.lights;
					if (!0 === _clippingEnabled && (!0 === _localClippingEnabled || camera !== _currentCamera)) {
						let useCache = camera === _currentCamera && material.id === _currentMaterialId;
						clipping.setState(material, camera, useCache)
					}
					let needsProgramChange = !1;
					material.version === materialProperties.__version ? materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version ? needsProgramChange = !0 : materialProperties.outputColorSpace !== colorSpace1 ? needsProgramChange = !0 : object.isBatchedMesh && !1 === materialProperties.batching ? needsProgramChange = !0 : object.isBatchedMesh || !0 !== materialProperties.batching ? object.isInstancedMesh && !1 === materialProperties.instancing ? needsProgramChange = !0 : object.isInstancedMesh || !0 !== materialProperties.instancing ? object.isSkinnedMesh && !1 === materialProperties.skinning ? needsProgramChange = !0 : object.isSkinnedMesh || !0 !== materialProperties.skinning ? object.isInstancedMesh && !0 === materialProperties.instancingColor && null === object.instanceColor ? needsProgramChange = !0 : object.isInstancedMesh && !1 === materialProperties.instancingColor && null !== object.instanceColor ? needsProgramChange = !0 : materialProperties.envMap !== envMap ? needsProgramChange = !0 : !0 === material.fog && materialProperties.fog !== fog ? needsProgramChange = !0 : void 0 !== materialProperties.numClippingPlanes && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection) ? needsProgramChange = !0 : materialProperties.vertexAlphas !== vertexAlphas ? needsProgramChange = !0 : materialProperties.vertexTangents !== vertexTangents ? needsProgramChange = !0 : materialProperties.morphTargets !== morphTargets ? needsProgramChange = !0 : materialProperties.morphNormals !== morphNormals ? needsProgramChange = !0 : materialProperties.morphColors !== morphColors ? needsProgramChange = !0 : materialProperties.toneMapping !== toneMapping ? needsProgramChange = !0 : !0 === capabilities.isWebGL2 && materialProperties.morphTargetsCount !== morphTargetsCount && (needsProgramChange = !0) : needsProgramChange = !0 : needsProgramChange = !0 : needsProgramChange = !0 : (needsProgramChange = !0, materialProperties.__version = material.version);
					let program = materialProperties.currentProgram;
					!0 === needsProgramChange && (program = getProgram(material, scene, object));
					let refreshProgram = !1,
						refreshMaterial = !1,
						refreshLights = !1,
						p_uniforms = program.getUniforms(),
						m_uniforms = materialProperties.uniforms;
					if (state.useProgram(program.program) && (refreshProgram = !0, refreshMaterial = !0, refreshLights = !0), material.id !== _currentMaterialId && (_currentMaterialId = material.id, refreshMaterial = !0), refreshProgram || _currentCamera !== camera) {
						p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix), p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
						let uCamPos = p_uniforms.map.cameraPosition;
						void 0 !== uCamPos && uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld)), capabilities.logarithmicDepthBuffer && p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2)), (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) && p_uniforms.setValue(_gl, "isOrthographic", !0 === camera.isOrthographicCamera), _currentCamera !== camera && (_currentCamera = camera, refreshMaterial = !0, refreshLights = !0)
					}
					if (object.isSkinnedMesh) {
						p_uniforms.setOptional(_gl, object, "bindMatrix"), p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
						let skeleton = object.skeleton;
						skeleton && (capabilities.floatVertexTextures ? (null === skeleton.boneTexture && skeleton.computeBoneTexture(), p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
					}
					object.isBatchedMesh && (p_uniforms.setOptional(_gl, object, "batchingTexture"), p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures));
					let morphAttributes = geometry.morphAttributes;
					if ((void 0 !== morphAttributes.position || void 0 !== morphAttributes.normal || void 0 !== morphAttributes.color && !0 === capabilities.isWebGL2) && morphtargets.update(object, geometry, program), (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) && (materialProperties.receiveShadow = object.receiveShadow, p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow)), material.isMeshGouraudMaterial && null !== material.envMap && (m_uniforms.envMap.value = envMap, m_uniforms.flipEnvMap.value = envMap.isCubeTexture && !1 === envMap.isRenderTargetTexture ? -1 : 1), refreshMaterial && (p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure), materialProperties.needsLights && (value = refreshLights, m_uniforms.ambientLightColor.needsUpdate = value, m_uniforms.lightProbe.needsUpdate = value, m_uniforms.directionalLights.needsUpdate = value, m_uniforms.directionalLightShadows.needsUpdate = value, m_uniforms.pointLights.needsUpdate = value, m_uniforms.pointLightShadows.needsUpdate = value, m_uniforms.spotLights.needsUpdate = value, m_uniforms.spotLightShadows.needsUpdate = value, m_uniforms.rectAreaLights.needsUpdate = value, m_uniforms.hemisphereLights.needsUpdate = value), fog && !0 === material.fog && materials.refreshFogUniforms(m_uniforms, fog), materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget), WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures)), material.isShaderMaterial && !0 === material.uniformsNeedUpdate && (WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures), material.uniformsNeedUpdate = !1), material.isSpriteMaterial && p_uniforms.setValue(_gl, "center", object.center), p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix), p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix), p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld), material.isShaderMaterial || material.isRawShaderMaterial) {
						let groups = material.uniformsGroups;
						for (let i = 0, l = groups.length; i < l; i++)
							if (capabilities.isWebGL2) {
								let group = groups[i];
								uniformsGroups.update(group, program), uniformsGroups.bind(group, program)
							} else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
					}
					return program
				}(camera, scene, geometry, material, object);
			state.setMaterial(material, frontFaceCW);
			let index = geometry.index,
				rangeFactor = 1;
			if (!0 === material.wireframe) {
				if (void 0 === (index = geometries.getWireframeAttribute(geometry))) return;
				rangeFactor = 2
			}
			let drawRange = geometry.drawRange,
				position = geometry.attributes.position,
				drawStart = drawRange.start * rangeFactor,
				drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
			null !== group && (drawStart = Math.max(drawStart, group.start * rangeFactor), drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor)), null !== index ? (drawStart = Math.max(drawStart, 0), drawEnd = Math.min(drawEnd, index.count)) : null != position && (drawStart = Math.max(drawStart, 0), drawEnd = Math.min(drawEnd, position.count));
			let drawCount = drawEnd - drawStart;
			if (drawCount < 0 || drawCount === 1 / 0) return;
			bindingStates.setup(object, material, program, geometry, index);
			let renderer = bufferRenderer;
			if (null !== index && (attribute = attributes.get(index), (renderer = indexedBufferRenderer).setIndex(attribute)), object.isMesh) !0 === material.wireframe ? (state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio()), renderer.setMode(_gl.LINES)) : renderer.setMode(_gl.TRIANGLES);
			else if (object.isLine) {
				let lineWidth = material.linewidth;
				void 0 === lineWidth && (lineWidth = 1), state.setLineWidth(lineWidth * getTargetPixelRatio()), object.isLineSegments ? renderer.setMode(_gl.LINES) : object.isLineLoop ? renderer.setMode(_gl.LINE_LOOP) : renderer.setMode(_gl.LINE_STRIP)
			} else object.isPoints ? renderer.setMode(_gl.POINTS) : object.isSprite && renderer.setMode(_gl.TRIANGLES);
			if (object.isBatchedMesh) renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
			else if (object.isInstancedMesh) renderer.renderInstances(drawStart, drawCount, object.count);
			else if (geometry.isInstancedBufferGeometry) {
				let maxInstanceCount = void 0 !== geometry._maxInstanceCount ? geometry._maxInstanceCount : 1 / 0,
					instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
				renderer.renderInstances(drawStart, drawCount, instanceCount)
			} else renderer.render(drawStart, drawCount)
		}, this.compile = function(scene, camera, targetScene = null) {
			null === targetScene && (targetScene = scene), (currentRenderState = renderStates.get(targetScene)).init(), renderStateStack.push(currentRenderState), targetScene.traverseVisible(function(object) {
				object.isLight && object.layers.test(camera.layers) && (currentRenderState.pushLight(object), object.castShadow && currentRenderState.pushShadow(object))
			}), scene !== targetScene && scene.traverseVisible(function(object) {
				object.isLight && object.layers.test(camera.layers) && (currentRenderState.pushLight(object), object.castShadow && currentRenderState.pushShadow(object))
			}), currentRenderState.setupLights(_this._useLegacyLights);
			let materials = new Set;
			return scene.traverse(function(object) {
				let material = object.material;
				if (material) {
					if (Array.isArray(material))
						for (let i = 0; i < material.length; i++) {
							let material2 = material[i];
							prepareMaterial(material2, targetScene, object), materials.add(material2)
						} else prepareMaterial(material, targetScene, object), materials.add(material)
				}
			}), renderStateStack.pop(), currentRenderState = null, materials
		}, this.compileAsync = function(scene, camera, targetScene = null) {
			let materials = this.compile(scene, camera, targetScene);
			return new Promise(resolve => {
				function checkMaterialsReady() {
					if (materials.forEach(function(material) {
							properties.get(material).currentProgram.isReady() && materials.delete(material)
						}), 0 === materials.size) {
						resolve(scene);
						return
					}
					setTimeout(checkMaterialsReady, 10)
				}
				null !== extensions.get("KHR_parallel_shader_compile") ? checkMaterialsReady() : setTimeout(checkMaterialsReady, 10)
			})
		};
		let onAnimationFrameCallback = null;

		function onXRSessionStart() {
			animation.stop()
		}

		function onXRSessionEnd() {
			animation.start()
		}
		let animation = new WebGLAnimation;

		function renderScene(currentRenderList, scene, camera, viewport) {
			let opaqueObjects = currentRenderList.opaque,
				transmissiveObjects = currentRenderList.transmissive,
				transparentObjects = currentRenderList.transparent;
			currentRenderState.setupLightsView(camera), !0 === _clippingEnabled && clipping.setGlobalState(_this.clippingPlanes, camera), transmissiveObjects.length > 0 && function(opaqueObjects, transmissiveObjects, scene, camera) {
				if (null !== (!0 === scene.isScene ? scene.overrideMaterial : null)) return;
				let isWebGL2 = capabilities.isWebGL2;
				null === _transmissionRenderTarget && (_transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
					generateMipmaps: !0,
					type: extensions.has("EXT_color_buffer_half_float") ? 1016 : 1009,
					minFilter: 1008,
					samples: isWebGL2 ? 4 : 0
				})), _this.getDrawingBufferSize(_vector2), isWebGL2 ? _transmissionRenderTarget.setSize(_vector2.x, _vector2.y) : _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x), floorPowerOfTwo(_vector2.y));
				let currentRenderTarget = _this.getRenderTarget();
				_this.setRenderTarget(_transmissionRenderTarget), _this.getClearColor(_currentClearColor), (_currentClearAlpha = _this.getClearAlpha()) < 1 && _this.setClearColor(16777215, .5), _this.clear();
				let currentToneMapping = _this.toneMapping;
				_this.toneMapping = 0, renderObjects(opaqueObjects, scene, camera), textures.updateMultisampleRenderTarget(_transmissionRenderTarget), textures.updateRenderTargetMipmap(_transmissionRenderTarget);
				let renderTargetNeedsUpdate = !1;
				for (let i = 0, l = transmissiveObjects.length; i < l; i++) {
					let renderItem = transmissiveObjects[i],
						object = renderItem.object,
						geometry = renderItem.geometry,
						material = renderItem.material,
						group = renderItem.group;
					if (2 === material.side && object.layers.test(camera.layers)) {
						let currentSide = material.side;
						material.side = 1, material.needsUpdate = !0, renderObject(object, scene, camera, geometry, material, group), material.side = currentSide, material.needsUpdate = !0, renderTargetNeedsUpdate = !0
					}
				}!0 === renderTargetNeedsUpdate && (textures.updateMultisampleRenderTarget(_transmissionRenderTarget), textures.updateRenderTargetMipmap(_transmissionRenderTarget)), _this.setRenderTarget(currentRenderTarget), _this.setClearColor(_currentClearColor, _currentClearAlpha), _this.toneMapping = currentToneMapping
			}(opaqueObjects, transmissiveObjects, scene, camera), viewport && state.viewport(_currentViewport.copy(viewport)), opaqueObjects.length > 0 && renderObjects(opaqueObjects, scene, camera), transmissiveObjects.length > 0 && renderObjects(transmissiveObjects, scene, camera), transparentObjects.length > 0 && renderObjects(transparentObjects, scene, camera), state.buffers.depth.setTest(!0), state.buffers.depth.setMask(!0), state.buffers.color.setMask(!0), state.setPolygonOffset(!1)
		}

		function renderObjects(renderList, scene, camera) {
			let overrideMaterial = !0 === scene.isScene ? scene.overrideMaterial : null;
			for (let i = 0, l = renderList.length; i < l; i++) {
				let renderItem = renderList[i],
					object = renderItem.object,
					geometry = renderItem.geometry,
					material = null === overrideMaterial ? renderItem.material : overrideMaterial,
					group = renderItem.group;
				object.layers.test(camera.layers) && renderObject(object, scene, camera, geometry, material, group)
			}
		}

		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group), object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld), object.normalMatrix.getNormalMatrix(object.modelViewMatrix), material.onBeforeRender(_this, scene, camera, geometry, object, group), !0 === material.transparent && 2 === material.side && !1 === material.forceSinglePass ? (material.side = 1, material.needsUpdate = !0, _this.renderBufferDirect(camera, scene, geometry, material, object, group), material.side = 0, material.needsUpdate = !0, _this.renderBufferDirect(camera, scene, geometry, material, object, group), material.side = 2) : _this.renderBufferDirect(camera, scene, geometry, material, object, group), object.onAfterRender(_this, scene, camera, geometry, material, group)
		}

		function getProgram(material, scene, object) {
			!0 !== scene.isScene && (scene = _emptyScene);
			let materialProperties = properties.get(material),
				lights = currentRenderState.state.lights,
				shadowsArray = currentRenderState.state.shadowsArray,
				lightsStateVersion = lights.state.version,
				parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object),
				programCacheKey = programCache.getProgramCacheKey(parameters),
				programs = materialProperties.programs;
			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null, materialProperties.fog = scene.fog, materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment), void 0 === programs && (material.addEventListener("dispose", onMaterialDispose), programs = new Map, materialProperties.programs = programs);
			let program = programs.get(programCacheKey);
			if (void 0 !== program) {
				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) return updateCommonMaterialProperties(material, parameters), program
			} else parameters.uniforms = programCache.getUniforms(material), material.onBuild(object, parameters, _this), material.onBeforeCompile(parameters, _this), program = programCache.acquireProgram(parameters, programCacheKey), programs.set(programCacheKey, program), materialProperties.uniforms = parameters.uniforms;
			let uniforms = materialProperties.uniforms;
			return (material.isShaderMaterial || material.isRawShaderMaterial) && !0 !== material.clipping || (uniforms.clippingPlanes = clipping.uniform), updateCommonMaterialProperties(material, parameters), materialProperties.needsLights = material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && !0 === material.lights, materialProperties.lightsStateVersion = lightsStateVersion, materialProperties.needsLights && (uniforms.ambientLightColor.value = lights.state.ambient, uniforms.lightProbe.value = lights.state.probe, uniforms.directionalLights.value = lights.state.directional, uniforms.directionalLightShadows.value = lights.state.directionalShadow, uniforms.spotLights.value = lights.state.spot, uniforms.spotLightShadows.value = lights.state.spotShadow, uniforms.rectAreaLights.value = lights.state.rectArea, uniforms.ltc_1.value = lights.state.rectAreaLTC1, uniforms.ltc_2.value = lights.state.rectAreaLTC2, uniforms.pointLights.value = lights.state.point, uniforms.pointLightShadows.value = lights.state.pointShadow, uniforms.hemisphereLights.value = lights.state.hemi, uniforms.directionalShadowMap.value = lights.state.directionalShadowMap, uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix, uniforms.spotShadowMap.value = lights.state.spotShadowMap, uniforms.spotLightMatrix.value = lights.state.spotLightMatrix, uniforms.spotLightMap.value = lights.state.spotLightMap, uniforms.pointShadowMap.value = lights.state.pointShadowMap, uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix), materialProperties.currentProgram = program, materialProperties.uniformsList = null, program
		}

		function getUniformList(materialProperties) {
			if (null === materialProperties.uniformsList) {
				let progUniforms = materialProperties.currentProgram.getUniforms();
				materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms)
			}
			return materialProperties.uniformsList
		}

		function updateCommonMaterialProperties(material, parameters) {
			let materialProperties = properties.get(material);
			materialProperties.outputColorSpace = parameters.outputColorSpace, materialProperties.batching = parameters.batching, materialProperties.instancing = parameters.instancing, materialProperties.instancingColor = parameters.instancingColor, materialProperties.skinning = parameters.skinning, materialProperties.morphTargets = parameters.morphTargets, materialProperties.morphNormals = parameters.morphNormals, materialProperties.morphColors = parameters.morphColors, materialProperties.morphTargetsCount = parameters.morphTargetsCount, materialProperties.numClippingPlanes = parameters.numClippingPlanes, materialProperties.numIntersection = parameters.numClipIntersection, materialProperties.vertexAlphas = parameters.vertexAlphas, materialProperties.vertexTangents = parameters.vertexTangents, materialProperties.toneMapping = parameters.toneMapping
		}
		animation.setAnimationLoop(function(time) {
			onAnimationFrameCallback && onAnimationFrameCallback(time)
		}), "undefined" != typeof self && animation.setContext(self), this.setAnimationLoop = function(callback) {
			onAnimationFrameCallback = callback, xr.setAnimationLoop(callback), null === callback ? animation.stop() : animation.start()
		}, xr.addEventListener("sessionstart", onXRSessionStart), xr.addEventListener("sessionend", onXRSessionEnd), this.render = function(scene, camera) {
			if (void 0 !== camera && !0 !== camera.isCamera) {
				console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
				return
			}
			if (!0 === _isContextLost) return;
			!0 === scene.matrixWorldAutoUpdate && scene.updateMatrixWorld(), null === camera.parent && !0 === camera.matrixWorldAutoUpdate && camera.updateMatrixWorld(), !0 === xr.enabled && !0 === xr.isPresenting && (!0 === xr.cameraAutoUpdate && xr.updateCamera(camera), camera = xr.getCamera()), !0 === scene.isScene && scene.onBeforeRender(_this, scene, camera, _currentRenderTarget), (currentRenderState = renderStates.get(scene, renderStateStack.length)).init(), renderStateStack.push(currentRenderState), _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse), _frustum.setFromProjectionMatrix(_projScreenMatrix), _localClippingEnabled = this.localClippingEnabled, _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled), (currentRenderList = renderLists.get(scene, renderListStack.length)).init(), renderListStack.push(currentRenderList),
				function projectObject(object, camera, groupOrder, sortObjects) {
					if (!1 === object.visible) return;
					if (object.layers.test(camera.layers)) {
						if (object.isGroup) groupOrder = object.renderOrder;
						else if (object.isLOD) !0 === object.autoUpdate && object.update(camera);
						else if (object.isLight) currentRenderState.pushLight(object), object.castShadow && currentRenderState.pushShadow(object);
						else if (object.isSprite) {
							if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
								sortObjects && _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
								let geometry = objects.update(object),
									material = object.material;
								material.visible && currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null)
							}
						} else if ((object.isMesh || object.isLine || object.isPoints) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
							let geometry = objects.update(object),
								material = object.material;
							if (sortObjects && (void 0 !== object.boundingSphere ? (null === object.boundingSphere && object.computeBoundingSphere(), _vector3.copy(object.boundingSphere.center)) : (null === geometry.boundingSphere && geometry.computeBoundingSphere(), _vector3.copy(geometry.boundingSphere.center)), _vector3.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix)), Array.isArray(material)) {
								let groups = geometry.groups;
								for (let i = 0, l = groups.length; i < l; i++) {
									let group = groups[i],
										groupMaterial = material[group.materialIndex];
									groupMaterial && groupMaterial.visible && currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group)
								}
							} else material.visible && currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null)
						}
					}
					let children = object.children;
					for (let i = 0, l = children.length; i < l; i++) projectObject(children[i], camera, groupOrder, sortObjects)
				}(scene, camera, 0, _this.sortObjects), currentRenderList.finish(), !0 === _this.sortObjects && currentRenderList.sort(_opaqueSort, _transparentSort), this.info.render.frame++, !0 === _clippingEnabled && clipping.beginShadows();
			let shadowsArray = currentRenderState.state.shadowsArray;
			if (shadowMap.render(shadowsArray, scene, camera), !0 === _clippingEnabled && clipping.endShadows(), !0 === this.info.autoReset && this.info.reset(), background.render(currentRenderList, scene), currentRenderState.setupLights(_this._useLegacyLights), camera.isArrayCamera) {
				let cameras = camera.cameras;
				for (let i = 0, l = cameras.length; i < l; i++) {
					let camera2 = cameras[i];
					renderScene(currentRenderList, scene, camera2, camera2.viewport)
				}
			} else renderScene(currentRenderList, scene, camera);
			null !== _currentRenderTarget && (textures.updateMultisampleRenderTarget(_currentRenderTarget), textures.updateRenderTargetMipmap(_currentRenderTarget)), !0 === scene.isScene && scene.onAfterRender(_this, scene, camera), bindingStates.resetDefaultState(), _currentMaterialId = -1, _currentCamera = null, renderStateStack.pop(), currentRenderState = renderStateStack.length > 0 ? renderStateStack[renderStateStack.length - 1] : null, renderListStack.pop(), currentRenderList = renderListStack.length > 0 ? renderListStack[renderListStack.length - 1] : null
		}, this.getActiveCubeFace = function() {
			return _currentActiveCubeFace
		}, this.getActiveMipmapLevel = function() {
			return _currentActiveMipmapLevel
		}, this.getRenderTarget = function() {
			return _currentRenderTarget
		}, this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
			properties.get(renderTarget.texture).__webglTexture = colorTexture, properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
			let renderTargetProperties = properties.get(renderTarget);
			renderTargetProperties.__hasExternalTextures = !0, renderTargetProperties.__hasExternalTextures && (renderTargetProperties.__autoAllocateDepthBuffer = void 0 === depthTexture, renderTargetProperties.__autoAllocateDepthBuffer || !0 !== extensions.has("WEBGL_multisampled_render_to_texture") || (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), renderTargetProperties.__useRenderToTexture = !1))
		}, this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
			let renderTargetProperties = properties.get(renderTarget);
			renderTargetProperties.__webglFramebuffer = defaultFramebuffer, renderTargetProperties.__useDefaultFramebuffer = void 0 === defaultFramebuffer
		}, this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
			_currentRenderTarget = renderTarget, _currentActiveCubeFace = activeCubeFace, _currentActiveMipmapLevel = activeMipmapLevel;
			let useDefaultFramebuffer = !0,
				framebuffer = null,
				isCube = !1,
				isRenderTarget3D = !1;
			if (renderTarget) {
				let renderTargetProperties = properties.get(renderTarget);
				void 0 !== renderTargetProperties.__useDefaultFramebuffer ? (state.bindFramebuffer(_gl.FRAMEBUFFER, null), useDefaultFramebuffer = !1) : void 0 === renderTargetProperties.__webglFramebuffer ? textures.setupRenderTarget(renderTarget) : renderTargetProperties.__hasExternalTextures && textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
				let texture = renderTarget.texture;
				(texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) && (isRenderTarget3D = !0);
				let __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
				renderTarget.isWebGLCubeRenderTarget ? (framebuffer = Array.isArray(__webglFramebuffer[activeCubeFace]) ? __webglFramebuffer[activeCubeFace][activeMipmapLevel] : __webglFramebuffer[activeCubeFace], isCube = !0) : framebuffer = capabilities.isWebGL2 && renderTarget.samples > 0 && !1 === textures.useMultisampledRTT(renderTarget) ? properties.get(renderTarget).__webglMultisampledFramebuffer : Array.isArray(__webglFramebuffer) ? __webglFramebuffer[activeMipmapLevel] : __webglFramebuffer, _currentViewport.copy(renderTarget.viewport), _currentScissor.copy(renderTarget.scissor), _currentScissorTest = renderTarget.scissorTest
			} else _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor(), _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor(), _currentScissorTest = _scissorTest;
			if (state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer) && capabilities.drawBuffers && useDefaultFramebuffer && state.drawBuffers(renderTarget, framebuffer), state.viewport(_currentViewport), state.scissor(_currentScissor), state.setScissorTest(_currentScissorTest), isCube) {
				let textureProperties = properties.get(renderTarget.texture);
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel)
			} else if (isRenderTarget3D) {
				let textureProperties = properties.get(renderTarget.texture);
				_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, activeCubeFace || 0)
			}
			_currentMaterialId = -1
		}, this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
				return
			}
			let framebuffer = properties.get(renderTarget).__webglFramebuffer;
			if (renderTarget.isWebGLCubeRenderTarget && void 0 !== activeCubeFaceIndex && (framebuffer = framebuffer[activeCubeFaceIndex]), framebuffer) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				try {
					let texture = renderTarget.texture,
						textureFormat = texture.format,
						textureType = texture.type;
					if (1023 !== textureFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
						return
					}
					let halfFloatSupportedByExt = 1016 === textureType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
					if (1009 !== textureType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && !(1015 === textureType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
						return
					}
					x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height && _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer)
				} finally {
					let framebuffer = null !== _currentRenderTarget ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
					state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer)
				}
			}
		}, this.copyFramebufferToTexture = function(position, texture, level = 0) {
			let levelScale = Math.pow(2, -level),
				width = Math.floor(texture.image.width * levelScale),
				height = Math.floor(texture.image.height * levelScale);
			textures.setTexture2D(texture, 0), _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height), state.unbindTexture()
		}, this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
			let width = srcTexture.image.width,
				height = srcTexture.image.height,
				glFormat = utils.convert(dstTexture.format),
				glType = utils.convert(dstTexture.type);
			textures.setTexture2D(dstTexture, 0), _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha), _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment), srcTexture.isDataTexture ? _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data) : srcTexture.isCompressedTexture ? _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data) : _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image), 0 === level && dstTexture.generateMipmaps && _gl.generateMipmap(_gl.TEXTURE_2D), state.unbindTexture()
		}, this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
			let glTarget;
			if (_this.isWebGL1Renderer) {
				console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
				return
			}
			let width = sourceBox.max.x - sourceBox.min.x + 1,
				height = sourceBox.max.y - sourceBox.min.y + 1,
				depth = sourceBox.max.z - sourceBox.min.z + 1,
				glFormat = utils.convert(dstTexture.format),
				glType = utils.convert(dstTexture.type);
			if (dstTexture.isData3DTexture) textures.setTexture3D(dstTexture, 0), glTarget = _gl.TEXTURE_3D;
			else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) textures.setTexture2DArray(dstTexture, 0), glTarget = _gl.TEXTURE_2D_ARRAY;
			else {
				console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
				return
			}
			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY), _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha), _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
			let unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH),
				unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT),
				unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS),
				unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS),
				unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES),
				image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width), _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height), _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x), _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y), _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z), srcTexture.isDataTexture || srcTexture.isData3DTexture ? _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data) : srcTexture.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data)) : _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image), _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen), _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight), _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels), _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows), _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages), 0 === level && dstTexture.generateMipmaps && _gl.generateMipmap(glTarget), state.unbindTexture()
		}, this.initTexture = function(texture) {
			texture.isCubeTexture ? textures.setTextureCube(texture, 0) : texture.isData3DTexture ? textures.setTexture3D(texture, 0) : texture.isDataArrayTexture || texture.isCompressedArrayTexture ? textures.setTexture2DArray(texture, 0) : textures.setTexture2D(texture, 0), state.unbindTexture()
		}, this.resetState = function() {
			_currentActiveCubeFace = 0, _currentActiveMipmapLevel = 0, _currentRenderTarget = null, state.reset(), bindingStates.reset()
		}, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
			detail: this
		}))
	}
	get coordinateSystem() {
		return 2e3
	}
	get outputColorSpace() {
		return this._outputColorSpace
	}
	set outputColorSpace(colorSpace1) {
		this._outputColorSpace = colorSpace1;
		let gl = this.getContext();
		gl.drawingBufferColorSpace = colorSpace1 === DisplayP3ColorSpace ? "display-p3" : "srgb", gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? "display-p3" : "srgb"
	}
	get outputEncoding() {
		return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === SRGBColorSpace ? 3001 : 3e3
	}
	set outputEncoding(encoding) {
		console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = 3001 === encoding ? SRGBColorSpace : LinearSRGBColorSpace
	}
	get useLegacyLights() {
		return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
	}
	set useLegacyLights(value) {
		console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = value
	}
}(class extends WebGLRenderer {}).prototype.isWebGL1Renderer = !0;
class Scene extends Object3D {
	constructor() {
		super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
			detail: this
		}))
	}
	copy(source, recursive) {
		return super.copy(source, recursive), null !== source.background && (this.background = source.background.clone()), null !== source.environment && (this.environment = source.environment.clone()), null !== source.fog && (this.fog = source.fog.clone()), this.backgroundBlurriness = source.backgroundBlurriness, this.backgroundIntensity = source.backgroundIntensity, null !== source.overrideMaterial && (this.overrideMaterial = source.overrideMaterial.clone()), this.matrixAutoUpdate = source.matrixAutoUpdate, this
	}
	toJSON(meta) {
		let data = super.toJSON(meta);
		return null !== this.fog && (data.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (data.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (data.object.backgroundIntensity = this.backgroundIntensity), data
	}
}
class InterleavedBuffer {
	constructor(array, stride) {
		this.isInterleavedBuffer = !0, this.array = array, this.stride = stride, this.count = void 0 !== array ? array.length / stride : 0, this.usage = 35044, this._updateRange = {
			offset: 0,
			count: -1
		}, this.updateRanges = [], this.version = 0, this.uuid = generateUUID()
	}
	onUploadCallback() {}
	set needsUpdate(value) {
		!0 === value && this.version++
	}
	get updateRange() {
		return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
	}
	setUsage(value) {
		return this.usage = value, this
	}
	addUpdateRange(start, count) {
		this.updateRanges.push({
			start,
			count
		})
	}
	clearUpdateRanges() {
		this.updateRanges.length = 0
	}
	copy(source) {
		return this.array = new source.array.constructor(source.array), this.count = source.count, this.stride = source.stride, this.usage = source.usage, this
	}
	copyAt(index1, attribute, index2) {
		index1 *= this.stride, index2 *= attribute.stride;
		for (let i = 0, l = this.stride; i < l; i++) this.array[index1 + i] = attribute.array[index2 + i];
		return this
	}
	set(value, offset = 0) {
		return this.array.set(value, offset), this
	}
	clone(data) {
		void 0 === data.arrayBuffers && (data.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = generateUUID()), void 0 === data.arrayBuffers[this.array.buffer._uuid] && (data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
		let array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]),
			ib = new this.constructor(array, this.stride);
		return ib.setUsage(this.usage), ib
	}
	onUpload(callback) {
		return this.onUploadCallback = callback, this
	}
	toJSON(data) {
		return void 0 === data.arrayBuffers && (data.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = generateUUID()), void 0 === data.arrayBuffers[this.array.buffer._uuid] && (data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		}
	}
}
let _vector$6 = new Vector3;
class InterleavedBufferAttribute {
	constructor(interleavedBuffer, itemSize, offset, normalized = !1) {
		this.isInterleavedBufferAttribute = !0, this.name = "", this.data = interleavedBuffer, this.itemSize = itemSize, this.offset = offset, this.normalized = normalized
	}
	get count() {
		return this.data.count
	}
	get array() {
		return this.data.array
	}
	set needsUpdate(value) {
		this.data.needsUpdate = value
	}
	applyMatrix4(m) {
		for (let i = 0, l = this.data.count; i < l; i++) _vector$6.fromBufferAttribute(this, i), _vector$6.applyMatrix4(m), this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
		return this
	}
	applyNormalMatrix(m) {
		for (let i = 0, l = this.count; i < l; i++) _vector$6.fromBufferAttribute(this, i), _vector$6.applyNormalMatrix(m), this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
		return this
	}
	transformDirection(m) {
		for (let i = 0, l = this.count; i < l; i++) _vector$6.fromBufferAttribute(this, i), _vector$6.transformDirection(m), this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
		return this
	}
	setX(index, x) {
		return this.normalized && (x = normalize(x, this.array)), this.data.array[index * this.data.stride + this.offset] = x, this
	}
	setY(index, y) {
		return this.normalized && (y = normalize(y, this.array)), this.data.array[index * this.data.stride + this.offset + 1] = y, this
	}
	setZ(index, z) {
		return this.normalized && (z = normalize(z, this.array)), this.data.array[index * this.data.stride + this.offset + 2] = z, this
	}
	setW(index, w) {
		return this.normalized && (w = normalize(w, this.array)), this.data.array[index * this.data.stride + this.offset + 3] = w, this
	}
	getX(index) {
		let x = this.data.array[index * this.data.stride + this.offset];
		return this.normalized && (x = denormalize(x, this.array)), x
	}
	getY(index) {
		let y = this.data.array[index * this.data.stride + this.offset + 1];
		return this.normalized && (y = denormalize(y, this.array)), y
	}
	getZ(index) {
		let z = this.data.array[index * this.data.stride + this.offset + 2];
		return this.normalized && (z = denormalize(z, this.array)), z
	}
	getW(index) {
		let w = this.data.array[index * this.data.stride + this.offset + 3];
		return this.normalized && (w = denormalize(w, this.array)), w
	}
	setXY(index, x, y) {
		return index = index * this.data.stride + this.offset, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array)), this.data.array[index + 0] = x, this.data.array[index + 1] = y, this
	}
	setXYZ(index, x, y, z) {
		return index = index * this.data.stride + this.offset, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array)), this.data.array[index + 0] = x, this.data.array[index + 1] = y, this.data.array[index + 2] = z, this
	}
	setXYZW(index, x, y, z, w) {
		return index = index * this.data.stride + this.offset, this.normalized && (x = normalize(x, this.array), y = normalize(y, this.array), z = normalize(z, this.array), w = normalize(w, this.array)), this.data.array[index + 0] = x, this.data.array[index + 1] = y, this.data.array[index + 2] = z, this.data.array[index + 3] = w, this
	}
	clone(data) {
		if (void 0 !== data) return void 0 === data.interleavedBuffers && (data.interleavedBuffers = {}), void 0 === data.interleavedBuffers[this.data.uuid] && (data.interleavedBuffers[this.data.uuid] = this.data.clone(data)), new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
		{
			console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
			let array = [];
			for (let i = 0; i < this.count; i++) {
				let index = i * this.data.stride + this.offset;
				for (let j = 0; j < this.itemSize; j++) array.push(this.data.array[index + j])
			}
			return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized)
		}
	}
	toJSON(data) {
		if (void 0 !== data) return void 0 === data.interleavedBuffers && (data.interleavedBuffers = {}), void 0 === data.interleavedBuffers[this.data.uuid] && (data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data)), {
			isInterleavedBufferAttribute: !0,
			itemSize: this.itemSize,
			data: this.data.uuid,
			offset: this.offset,
			normalized: this.normalized
		};
		{
			console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
			let array = [];
			for (let i = 0; i < this.count; i++) {
				let index = i * this.data.stride + this.offset;
				for (let j = 0; j < this.itemSize; j++) array.push(this.data.array[index + j])
			}
			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			}
		}
	}
}
let _basePosition = new Vector3,
	_skinIndex = new Vector4,
	_skinWeight = new Vector4,
	_vector3 = new Vector3,
	_matrix4 = new Matrix4,
	_vertex = new Vector3,
	_sphere$4 = new Sphere,
	_inverseMatrix$2 = new Matrix4,
	_ray$2 = new Ray;
class SkinnedMesh extends Mesh {
	constructor(geometry, material) {
		super(geometry, material), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = AttachedBindMode, this.bindMatrix = new Matrix4, this.bindMatrixInverse = new Matrix4, this.boundingBox = null, this.boundingSphere = null
	}
	computeBoundingBox() {
		let geometry = this.geometry;
		null === this.boundingBox && (this.boundingBox = new Box3), this.boundingBox.makeEmpty();
		let positionAttribute = geometry.getAttribute("position");
		for (let i = 0; i < positionAttribute.count; i++) this.getVertexPosition(i, _vertex), this.boundingBox.expandByPoint(_vertex)
	}
	computeBoundingSphere() {
		let geometry = this.geometry;
		null === this.boundingSphere && (this.boundingSphere = new Sphere), this.boundingSphere.makeEmpty();
		let positionAttribute = geometry.getAttribute("position");
		for (let i = 0; i < positionAttribute.count; i++) this.getVertexPosition(i, _vertex), this.boundingSphere.expandByPoint(_vertex)
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.bindMode = source.bindMode, this.bindMatrix.copy(source.bindMatrix), this.bindMatrixInverse.copy(source.bindMatrixInverse), this.skeleton = source.skeleton, null !== source.boundingBox && (this.boundingBox = source.boundingBox.clone()), null !== source.boundingSphere && (this.boundingSphere = source.boundingSphere.clone()), this
	}
	raycast(raycaster, intersects) {
		let material = this.material,
			matrixWorld = this.matrixWorld;
		if (void 0 !== material && (null === this.boundingSphere && this.computeBoundingSphere(), _sphere$4.copy(this.boundingSphere), _sphere$4.applyMatrix4(matrixWorld), !1 !== raycaster.ray.intersectsSphere(_sphere$4))) {
			if (_inverseMatrix$2.copy(matrixWorld).invert(), _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2), null !== this.boundingBox && !1 === _ray$2.intersectsBox(this.boundingBox)) return;
			this._computeIntersections(raycaster, intersects, _ray$2)
		}
	}
	getVertexPosition(index, target) {
		return super.getVertexPosition(index, target), this.applyBoneTransform(index, target), target
	}
	bind(skeleton, bindMatrix) {
		this.skeleton = skeleton, void 0 === bindMatrix && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), bindMatrix = this.matrixWorld), this.bindMatrix.copy(bindMatrix), this.bindMatrixInverse.copy(bindMatrix).invert()
	}
	pose() {
		this.skeleton.pose()
	}
	normalizeSkinWeights() {
		let vector = new Vector4,
			skinWeight = this.geometry.attributes.skinWeight;
		for (let i = 0, l = skinWeight.count; i < l; i++) {
			vector.fromBufferAttribute(skinWeight, i);
			let scale = 1 / vector.manhattanLength();
			scale !== 1 / 0 ? vector.multiplyScalar(scale) : vector.set(1, 0, 0, 0), skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w)
		}
	}
	updateMatrixWorld(force) {
		super.updateMatrixWorld(force), this.bindMode === AttachedBindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
	}
	applyBoneTransform(index, vector) {
		let skeleton = this.skeleton,
			geometry = this.geometry;
		_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index), _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index), _basePosition.copy(vector).applyMatrix4(this.bindMatrix), vector.set(0, 0, 0);
		for (let i = 0; i < 4; i++) {
			let weight = _skinWeight.getComponent(i);
			if (0 !== weight) {
				let boneIndex = _skinIndex.getComponent(i);
				_matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]), vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight)
			}
		}
		return vector.applyMatrix4(this.bindMatrixInverse)
	}
	boneTransform(index, vector) {
		return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(index, vector)
	}
}
class Bone extends Object3D {
	constructor() {
		super(), this.isBone = !0, this.type = "Bone"
	}
}
class DataTexture extends Texture$1 {
	constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace1) {
		super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace1), this.isDataTexture = !0, this.image = {
			data: data,
			width: width,
			height: height
		}, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
	}
}
let _offsetMatrix = new Matrix4,
	_identityMatrix$1 = new Matrix4;
class Skeleton {
	constructor(bones = [], boneInverses = []) {
		this.uuid = generateUUID(), this.bones = bones.slice(0), this.boneInverses = boneInverses, this.boneMatrices = null, this.boneTexture = null, this.init()
	}
	init() {
		let bones = this.bones,
			boneInverses = this.boneInverses;
		if (this.boneMatrices = new Float32Array(16 * bones.length), 0 === boneInverses.length) this.calculateInverses();
		else if (bones.length !== boneInverses.length) {
			console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
			for (let i = 0, il = this.bones.length; i < il; i++) this.boneInverses.push(new Matrix4)
		}
	}
	calculateInverses() {
		this.boneInverses.length = 0;
		for (let i = 0, il = this.bones.length; i < il; i++) {
			let inverse = new Matrix4;
			this.bones[i] && inverse.copy(this.bones[i].matrixWorld).invert(), this.boneInverses.push(inverse)
		}
	}
	pose() {
		for (let i = 0, il = this.bones.length; i < il; i++) {
			let bone = this.bones[i];
			bone && bone.matrixWorld.copy(this.boneInverses[i]).invert()
		}
		for (let i = 0, il = this.bones.length; i < il; i++) {
			let bone = this.bones[i];
			bone && (bone.parent && bone.parent.isBone ? (bone.matrix.copy(bone.parent.matrixWorld).invert(), bone.matrix.multiply(bone.matrixWorld)) : bone.matrix.copy(bone.matrixWorld), bone.matrix.decompose(bone.position, bone.quaternion, bone.scale))
		}
	}
	update() {
		let bones = this.bones,
			boneInverses = this.boneInverses,
			boneMatrices = this.boneMatrices,
			boneTexture = this.boneTexture;
		for (let i = 0, il = bones.length; i < il; i++) {
			let matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix$1;
			_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]), _offsetMatrix.toArray(boneMatrices, 16 * i)
		}
		null !== boneTexture && (boneTexture.needsUpdate = !0)
	}
	clone() {
		return new Skeleton(this.bones, this.boneInverses)
	}
	computeBoneTexture() {
		let size = Math.sqrt(4 * this.bones.length),
			boneMatrices = new Float32Array((size = Math.max(size = 4 * Math.ceil(size / 4), 4)) * size * 4);
		boneMatrices.set(this.boneMatrices);
		let boneTexture = new DataTexture(boneMatrices, size, size, 1023, 1015);
		return boneTexture.needsUpdate = !0, this.boneMatrices = boneMatrices, this.boneTexture = boneTexture, this
	}
	getBoneByName(name) {
		for (let i = 0, il = this.bones.length; i < il; i++) {
			let bone = this.bones[i];
			if (bone.name === name) return bone
		}
	}
	dispose() {
		null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
	}
	fromJSON(json, bones) {
		this.uuid = json.uuid;
		for (let i = 0, l = json.bones.length; i < l; i++) {
			let uuid = json.bones[i],
				bone = bones[uuid];
			void 0 === bone && (console.warn("THREE.Skeleton: No bone found with UUID:", uuid), bone = new Bone), this.bones.push(bone), this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]))
		}
		return this.init(), this
	}
	toJSON() {
		let data = {
			metadata: {
				version: 4.6,
				type: "Skeleton",
				generator: "Skeleton.toJSON"
			},
			bones: [],
			boneInverses: []
		};
		data.uuid = this.uuid;
		let bones = this.bones,
			boneInverses = this.boneInverses;
		for (let i = 0, l = bones.length; i < l; i++) {
			let bone = bones[i];
			data.bones.push(bone.uuid);
			let boneInverse = boneInverses[i];
			data.boneInverses.push(boneInverse.toArray())
		}
		return data
	}
}
class InstancedBufferAttribute extends BufferAttribute {
	constructor(array, itemSize, normalized, meshPerAttribute = 1) {
		super(array, itemSize, normalized), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = meshPerAttribute
	}
	copy(source) {
		return super.copy(source), this.meshPerAttribute = source.meshPerAttribute, this
	}
	toJSON() {
		let data = super.toJSON();
		return data.meshPerAttribute = this.meshPerAttribute, data.isInstancedBufferAttribute = !0, data
	}
}
let _instanceLocalMatrix = new Matrix4,
	_instanceWorldMatrix = new Matrix4,
	_instanceIntersects = [],
	_box3 = new Box3,
	_identity = new Matrix4,
	_mesh$1 = new Mesh,
	_sphere$3 = new Sphere;
class InstancedMesh extends Mesh {
	constructor(geometry, material, count) {
		super(geometry, material), this.isInstancedMesh = !0, this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(16 * count), 16), this.instanceColor = null, this.count = count, this.boundingBox = null, this.boundingSphere = null;
		for (let i = 0; i < count; i++) this.setMatrixAt(i, _identity)
	}
	computeBoundingBox() {
		let geometry = this.geometry,
			count = this.count;
		null === this.boundingBox && (this.boundingBox = new Box3), null === geometry.boundingBox && geometry.computeBoundingBox(), this.boundingBox.makeEmpty();
		for (let i = 0; i < count; i++) this.getMatrixAt(i, _instanceLocalMatrix), _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix), this.boundingBox.union(_box3)
	}
	computeBoundingSphere() {
		let geometry = this.geometry,
			count = this.count;
		null === this.boundingSphere && (this.boundingSphere = new Sphere), null === geometry.boundingSphere && geometry.computeBoundingSphere(), this.boundingSphere.makeEmpty();
		for (let i = 0; i < count; i++) this.getMatrixAt(i, _instanceLocalMatrix), _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix), this.boundingSphere.union(_sphere$3)
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.instanceMatrix.copy(source.instanceMatrix), null !== source.instanceColor && (this.instanceColor = source.instanceColor.clone()), this.count = source.count, null !== source.boundingBox && (this.boundingBox = source.boundingBox.clone()), null !== source.boundingSphere && (this.boundingSphere = source.boundingSphere.clone()), this
	}
	getColorAt(index, color) {
		color.fromArray(this.instanceColor.array, 3 * index)
	}
	getMatrixAt(index, matrix) {
		matrix.fromArray(this.instanceMatrix.array, 16 * index)
	}
	raycast(raycaster, intersects) {
		let matrixWorld = this.matrixWorld,
			raycastTimes = this.count;
		if (_mesh$1.geometry = this.geometry, _mesh$1.material = this.material, void 0 !== _mesh$1.material && (null === this.boundingSphere && this.computeBoundingSphere(), _sphere$3.copy(this.boundingSphere), _sphere$3.applyMatrix4(matrixWorld), !1 !== raycaster.ray.intersectsSphere(_sphere$3)))
			for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
				this.getMatrixAt(instanceId, _instanceLocalMatrix), _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix), _mesh$1.matrixWorld = _instanceWorldMatrix, _mesh$1.raycast(raycaster, _instanceIntersects);
				for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
					let intersect = _instanceIntersects[i];
					intersect.instanceId = instanceId, intersect.object = this, intersects.push(intersect)
				}
				_instanceIntersects.length = 0
			}
	}
	setColorAt(index, color) {
		null === this.instanceColor && (this.instanceColor = new InstancedBufferAttribute(new Float32Array(3 * this.instanceMatrix.count), 3)), color.toArray(this.instanceColor.array, 3 * index)
	}
	setMatrixAt(index, matrix) {
		matrix.toArray(this.instanceMatrix.array, 16 * index)
	}
	updateMorphTargets() {}
	dispose() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
}
class LineBasicMaterial extends Material$1 {
	constructor(parameters) {
		super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Color(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(parameters)
	}
	copy(source) {
		return super.copy(source), this.color.copy(source.color), this.map = source.map, this.linewidth = source.linewidth, this.linecap = source.linecap, this.linejoin = source.linejoin, this.fog = source.fog, this
	}
}
let _start$1 = new Vector3,
	_end$1 = new Vector3,
	_inverseMatrix$1 = new Matrix4,
	_ray$1 = new Ray,
	_sphere$1 = new Sphere;
class Line extends Object3D {
	constructor(geometry = new BufferGeometry, material = new LineBasicMaterial) {
		super(), this.isLine = !0, this.type = "Line", this.geometry = geometry, this.material = material, this.updateMorphTargets()
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.material = Array.isArray(source.material) ? source.material.slice() : source.material, this.geometry = source.geometry, this
	}
	computeLineDistances() {
		let geometry = this.geometry;
		if (null === geometry.index) {
			let positionAttribute = geometry.attributes.position,
				lineDistances = [0];
			for (let i = 1, l = positionAttribute.count; i < l; i++) _start$1.fromBufferAttribute(positionAttribute, i - 1), _end$1.fromBufferAttribute(positionAttribute, i), lineDistances[i] = lineDistances[i - 1], lineDistances[i] += _start$1.distanceTo(_end$1);
			geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1))
		} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
		return this
	}
	raycast(raycaster, intersects) {
		let geometry = this.geometry,
			matrixWorld = this.matrixWorld,
			threshold = raycaster.params.Line.threshold,
			drawRange = geometry.drawRange;
		if (null === geometry.boundingSphere && geometry.computeBoundingSphere(), _sphere$1.copy(geometry.boundingSphere), _sphere$1.applyMatrix4(matrixWorld), _sphere$1.radius += threshold, !1 === raycaster.ray.intersectsSphere(_sphere$1)) return;
		_inverseMatrix$1.copy(matrixWorld).invert(), _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
		let localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			localThresholdSq = localThreshold * localThreshold,
			vStart = new Vector3,
			vEnd = new Vector3,
			interSegment = new Vector3,
			interRay = new Vector3,
			step = this.isLineSegments ? 2 : 1,
			index = geometry.index,
			positionAttribute = geometry.attributes.position;
		if (null !== index) {
			let start = Math.max(0, drawRange.start),
				end = Math.min(index.count, drawRange.start + drawRange.count);
			for (let i = start, l = end - 1; i < l; i += step) {
				let a = index.getX(i),
					b = index.getX(i + 1);
				if (vStart.fromBufferAttribute(positionAttribute, a), vEnd.fromBufferAttribute(positionAttribute, b), _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment) > localThresholdSq) continue;
				interRay.applyMatrix4(this.matrixWorld);
				let distance = raycaster.ray.origin.distanceTo(interRay);
				distance < raycaster.near || distance > raycaster.far || intersects.push({
					distance: distance,
					point: interSegment.clone().applyMatrix4(this.matrixWorld),
					index: i,
					face: null,
					faceIndex: null,
					object: this
				})
			}
		} else {
			let start = Math.max(0, drawRange.start),
				end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
			for (let i = start, l = end - 1; i < l; i += step) {
				if (vStart.fromBufferAttribute(positionAttribute, i), vEnd.fromBufferAttribute(positionAttribute, i + 1), _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment) > localThresholdSq) continue;
				interRay.applyMatrix4(this.matrixWorld);
				let distance = raycaster.ray.origin.distanceTo(interRay);
				distance < raycaster.near || distance > raycaster.far || intersects.push({
					distance: distance,
					point: interSegment.clone().applyMatrix4(this.matrixWorld),
					index: i,
					face: null,
					faceIndex: null,
					object: this
				})
			}
		}
	}
	updateMorphTargets() {
		let morphAttributes = this.geometry.morphAttributes,
			keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			let morphAttribute = morphAttributes[keys[0]];
			if (void 0 !== morphAttribute) {
				this.morphTargetInfluences = [], this.morphTargetDictionary = {};
				for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
					let name = morphAttribute[m].name || String(m);
					this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m
				}
			}
		}
	}
}
let _start = new Vector3,
	_end = new Vector3;
class LineSegments extends Line {
	constructor(geometry, material) {
		super(geometry, material), this.isLineSegments = !0, this.type = "LineSegments"
	}
	computeLineDistances() {
		let geometry = this.geometry;
		if (null === geometry.index) {
			let positionAttribute = geometry.attributes.position,
				lineDistances = [];
			for (let i = 0, l = positionAttribute.count; i < l; i += 2) _start.fromBufferAttribute(positionAttribute, i), _end.fromBufferAttribute(positionAttribute, i + 1), lineDistances[i] = 0 === i ? 0 : lineDistances[i - 1], lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
			geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1))
		} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
		return this
	}
}
class LineLoop extends Line {
	constructor(geometry, material) {
		super(geometry, material), this.isLineLoop = !0, this.type = "LineLoop"
	}
}
class PointsMaterial extends Material$1 {
	constructor(parameters) {
		super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Color(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(parameters)
	}
	copy(source) {
		return super.copy(source), this.color.copy(source.color), this.map = source.map, this.alphaMap = source.alphaMap, this.size = source.size, this.sizeAttenuation = source.sizeAttenuation, this.fog = source.fog, this
	}
}
let _inverseMatrix = new Matrix4,
	_ray = new Ray,
	_sphere = new Sphere,
	_position$2 = new Vector3;
class Points extends Object3D {
	constructor(geometry = new BufferGeometry, material = new PointsMaterial) {
		super(), this.isPoints = !0, this.type = "Points", this.geometry = geometry, this.material = material, this.updateMorphTargets()
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.material = Array.isArray(source.material) ? source.material.slice() : source.material, this.geometry = source.geometry, this
	}
	raycast(raycaster, intersects) {
		let geometry = this.geometry,
			matrixWorld = this.matrixWorld,
			threshold = raycaster.params.Points.threshold,
			drawRange = geometry.drawRange;
		if (null === geometry.boundingSphere && geometry.computeBoundingSphere(), _sphere.copy(geometry.boundingSphere), _sphere.applyMatrix4(matrixWorld), _sphere.radius += threshold, !1 === raycaster.ray.intersectsSphere(_sphere)) return;
		_inverseMatrix.copy(matrixWorld).invert(), _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
		let localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3),
			localThresholdSq = localThreshold * localThreshold,
			index = geometry.index,
			positionAttribute = geometry.attributes.position;
		if (null !== index) {
			let start = Math.max(0, drawRange.start),
				end = Math.min(index.count, drawRange.start + drawRange.count);
			for (let i = start; i < end; i++) {
				let a = index.getX(i);
				_position$2.fromBufferAttribute(positionAttribute, a), testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this)
			}
		} else {
			let start = Math.max(0, drawRange.start),
				end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
			for (let i = start; i < end; i++) _position$2.fromBufferAttribute(positionAttribute, i), testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this)
		}
	}
	updateMorphTargets() {
		let morphAttributes = this.geometry.morphAttributes,
			keys = Object.keys(morphAttributes);
		if (keys.length > 0) {
			let morphAttribute = morphAttributes[keys[0]];
			if (void 0 !== morphAttribute) {
				this.morphTargetInfluences = [], this.morphTargetDictionary = {};
				for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
					let name = morphAttribute[m].name || String(m);
					this.morphTargetInfluences.push(0), this.morphTargetDictionary[name] = m
				}
			}
		}
	}
}

function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
	let rayPointDistanceSq = _ray.distanceSqToPoint(point);
	if (rayPointDistanceSq < localThresholdSq) {
		let intersectPoint = new Vector3;
		_ray.closestPointToPoint(point, intersectPoint), intersectPoint.applyMatrix4(matrixWorld);
		let distance = raycaster.ray.origin.distanceTo(intersectPoint);
		if (distance < raycaster.near || distance > raycaster.far) return;
		intersects.push({
			distance: distance,
			distanceToRay: Math.sqrt(rayPointDistanceSq),
			point: intersectPoint,
			index: index,
			face: null,
			object: object
		})
	}
}
class VideoTexture extends Texture$1 {
	constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
		super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy), this.isVideoTexture = !0, this.minFilter = void 0 !== minFilter ? minFilter : 1006, this.magFilter = void 0 !== magFilter ? magFilter : 1006, this.generateMipmaps = !1;
		let scope = this;
		"requestVideoFrameCallback" in video && video.requestVideoFrameCallback(function updateVideo() {
			scope.needsUpdate = !0, video.requestVideoFrameCallback(updateVideo)
		})
	}
	clone() {
		return new this.constructor(this.image).copy(this)
	}
	update() {
		let video = this.image;
		!1 == "requestVideoFrameCallback" in video && video.readyState >= video.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
	}
}
class CompressedTexture extends Texture$1 {
	constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace1) {
		super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace1), this.isCompressedTexture = !0, this.image = {
			width: width,
			height: height
		}, this.mipmaps = mipmaps, this.flipY = !1, this.generateMipmaps = !1
	}
}
class CompressedArrayTexture extends CompressedTexture {
	constructor(mipmaps, width, height, depth, format, type) {
		super(mipmaps, width, height, format, type), this.isCompressedArrayTexture = !0, this.image.depth = depth, this.wrapR = 1001
	}
}
class CompressedCubeTexture extends CompressedTexture {
	constructor(images, format, type) {
		super(void 0, images[0].width, images[0].height, format, type, 301), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = images
	}
}
class CanvasTexture extends Texture$1 {
	constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
		super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy), this.isCanvasTexture = !0, this.needsUpdate = !0
	}
}
class SphereGeometry extends BufferGeometry {
	constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = 2 * Math.PI, thetaStart = 0, thetaLength = Math.PI) {
		super(), this.type = "SphereGeometry", this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		}, widthSegments = Math.max(3, Math.floor(widthSegments)), heightSegments = Math.max(2, Math.floor(heightSegments));
		let thetaEnd = Math.min(thetaStart + thetaLength, Math.PI),
			index = 0,
			grid = [],
			vertex = new Vector3,
			normal = new Vector3,
			indices = [],
			vertices = [],
			normals = [],
			uvs = [];
		for (let iy = 0; iy <= heightSegments; iy++) {
			let verticesRow = [],
				v = iy / heightSegments,
				uOffset = 0;
			0 === iy && 0 === thetaStart ? uOffset = .5 / widthSegments : iy === heightSegments && thetaEnd === Math.PI && (uOffset = -.5 / widthSegments);
			for (let ix = 0; ix <= widthSegments; ix++) {
				let u = ix / widthSegments;
				vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), vertex.y = radius * Math.cos(thetaStart + v * thetaLength), vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength), vertices.push(vertex.x, vertex.y, vertex.z), normal.copy(vertex).normalize(), normals.push(normal.x, normal.y, normal.z), uvs.push(u + uOffset, 1 - v), verticesRow.push(index++)
			}
			grid.push(verticesRow)
		}
		for (let iy = 0; iy < heightSegments; iy++)
			for (let ix = 0; ix < widthSegments; ix++) {
				let a = grid[iy][ix + 1],
					b = grid[iy][ix],
					c = grid[iy + 1][ix],
					d = grid[iy + 1][ix + 1];
				(0 !== iy || thetaStart > 0) && indices.push(a, b, d), (iy !== heightSegments - 1 || thetaEnd < Math.PI) && indices.push(b, c, d)
			}
		this.setIndex(indices), this.setAttribute("position", new Float32BufferAttribute(vertices, 3)), this.setAttribute("normal", new Float32BufferAttribute(normals, 3)), this.setAttribute("uv", new Float32BufferAttribute(uvs, 2))
	}
	copy(source) {
		return super.copy(source), this.parameters = Object.assign({}, source.parameters), this
	}
	static fromJSON(data) {
		return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength)
	}
}
class MeshStandardMaterial extends Material$1 {
	constructor(parameters) {
		super(), this.isMeshStandardMaterial = !0, this.defines = {
			STANDARD: ""
		}, this.type = "MeshStandardMaterial", this.color = new Color(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(parameters)
	}
	copy(source) {
		return super.copy(source), this.defines = {
			STANDARD: ""
		}, this.color.copy(source.color), this.roughness = source.roughness, this.metalness = source.metalness, this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.roughnessMap = source.roughnessMap, this.metalnessMap = source.metalnessMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapIntensity = source.envMapIntensity, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.flatShading = source.flatShading, this.fog = source.fog, this
	}
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
	constructor(parameters) {
		super(), this.isMeshPhysicalMaterial = !0, this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		}, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Vector2(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
			get: function() {
				return clamp$1(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
			},
			set: function(reflectivity) {
				this.ior = (1 + .4 * reflectivity) / (1 - .4 * reflectivity)
			}
		}), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Color(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Color(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Color(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(parameters)
	}
	get anisotropy() {
		return this._anisotropy
	}
	set anisotropy(value) {
		this._anisotropy > 0 != value > 0 && this.version++, this._anisotropy = value
	}
	get clearcoat() {
		return this._clearcoat
	}
	set clearcoat(value) {
		this._clearcoat > 0 != value > 0 && this.version++, this._clearcoat = value
	}
	get iridescence() {
		return this._iridescence
	}
	set iridescence(value) {
		this._iridescence > 0 != value > 0 && this.version++, this._iridescence = value
	}
	get sheen() {
		return this._sheen
	}
	set sheen(value) {
		this._sheen > 0 != value > 0 && this.version++, this._sheen = value
	}
	get transmission() {
		return this._transmission
	}
	set transmission(value) {
		this._transmission > 0 != value > 0 && this.version++, this._transmission = value
	}
	copy(source) {
		return super.copy(source), this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		}, this.anisotropy = source.anisotropy, this.anisotropyRotation = source.anisotropyRotation, this.anisotropyMap = source.anisotropyMap, this.clearcoat = source.clearcoat, this.clearcoatMap = source.clearcoatMap, this.clearcoatRoughness = source.clearcoatRoughness, this.clearcoatRoughnessMap = source.clearcoatRoughnessMap, this.clearcoatNormalMap = source.clearcoatNormalMap, this.clearcoatNormalScale.copy(source.clearcoatNormalScale), this.ior = source.ior, this.iridescence = source.iridescence, this.iridescenceMap = source.iridescenceMap, this.iridescenceIOR = source.iridescenceIOR, this.iridescenceThicknessRange = [...source.iridescenceThicknessRange], this.iridescenceThicknessMap = source.iridescenceThicknessMap, this.sheen = source.sheen, this.sheenColor.copy(source.sheenColor), this.sheenColorMap = source.sheenColorMap, this.sheenRoughness = source.sheenRoughness, this.sheenRoughnessMap = source.sheenRoughnessMap, this.transmission = source.transmission, this.transmissionMap = source.transmissionMap, this.thickness = source.thickness, this.thicknessMap = source.thicknessMap, this.attenuationDistance = source.attenuationDistance, this.attenuationColor.copy(source.attenuationColor), this.specularIntensity = source.specularIntensity, this.specularIntensityMap = source.specularIntensityMap, this.specularColor.copy(source.specularColor), this.specularColorMap = source.specularColorMap, this
	}
}

function convertArray(array, type, forceClone) {
	return array && (forceClone || array.constructor !== type) ? "number" == typeof type.BYTES_PER_ELEMENT ? new type(array) : Array.prototype.slice.call(array) : array
}

function sortedArray(values, stride, order) {
	let nValues = values.length,
		result = new values.constructor(nValues);
	for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
		let srcOffset = order[i] * stride;
		for (let j = 0; j !== stride; ++j) result[dstOffset++] = values[srcOffset + j]
	}
	return result
}

function flattenJSON(jsonKeys, times, values, valuePropertyName) {
	let i = 1,
		key = jsonKeys[0];
	for (; void 0 !== key && void 0 === key[valuePropertyName];) key = jsonKeys[i++];
	if (void 0 === key) return;
	let value = key[valuePropertyName];
	if (void 0 !== value) {
		if (Array.isArray(value))
			do void 0 !== (value = key[valuePropertyName]) && (times.push(key.time), values.push.apply(values, value)), key = jsonKeys[i++]; while (void 0 !== key)
		else if (void 0 !== value.toArray)
			do void 0 !== (value = key[valuePropertyName]) && (times.push(key.time), value.toArray(values, values.length)), key = jsonKeys[i++]; while (void 0 !== key)
		else
			do void 0 !== (value = key[valuePropertyName]) && (times.push(key.time), values.push(value)), key = jsonKeys[i++]; while (void 0 !== key)
	}
}
class Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		this.parameterPositions = parameterPositions, this._cachedIndex = 0, this.resultBuffer = void 0 !== resultBuffer ? resultBuffer : new sampleValues.constructor(sampleSize), this.sampleValues = sampleValues, this.valueSize = sampleSize, this.settings = null, this.DefaultSettings_ = {}
	}
	evaluate(t) {
		let pp = this.parameterPositions,
			i1 = this._cachedIndex,
			t1 = pp[i1],
			t0 = pp[i1 - 1];
		validate_interval: {
			seek: {
				let right;linear_scan: {
					forward_scan: if (!(t < t1)) {
						for (let giveUpAt = i1 + 2;;) {
							if (void 0 === t1) {
								if (t < t0) break forward_scan;
								return i1 = pp.length, this._cachedIndex = i1, this.copySampleValue_(i1 - 1)
							}
							if (i1 === giveUpAt) break;
							if (t0 = t1, t < (t1 = pp[++i1])) break seek
						}
						right = pp.length;
						break linear_scan
					}if (!(t >= t0)) {
						let t1global = pp[1];
						t < t1global && (i1 = 2, t0 = t1global);
						for (let giveUpAt = i1 - 2;;) {
							if (void 0 === t0) return this._cachedIndex = 0, this.copySampleValue_(0);
							if (i1 === giveUpAt) break;
							if (t1 = t0, t >= (t0 = pp[--i1 - 1])) break seek
						}
						right = i1, i1 = 0;
						break linear_scan
					}
					break validate_interval
				}
				for (; i1 < right;) {
					let mid = i1 + right >>> 1;
					t < pp[mid] ? right = mid : i1 = mid + 1
				}
				if (t1 = pp[i1], void 0 === (t0 = pp[i1 - 1])) return this._cachedIndex = 0,
				this.copySampleValue_(0);
				if (void 0 === t1) return i1 = pp.length,
				this._cachedIndex = i1,
				this.copySampleValue_(i1 - 1)
			}
			this._cachedIndex = i1,
			this.intervalChanged_(i1, t0, t1)
		}
		return this.interpolate_(i1, t0, t, t1)
	}
	getSettings_() {
		return this.settings || this.DefaultSettings_
	}
	copySampleValue_(index) {
		let result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;
		for (let i = 0; i !== stride; ++i) result[i] = values[offset + i];
		return result
	}
	interpolate_() {
		throw Error("call to abstract method")
	}
	intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
			endingStart: 2400,
			endingEnd: 2400
		}
	}
	intervalChanged_(i1, t0, t1) {
		let pp = this.parameterPositions,
			iPrev = i1 - 2,
			iNext = i1 + 1,
			tPrev = pp[iPrev],
			tNext = pp[iNext];
		if (void 0 === tPrev) switch (this.getSettings_().endingStart) {
			case 2401:
				iPrev = i1, tPrev = 2 * t0 - t1;
				break;
			case 2402:
				iPrev = pp.length - 2, tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
				break;
			default:
				iPrev = i1, tPrev = t1
		}
		if (void 0 === tNext) switch (this.getSettings_().endingEnd) {
			case 2401:
				iNext = i1, tNext = 2 * t1 - t0;
				break;
			case 2402:
				iNext = 1, tNext = t1 + pp[1] - pp[0];
				break;
			default:
				iNext = i1 - 1, tNext = t0
		}
		let halfDt = (t1 - t0) * .5,
			stride = this.valueSize;
		this._weightPrev = halfDt / (t0 - tPrev), this._weightNext = halfDt / (tNext - t1), this._offsetPrev = iPrev * stride, this._offsetNext = iNext * stride
	}
	interpolate_(i1, t0, t, t1) {
		let result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			o1 = i1 * stride,
			o0 = o1 - stride,
			oP = this._offsetPrev,
			oN = this._offsetNext,
			wP = this._weightPrev,
			wN = this._weightNext,
			p = (t - t0) / (t1 - t0),
			pp = p * p,
			ppp = pp * p,
			sP = -wP * ppp + 2 * wP * pp - wP * p,
			s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-.5 + wP) * p + 1,
			s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + .5 * p,
			sN = wN * ppp - wN * pp;
		for (let i = 0; i !== stride; ++i) result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
		return result
	}
}
class LinearInterpolant extends Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer)
	}
	interpolate_(i1, t0, t, t1) {
		let result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset1 = i1 * stride,
			offset0 = offset1 - stride,
			weight1 = (t - t0) / (t1 - t0),
			weight0 = 1 - weight1;
		for (let i = 0; i !== stride; ++i) result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
		return result
	}
}
class DiscreteInterpolant extends Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer)
	}
	interpolate_(i1) {
		return this.copySampleValue_(i1 - 1)
	}
}
class KeyframeTrack {
	constructor(name, times, values, interpolation) {
		if (void 0 === name) throw Error("THREE.KeyframeTrack: track name is undefined");
		if (void 0 === times || 0 === times.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + name);
		this.name = name, this.times = convertArray(times, this.TimeBufferType), this.values = convertArray(values, this.ValueBufferType), this.setInterpolation(interpolation || this.DefaultInterpolation)
	}
	static toJSON(track) {
		let json;
		let trackType = track.constructor;
		if (trackType.toJSON !== this.toJSON) json = trackType.toJSON(track);
		else {
			json = {
				name: track.name,
				times: convertArray(track.times, Array),
				values: convertArray(track.values, Array)
			};
			let interpolation = track.getInterpolation();
			interpolation !== track.DefaultInterpolation && (json.interpolation = interpolation)
		}
		return json.type = track.ValueTypeName, json
	}
	InterpolantFactoryMethodDiscrete(result) {
		return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result)
	}
	InterpolantFactoryMethodLinear(result) {
		return new LinearInterpolant(this.times, this.values, this.getValueSize(), result)
	}
	InterpolantFactoryMethodSmooth(result) {
		return new CubicInterpolant(this.times, this.values, this.getValueSize(), result)
	}
	setInterpolation(interpolation) {
		let factoryMethod;
		switch (interpolation) {
			case 2300:
				factoryMethod = this.InterpolantFactoryMethodDiscrete;
				break;
			case 2301:
				factoryMethod = this.InterpolantFactoryMethodLinear;
				break;
			case 2302:
				factoryMethod = this.InterpolantFactoryMethodSmooth
		}
		if (void 0 === factoryMethod) {
			let message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
			if (void 0 === this.createInterpolant) {
				if (interpolation !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
				else throw Error(message)
			}
			return console.warn("THREE.KeyframeTrack:", message), this
		}
		return this.createInterpolant = factoryMethod, this
	}
	getInterpolation() {
		switch (this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete:
				return 2300;
			case this.InterpolantFactoryMethodLinear:
				return 2301;
			case this.InterpolantFactoryMethodSmooth:
				return 2302
		}
	}
	getValueSize() {
		return this.values.length / this.times.length
	}
	shift(timeOffset) {
		if (0 !== timeOffset) {
			let times = this.times;
			for (let i = 0, n = times.length; i !== n; ++i) times[i] += timeOffset
		}
		return this
	}
	scale(timeScale) {
		if (1 !== timeScale) {
			let times = this.times;
			for (let i = 0, n = times.length; i !== n; ++i) times[i] *= timeScale
		}
		return this
	}
	trim(startTime, endTime) {
		let times = this.times,
			nKeys = times.length,
			from = 0,
			to = nKeys - 1;
		for (; from !== nKeys && times[from] < startTime;) ++from;
		for (; - 1 !== to && times[to] > endTime;) --to;
		if (++to, 0 !== from || to !== nKeys) {
			from >= to && (from = (to = Math.max(to, 1)) - 1);
			let stride = this.getValueSize();
			this.times = times.slice(from, to), this.values = this.values.slice(from * stride, to * stride)
		}
		return this
	}
	validate() {
		let valid = !0,
			valueSize = this.getValueSize();
		valueSize - Math.floor(valueSize) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), valid = !1);
		let times = this.times,
			values = this.values,
			nKeys = times.length;
		0 === nKeys && (console.error("THREE.KeyframeTrack: Track is empty.", this), valid = !1);
		let prevTime = null;
		for (let i = 0; i !== nKeys; i++) {
			let currTime = times[i];
			if ("number" == typeof currTime && isNaN(currTime)) {
				console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime), valid = !1;
				break
			}
			if (null !== prevTime && prevTime > currTime) {
				console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime), valid = !1;
				break
			}
			prevTime = currTime
		}
		if (void 0 !== values && ArrayBuffer.isView(values) && !(values instanceof DataView))
			for (let i = 0, n = values.length; i !== n; ++i) {
				let value = values[i];
				if (isNaN(value)) {
					console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value), valid = !1;
					break
				}
			}
		return valid
	}
	optimize() {
		let times = this.times.slice(),
			values = this.values.slice(),
			stride = this.getValueSize(),
			smoothInterpolation = 2302 === this.getInterpolation(),
			lastIndex = times.length - 1,
			writeIndex = 1;
		for (let i = 1; i < lastIndex; ++i) {
			let keep = !1,
				time = times[i];
			if (time !== times[i + 1] && (1 !== i || time !== times[0])) {
				if (smoothInterpolation) keep = !0;
				else {
					let offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;
					for (let j = 0; j !== stride; ++j) {
						let value = values[offset + j];
						if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
							keep = !0;
							break
						}
					}
				}
			}
			if (keep) {
				if (i !== writeIndex) {
					times[writeIndex] = times[i];
					let readOffset = i * stride,
						writeOffset = writeIndex * stride;
					for (let j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j]
				}++writeIndex
			}
		}
		if (lastIndex > 0) {
			times[writeIndex] = times[lastIndex];
			for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) values[writeOffset + j] = values[readOffset + j];
			++writeIndex
		}
		return writeIndex !== times.length ? (this.times = times.slice(0, writeIndex), this.values = values.slice(0, writeIndex * stride)) : (this.times = times, this.values = values), this
	}
	clone() {
		let times = this.times.slice(),
			values = this.values.slice(),
			track = new this.constructor(this.name, times, values);
		return track.createInterpolant = this.createInterpolant, track
	}
}
KeyframeTrack.prototype.TimeBufferType = Float32Array, KeyframeTrack.prototype.ValueBufferType = Float32Array, KeyframeTrack.prototype.DefaultInterpolation = 2301;
class BooleanKeyframeTrack extends KeyframeTrack {}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool", BooleanKeyframeTrack.prototype.ValueBufferType = Array, BooleanKeyframeTrack.prototype.DefaultInterpolation = 2300, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer)
	}
	interpolate_(i1, t0, t, t1) {
		let result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			alpha = (t - t0) / (t1 - t0),
			offset = i1 * stride;
		for (let end = offset + stride; offset !== end; offset += 4) Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
		return result
	}
}
class QuaternionKeyframeTrack extends KeyframeTrack {
	InterpolantFactoryMethodLinear(result) {
		return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result)
	}
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion", QuaternionKeyframeTrack.prototype.DefaultInterpolation = 2301, QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {}
StringKeyframeTrack.prototype.ValueTypeName = "string", StringKeyframeTrack.prototype.ValueBufferType = Array, StringKeyframeTrack.prototype.DefaultInterpolation = 2300, StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0, StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
	constructor(name, duration = -1, tracks, blendMode = 2500) {
		this.name = name, this.tracks = tracks, this.duration = duration, this.blendMode = blendMode, this.uuid = generateUUID(), this.duration < 0 && this.resetDuration()
	}
	static parse(json) {
		let tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1 / (json.fps || 1);
		for (let i = 0, n = jsonTracks.length; i !== n; ++i) tracks.push((function(json) {
			if (void 0 === json.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
			let trackType = function(typeName) {
				switch (typeName.toLowerCase()) {
					case "scalar":
					case "double":
					case "float":
					case "number":
					case "integer":
						return NumberKeyframeTrack;
					case "vector":
					case "vector2":
					case "vector3":
					case "vector4":
						return VectorKeyframeTrack;
					case "color":
						return ColorKeyframeTrack;
					case "quaternion":
						return QuaternionKeyframeTrack;
					case "bool":
					case "boolean":
						return BooleanKeyframeTrack;
					case "string":
						return StringKeyframeTrack
				}
				throw Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName)
			}(json.type);
			if (void 0 === json.times) {
				let times = [],
					values = [];
				flattenJSON(json.keys, times, values, "value"), json.times = times, json.values = values
			}
			return void 0 !== trackType.parse ? trackType.parse(json) : new trackType(json.name, json.times, json.values, json.interpolation)
		})(jsonTracks[i]).scale(frameTime));
		let clip = new this(json.name, json.duration, tracks, json.blendMode);
		return clip.uuid = json.uuid, clip
	}
	static toJSON(clip) {
		let tracks = [],
			clipTracks = clip.tracks,
			json = {
				name: clip.name,
				duration: clip.duration,
				tracks: tracks,
				uuid: clip.uuid,
				blendMode: clip.blendMode
			};
		for (let i = 0, n = clipTracks.length; i !== n; ++i) tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
		return json
	}
	static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
		let numMorphTargets = morphTargetSequence.length,
			tracks = [];
		for (let i = 0; i < numMorphTargets; i++) {
			let times = [],
				values = [];
			times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets), values.push(0, 1, 0);
			let order = function(times) {
				let n = times.length,
					result = Array(n);
				for (let i = 0; i !== n; ++i) result[i] = i;
				return result.sort(function(i, j) {
					return times[i] - times[j]
				}), result
			}(times);
			times = sortedArray(times, 1, order), values = sortedArray(values, 1, order), noLoop || 0 !== times[0] || (times.push(numMorphTargets), values.push(values[0])), tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps))
		}
		return new this(name, -1, tracks)
	}
	static findByName(objectOrClipArray, name) {
		let clipArray = objectOrClipArray;
		Array.isArray(objectOrClipArray) || (clipArray = objectOrClipArray.geometry && objectOrClipArray.geometry.animations || objectOrClipArray.animations);
		for (let i = 0; i < clipArray.length; i++)
			if (clipArray[i].name === name) return clipArray[i];
		return null
	}
	static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
		let animationToMorphTargets = {},
			pattern = /^([\w-]*?)([\d]+)$/;
		for (let i = 0, il = morphTargets.length; i < il; i++) {
			let morphTarget = morphTargets[i],
				parts = morphTarget.name.match(pattern);
			if (parts && parts.length > 1) {
				let name = parts[1],
					animationMorphTargets = animationToMorphTargets[name];
				animationMorphTargets || (animationToMorphTargets[name] = animationMorphTargets = []), animationMorphTargets.push(morphTarget)
			}
		}
		let clips = [];
		for (let name in animationToMorphTargets) clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
		return clips
	}
	static parseAnimation(animation, bones) {
		if (!animation) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
		let addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
				if (0 !== animationKeys.length) {
					let times = [],
						values = [];
					flattenJSON(animationKeys, times, values, propertyName), 0 !== times.length && destTracks.push(new trackType(trackName, times, values))
				}
			},
			tracks = [],
			clipName = animation.name || "default",
			fps = animation.fps || 30,
			blendMode = animation.blendMode,
			duration = animation.length || -1,
			hierarchyTracks = animation.hierarchy || [];
		for (let h = 0; h < hierarchyTracks.length; h++) {
			let animationKeys = hierarchyTracks[h].keys;
			if (animationKeys && 0 !== animationKeys.length) {
				if (animationKeys[0].morphTargets) {
					let k;
					let morphTargetNames = {};
					for (k = 0; k < animationKeys.length; k++)
						if (animationKeys[k].morphTargets)
							for (let m = 0; m < animationKeys[k].morphTargets.length; m++) morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
					for (let morphTargetName in morphTargetNames) {
						let times = [],
							values = [];
						for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
							let animationKey = animationKeys[k];
							times.push(animationKey.time), values.push(animationKey.morphTarget === morphTargetName ? 1 : 0)
						}
						tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values))
					}
					duration = morphTargetNames.length * fps
				} else {
					let boneName = ".bones[" + bones[h].name + "]";
					addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks), addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks), addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks)
				}
			}
		}
		return 0 === tracks.length ? null : new this(clipName, duration, tracks, blendMode)
	}
	resetDuration() {
		let tracks = this.tracks,
			duration = 0;
		for (let i = 0, n = tracks.length; i !== n; ++i) {
			let track = this.tracks[i];
			duration = Math.max(duration, track.times[track.times.length - 1])
		}
		return this.duration = duration, this
	}
	trim() {
		for (let i = 0; i < this.tracks.length; i++) this.tracks[i].trim(0, this.duration);
		return this
	}
	validate() {
		let valid = !0;
		for (let i = 0; i < this.tracks.length; i++) valid = valid && this.tracks[i].validate();
		return valid
	}
	optimize() {
		for (let i = 0; i < this.tracks.length; i++) this.tracks[i].optimize();
		return this
	}
	clone() {
		let tracks = [];
		for (let i = 0; i < this.tracks.length; i++) tracks.push(this.tracks[i].clone());
		return new this.constructor(this.name, this.duration, tracks, this.blendMode)
	}
	toJSON() {
		return this.constructor.toJSON(this)
	}
}
let Cache = {
	enabled: !1,
	files: {},
	add: function(key, file) {
		!1 !== this.enabled && (this.files[key] = file)
	},
	get: function(key) {
		if (!1 !== this.enabled) return this.files[key]
	},
	remove: function(key) {
		delete this.files[key]
	},
	clear: function() {
		this.files = {}
	}
};
class LoadingManager {
	constructor(onLoad, onProgress, onError) {
		let urlModifier;
		let scope = this,
			isLoading = !1,
			itemsLoaded = 0,
			itemsTotal = 0,
			handlers = [];
		this.onStart = void 0, this.onLoad = onLoad, this.onProgress = onProgress, this.onError = onError, this.itemStart = function(url) {
			itemsTotal++, !1 === isLoading && void 0 !== scope.onStart && scope.onStart(url, itemsLoaded, itemsTotal), isLoading = !0
		}, this.itemEnd = function(url) {
			itemsLoaded++, void 0 !== scope.onProgress && scope.onProgress(url, itemsLoaded, itemsTotal), itemsLoaded === itemsTotal && (isLoading = !1, void 0 !== scope.onLoad && scope.onLoad())
		}, this.itemError = function(url) {
			void 0 !== scope.onError && scope.onError(url)
		}, this.resolveURL = function(url) {
			return urlModifier ? urlModifier(url) : url
		}, this.setURLModifier = function(transform) {
			return urlModifier = transform, this
		}, this.addHandler = function(regex, loader) {
			return handlers.push(regex, loader), this
		}, this.removeHandler = function(regex) {
			let index = handlers.indexOf(regex);
			return -1 !== index && handlers.splice(index, 2), this
		}, this.getHandler = function(file) {
			for (let i = 0, l = handlers.length; i < l; i += 2) {
				let regex = handlers[i],
					loader = handlers[i + 1];
				if (regex.global && (regex.lastIndex = 0), regex.test(file)) return loader
			}
			return null
		}
	}
}
let DefaultLoadingManager = new LoadingManager;
class Loader {
	constructor(manager) {
		this.manager = void 0 !== manager ? manager : DefaultLoadingManager, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
	}
	load() {}
	loadAsync(url, onProgress) {
		let scope = this;
		return new Promise(function(resolve, reject) {
			scope.load(url, resolve, onProgress, reject)
		})
	}
	parse() {}
	setCrossOrigin(crossOrigin) {
		return this.crossOrigin = crossOrigin, this
	}
	setWithCredentials(value) {
		return this.withCredentials = value, this
	}
	setPath(path) {
		return this.path = path, this
	}
	setResourcePath(resourcePath) {
		return this.resourcePath = resourcePath, this
	}
	setRequestHeader(requestHeader) {
		return this.requestHeader = requestHeader, this
	}
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
let loading = {};
class HttpError extends Error {
	constructor(message, response) {
		super(message), this.response = response
	}
}
class FileLoader extends Loader {
	constructor(manager) {
		super(manager)
	}
	load(url, onLoad, onProgress, onError) {
		void 0 === url && (url = ""), void 0 !== this.path && (url = this.path + url), url = this.manager.resolveURL(url);
		let cached = Cache.get(url);
		if (void 0 !== cached) return this.manager.itemStart(url), setTimeout(() => {
			onLoad && onLoad(cached), this.manager.itemEnd(url)
		}, 0), cached;
		if (void 0 !== loading[url]) {
			loading[url].push({
				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError
			});
			return
		}
		loading[url] = [], loading[url].push({
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError
		});
		let req = new Request(url, {
				headers: new Headers(this.requestHeader),
				credentials: this.withCredentials ? "include" : "same-origin"
			}),
			mimeType = this.mimeType,
			responseType = this.responseType;
		fetch(req).then(response => {
			if (200 === response.status || 0 === response.status) {
				if (0 === response.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === response.body || void 0 === response.body.getReader) return response;
				let callbacks = loading[url],
					reader = response.body.getReader(),
					contentLength = response.headers.get("Content-Length") || response.headers.get("X-File-Size"),
					total = contentLength ? parseInt(contentLength) : 0,
					lengthComputable = 0 !== total,
					loaded = 0;
				return new Response(new ReadableStream({
					start(controller) {
						(function readData() {
							reader.read().then(({
								done,
								value
							}) => {
								if (done) controller.close();
								else {
									let event = new ProgressEvent("progress", {
										lengthComputable,
										loaded: loaded += value.byteLength,
										total
									});
									for (let i = 0, il = callbacks.length; i < il; i++) {
										let callback = callbacks[i];
										callback.onProgress && callback.onProgress(event)
									}
									controller.enqueue(value), readData()
								}
							})
						})()
					}
				}))
			}
			throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response)
		}).then(response => {
			switch (responseType) {
				case "arraybuffer":
					return response.arrayBuffer();
				case "blob":
					return response.blob();
				case "document":
					return response.text().then(text => new DOMParser().parseFromString(text, mimeType));
				case "json":
					return response.json();
				default:
					if (void 0 === mimeType) return response.text();
					{
						let exec = /charset="?([^;"\s]*)"?/i.exec(mimeType),
							decoder = new TextDecoder(exec && exec[1] ? exec[1].toLowerCase() : void 0);
						return response.arrayBuffer().then(ab => decoder.decode(ab))
					}
			}
		}).then(data => {
			Cache.add(url, data);
			let callbacks = loading[url];
			delete loading[url];
			for (let i = 0, il = callbacks.length; i < il; i++) {
				let callback = callbacks[i];
				callback.onLoad && callback.onLoad(data)
			}
		}).catch(err => {
			let callbacks = loading[url];
			if (void 0 === callbacks) throw this.manager.itemError(url), err;
			delete loading[url];
			for (let i = 0, il = callbacks.length; i < il; i++) {
				let callback = callbacks[i];
				callback.onError && callback.onError(err)
			}
			this.manager.itemError(url)
		}).finally(() => {
			this.manager.itemEnd(url)
		}), this.manager.itemStart(url)
	}
	setResponseType(value) {
		return this.responseType = value, this
	}
	setMimeType(value) {
		return this.mimeType = value, this
	}
}
class ImageLoader extends Loader {
	constructor(manager) {
		super(manager)
	}
	load(url, onLoad, onProgress, onError) {
		void 0 !== this.path && (url = this.path + url), url = this.manager.resolveURL(url);
		let scope = this,
			cached = Cache.get(url);
		if (void 0 !== cached) return scope.manager.itemStart(url), setTimeout(function() {
			onLoad && onLoad(cached), scope.manager.itemEnd(url)
		}, 0), cached;
		let image = createElementNS("img");

		function onImageLoad() {
			removeEventListeners(), Cache.add(url, this), onLoad && onLoad(this), scope.manager.itemEnd(url)
		}

		function onImageError(event) {
			removeEventListeners(), onError && onError(event), scope.manager.itemError(url), scope.manager.itemEnd(url)
		}

		function removeEventListeners() {
			image.removeEventListener("load", onImageLoad, !1), image.removeEventListener("error", onImageError, !1)
		}
		return image.addEventListener("load", onImageLoad, !1), image.addEventListener("error", onImageError, !1), "data:" !== url.slice(0, 5) && void 0 !== this.crossOrigin && (image.crossOrigin = this.crossOrigin), scope.manager.itemStart(url), image.src = url, image
	}
}
class DataTextureLoader extends Loader {
	constructor(manager) {
		super(manager)
	}
	load(url, onLoad, onProgress, onError) {
		let scope = this,
			texture = new DataTexture,
			loader = new FileLoader(this.manager);
		return loader.setResponseType("arraybuffer"), loader.setRequestHeader(this.requestHeader), loader.setPath(this.path), loader.setWithCredentials(scope.withCredentials), loader.load(url, function(buffer) {
			let texData;
			try {
				texData = scope.parse(buffer)
			} catch (error) {
				if (void 0 !== onError) onError(error);
				else {
					console.error(error);
					return
				}
			}
			void 0 !== texData.image ? texture.image = texData.image : void 0 !== texData.data && (texture.image.width = texData.width, texture.image.height = texData.height, texture.image.data = texData.data), texture.wrapS = void 0 !== texData.wrapS ? texData.wrapS : 1001, texture.wrapT = void 0 !== texData.wrapT ? texData.wrapT : 1001, texture.magFilter = void 0 !== texData.magFilter ? texData.magFilter : 1006, texture.minFilter = void 0 !== texData.minFilter ? texData.minFilter : 1006, texture.anisotropy = void 0 !== texData.anisotropy ? texData.anisotropy : 1, void 0 !== texData.colorSpace ? texture.colorSpace = texData.colorSpace : void 0 !== texData.encoding && (texture.encoding = texData.encoding), void 0 !== texData.flipY && (texture.flipY = texData.flipY), void 0 !== texData.format && (texture.format = texData.format), void 0 !== texData.type && (texture.type = texData.type), void 0 !== texData.mipmaps && (texture.mipmaps = texData.mipmaps, texture.minFilter = 1008), 1 === texData.mipmapCount && (texture.minFilter = 1006), void 0 !== texData.generateMipmaps && (texture.generateMipmaps = texData.generateMipmaps), texture.needsUpdate = !0, onLoad && onLoad(texture, texData)
		}, onProgress, onError), texture
	}
}
class TextureLoader extends Loader {
	constructor(manager) {
		super(manager)
	}
	load(url, onLoad, onProgress, onError) {
		let texture = new Texture$1,
			loader = new ImageLoader(this.manager);
		return loader.setCrossOrigin(this.crossOrigin), loader.setPath(this.path), loader.load(url, function(image) {
			texture.image = image, texture.needsUpdate = !0, void 0 !== onLoad && onLoad(texture)
		}, onProgress, onError), texture
	}
}
class Light extends Object3D {
	constructor(color, intensity = 1) {
		super(), this.isLight = !0, this.type = "Light", this.color = new Color(color), this.intensity = intensity
	}
	dispose() {}
	copy(source, recursive) {
		return super.copy(source, recursive), this.color.copy(source.color), this.intensity = source.intensity, this
	}
	toJSON(meta) {
		let data = super.toJSON(meta);
		return data.object.color = this.color.getHex(), data.object.intensity = this.intensity, void 0 !== this.groundColor && (data.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (data.object.distance = this.distance), void 0 !== this.angle && (data.object.angle = this.angle), void 0 !== this.decay && (data.object.decay = this.decay), void 0 !== this.penumbra && (data.object.penumbra = this.penumbra), void 0 !== this.shadow && (data.object.shadow = this.shadow.toJSON()), data
	}
}
let _projScreenMatrix$1 = new Matrix4,
	_lightPositionWorld$1 = new Vector3,
	_lookTarget$1 = new Vector3;
class LightShadow {
	constructor(camera) {
		this.camera = camera, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Vector2(512, 512), this.map = null, this.mapPass = null, this.matrix = new Matrix4, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Frustum, this._frameExtents = new Vector2(1, 1), this._viewportCount = 1, this._viewports = [new Vector4(0, 0, 1, 1)]
	}
	getViewportCount() {
		return this._viewportCount
	}
	getFrustum() {
		return this._frustum
	}
	updateMatrices(light) {
		let shadowCamera = this.camera,
			shadowMatrix = this.matrix;
		_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld), shadowCamera.position.copy(_lightPositionWorld$1), _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld), shadowCamera.lookAt(_lookTarget$1), shadowCamera.updateMatrixWorld(), _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix$1), shadowMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), shadowMatrix.multiply(_projScreenMatrix$1)
	}
	getViewport(viewportIndex) {
		return this._viewports[viewportIndex]
	}
	getFrameExtents() {
		return this._frameExtents
	}
	dispose() {
		this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
	}
	copy(source) {
		return this.camera = source.camera.clone(), this.bias = source.bias, this.radius = source.radius, this.mapSize.copy(source.mapSize), this
	}
	clone() {
		return new this.constructor().copy(this)
	}
	toJSON() {
		let object = {};
		return 0 !== this.bias && (object.bias = this.bias), 0 !== this.normalBias && (object.normalBias = this.normalBias), 1 !== this.radius && (object.radius = this.radius), (512 !== this.mapSize.x || 512 !== this.mapSize.y) && (object.mapSize = this.mapSize.toArray()), object.camera = this.camera.toJSON(!1).object, delete object.camera.matrix, object
	}
}
class SpotLightShadow extends LightShadow {
	constructor() {
		super(new PerspectiveCamera(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
	}
	updateMatrices(light) {
		let camera = this.camera,
			fov = 2 * RAD2DEG * light.angle * this.focus,
			aspect = this.mapSize.width / this.mapSize.height,
			far = light.distance || camera.far;
		(fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) && (camera.fov = fov, camera.aspect = aspect, camera.far = far, camera.updateProjectionMatrix()), super.updateMatrices(light)
	}
	copy(source) {
		return super.copy(source), this.focus = source.focus, this
	}
}
class SpotLight extends Light {
	constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
		super(color, intensity), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D, this.distance = distance, this.angle = angle, this.penumbra = penumbra, this.decay = decay, this.map = null, this.shadow = new SpotLightShadow
	}
	get power() {
		return this.intensity * Math.PI
	}
	set power(power) {
		this.intensity = power / Math.PI
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.distance = source.distance, this.angle = source.angle, this.penumbra = source.penumbra, this.decay = source.decay, this.target = source.target.clone(), this.shadow = source.shadow.clone(), this
	}
}
let _projScreenMatrix = new Matrix4,
	_lightPositionWorld = new Vector3,
	_lookTarget = new Vector3;
class PointLightShadow extends LightShadow {
	constructor() {
		super(new PerspectiveCamera(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Vector2(4, 2), this._viewportCount = 6, this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)], this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)], this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)]
	}
	updateMatrices(light, viewportIndex = 0) {
		let camera = this.camera,
			shadowMatrix = this.matrix,
			far = light.distance || camera.far;
		far !== camera.far && (camera.far = far, camera.updateProjectionMatrix()), _lightPositionWorld.setFromMatrixPosition(light.matrixWorld), camera.position.copy(_lightPositionWorld), _lookTarget.copy(camera.position), _lookTarget.add(this._cubeDirections[viewportIndex]), camera.up.copy(this._cubeUps[viewportIndex]), camera.lookAt(_lookTarget), camera.updateMatrixWorld(), shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z), _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse), this._frustum.setFromProjectionMatrix(_projScreenMatrix)
	}
}
class PointLight extends Light {
	constructor(color, intensity, distance = 0, decay = 2) {
		super(color, intensity), this.isPointLight = !0, this.type = "PointLight", this.distance = distance, this.decay = decay, this.shadow = new PointLightShadow
	}
	get power() {
		return 4 * this.intensity * Math.PI
	}
	set power(power) {
		this.intensity = power / (4 * Math.PI)
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.distance = source.distance, this.decay = source.decay, this.shadow = source.shadow.clone(), this
	}
}
class DirectionalLightShadow extends LightShadow {
	constructor() {
		super(new OrthographicCamera(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
	}
}
class DirectionalLight extends Light {
	constructor(color, intensity) {
		super(color, intensity), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Object3D.DEFAULT_UP), this.updateMatrix(), this.target = new Object3D, this.shadow = new DirectionalLightShadow
	}
	dispose() {
		this.shadow.dispose()
	}
	copy(source) {
		return super.copy(source), this.target = source.target.clone(), this.shadow = source.shadow.clone(), this
	}
}
class SphericalHarmonics3 {
	constructor() {
		this.isSphericalHarmonics3 = !0, this.coefficients = [];
		for (let i = 0; i < 9; i++) this.coefficients.push(new Vector3)
	}
	set(coefficients) {
		for (let i = 0; i < 9; i++) this.coefficients[i].copy(coefficients[i]);
		return this
	}
	zero() {
		for (let i = 0; i < 9; i++) this.coefficients[i].set(0, 0, 0);
		return this
	}
	getAt(normal, target) {
		let x = normal.x,
			y = normal.y,
			z = normal.z,
			coeff = this.coefficients;
		return target.copy(coeff[0]).multiplyScalar(.282095), target.addScaledVector(coeff[1], .488603 * y), target.addScaledVector(coeff[2], .488603 * z), target.addScaledVector(coeff[3], .488603 * x), target.addScaledVector(coeff[4], x * y * 1.092548), target.addScaledVector(coeff[5], y * z * 1.092548), target.addScaledVector(coeff[6], .315392 * (3 * z * z - 1)), target.addScaledVector(coeff[7], x * z * 1.092548), target.addScaledVector(coeff[8], .546274 * (x * x - y * y)), target
	}
	getIrradianceAt(normal, target) {
		let x = normal.x,
			y = normal.y,
			z = normal.z,
			coeff = this.coefficients;
		return target.copy(coeff[0]).multiplyScalar(.886227), target.addScaledVector(coeff[1], 1.023328 * y), target.addScaledVector(coeff[2], 1.023328 * z), target.addScaledVector(coeff[3], 1.023328 * x), target.addScaledVector(coeff[4], .858086 * x * y), target.addScaledVector(coeff[5], .858086 * y * z), target.addScaledVector(coeff[6], .743125 * z * z - .247708), target.addScaledVector(coeff[7], .858086 * x * z), target.addScaledVector(coeff[8], .429043 * (x * x - y * y)), target
	}
	add(sh) {
		for (let i = 0; i < 9; i++) this.coefficients[i].add(sh.coefficients[i]);
		return this
	}
	addScaledSH(sh, s) {
		for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(sh.coefficients[i], s);
		return this
	}
	scale(s) {
		for (let i = 0; i < 9; i++) this.coefficients[i].multiplyScalar(s);
		return this
	}
	lerp(sh, alpha) {
		for (let i = 0; i < 9; i++) this.coefficients[i].lerp(sh.coefficients[i], alpha);
		return this
	}
	equals(sh) {
		for (let i = 0; i < 9; i++)
			if (!this.coefficients[i].equals(sh.coefficients[i])) return !1;
		return !0
	}
	copy(sh) {
		return this.set(sh.coefficients)
	}
	clone() {
		return new this.constructor().copy(this)
	}
	fromArray(array, offset = 0) {
		let coefficients = this.coefficients;
		for (let i = 0; i < 9; i++) coefficients[i].fromArray(array, offset + 3 * i);
		return this
	}
	toArray(array = [], offset = 0) {
		let coefficients = this.coefficients;
		for (let i = 0; i < 9; i++) coefficients[i].toArray(array, offset + 3 * i);
		return array
	}
	static getBasisAt(normal, shBasis) {
		let x = normal.x,
			y = normal.y,
			z = normal.z;
		shBasis[0] = .282095, shBasis[1] = .488603 * y, shBasis[2] = .488603 * z, shBasis[3] = .488603 * x, shBasis[4] = 1.092548 * x * y, shBasis[5] = 1.092548 * y * z, shBasis[6] = .315392 * (3 * z * z - 1), shBasis[7] = 1.092548 * x * z, shBasis[8] = .546274 * (x * x - y * y)
	}
}
class LightProbe extends Light {
	constructor(sh = new SphericalHarmonics3, intensity = 1) {
		super(void 0, intensity), this.isLightProbe = !0, this.sh = sh
	}
	copy(source) {
		return super.copy(source), this.sh.copy(source.sh), this
	}
	fromJSON(json) {
		return this.intensity = json.intensity, this.sh.fromArray(json.sh), this
	}
	toJSON(meta) {
		let data = super.toJSON(meta);
		return data.object.sh = this.sh.toArray(), data
	}
}
class LoaderUtils {
	static decodeText(array) {
		if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(array);
		let s = "";
		for (let i = 0, il = array.length; i < il; i++) s += String.fromCharCode(array[i]);
		try {
			return decodeURIComponent(escape(s))
		} catch (e) {
			return s
		}
	}
	static extractUrlBase(url) {
		let index = url.lastIndexOf("/");
		return -1 === index ? "./" : url.slice(0, index + 1)
	}
	static resolveURL(url, path) {
		return "string" != typeof url || "" === url ? "" : (/^https?:\/\//i.test(path) && /^\//.test(url) && (path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(url) || /^data:.*,.*$/i.test(url) || /^blob:.*$/i.test(url)) ? url : path + url
	}
}
class ImageBitmapLoader extends Loader {
	constructor(manager) {
		super(manager), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
			premultiplyAlpha: "none"
		}
	}
	setOptions(options) {
		return this.options = options, this
	}
	load(url, onLoad, onProgress, onError) {
		void 0 === url && (url = ""), void 0 !== this.path && (url = this.path + url), url = this.manager.resolveURL(url);
		let scope = this,
			cached = Cache.get(url);
		if (void 0 !== cached) {
			if (scope.manager.itemStart(url), cached.then) {
				cached.then(imageBitmap => {
					onLoad && onLoad(imageBitmap), scope.manager.itemEnd(url)
				}).catch(e => {
					onError && onError(e)
				});
				return
			}
			return setTimeout(function() {
				onLoad && onLoad(cached), scope.manager.itemEnd(url)
			}, 0), cached
		}
		let fetchOptions = {};
		fetchOptions.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", fetchOptions.headers = this.requestHeader;
		let promise = fetch(url, fetchOptions).then(function(res) {
			return res.blob()
		}).then(function(blob) {
			return createImageBitmap(blob, Object.assign(scope.options, {
				colorSpaceConversion: "none"
			}))
		}).then(function(imageBitmap) {
			return Cache.add(url, imageBitmap), onLoad && onLoad(imageBitmap), scope.manager.itemEnd(url), imageBitmap
		}).catch(function(e) {
			onError && onError(e), Cache.remove(url), scope.manager.itemError(url), scope.manager.itemEnd(url)
		});
		Cache.add(url, promise), scope.manager.itemStart(url)
	}
}
class PropertyMixer {
	constructor(binding, typeName, valueSize) {
		let mixFunction, mixFunctionAdditive, setIdentity;
		switch (this.binding = binding, this.valueSize = valueSize, typeName) {
			case "quaternion":
				mixFunction = this._slerp, mixFunctionAdditive = this._slerpAdditive, setIdentity = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * valueSize), this._workIndex = 5;
				break;
			case "string":
			case "bool":
				mixFunction = this._select, mixFunctionAdditive = this._select, setIdentity = this._setAdditiveIdentityOther, this.buffer = Array(5 * valueSize);
				break;
			default:
				mixFunction = this._lerp, mixFunctionAdditive = this._lerpAdditive, setIdentity = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * valueSize)
		}
		this._mixBufferRegion = mixFunction, this._mixBufferRegionAdditive = mixFunctionAdditive, this._setIdentity = setIdentity, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
	}
	accumulate(accuIndex, weight) {
		let buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride,
			currentWeight = this.cumulativeWeight;
		if (0 === currentWeight) {
			for (let i = 0; i !== stride; ++i) buffer[offset + i] = buffer[i];
			currentWeight = weight
		} else {
			currentWeight += weight;
			let mix = weight / currentWeight;
			this._mixBufferRegion(buffer, offset, 0, mix, stride)
		}
		this.cumulativeWeight = currentWeight
	}
	accumulateAdditive(weight) {
		let buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;
		0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride), this.cumulativeWeightAdditive += weight
	}
	apply(accuIndex) {
		let stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,
			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,
			binding = this.binding;
		if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, weight < 1) {
			let originalValueOffset = stride * this._origIndex;
			this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride)
		}
		weightAdditive > 0 && this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
		for (let i = stride, e = stride + stride; i !== e; ++i)
			if (buffer[i] !== buffer[i + stride]) {
				binding.setValue(buffer, offset);
				break
			}
	}
	saveOriginalState() {
		let binding = this.binding,
			buffer = this.buffer,
			stride = this.valueSize,
			originalValueOffset = stride * this._origIndex;
		binding.getValue(buffer, originalValueOffset);
		for (let i = stride; i !== originalValueOffset; ++i) buffer[i] = buffer[originalValueOffset + i % stride];
		this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
	}
	restoreOriginalState() {
		let originalValueOffset = 3 * this.valueSize;
		this.binding.setValue(this.buffer, originalValueOffset)
	}
	_setAdditiveIdentityNumeric() {
		let startIndex = this._addIndex * this.valueSize,
			endIndex = startIndex + this.valueSize;
		for (let i = startIndex; i < endIndex; i++) this.buffer[i] = 0
	}
	_setAdditiveIdentityQuaternion() {
		this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
	}
	_setAdditiveIdentityOther() {
		let startIndex = this._origIndex * this.valueSize,
			targetIndex = this._addIndex * this.valueSize;
		for (let i = 0; i < this.valueSize; i++) this.buffer[targetIndex + i] = this.buffer[startIndex + i]
	}
	_select(buffer, dstOffset, srcOffset, t, stride) {
		if (t >= .5)
			for (let i = 0; i !== stride; ++i) buffer[dstOffset + i] = buffer[srcOffset + i]
	}
	_slerp(buffer, dstOffset, srcOffset, t) {
		Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t)
	}
	_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
		let workOffset = this._workIndex * stride;
		Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset), Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t)
	}
	_lerp(buffer, dstOffset, srcOffset, t, stride) {
		let s = 1 - t;
		for (let i = 0; i !== stride; ++i) {
			let j = dstOffset + i;
			buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t
		}
	}
	_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
		for (let i = 0; i !== stride; ++i) {
			let j = dstOffset + i;
			buffer[j] = buffer[j] + buffer[srcOffset + i] * t
		}
	}
}
let _RESERVED_CHARS_RE = "\\[\\]\\.:\\/",
	_reservedRe = RegExp("[" + _RESERVED_CHARS_RE + "]", "g"),
	_wordChar = "[^" + _RESERVED_CHARS_RE + "]",
	_wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]",
	_directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar),
	_trackRe = RegExp("^" + _directoryRe + /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar) + "$"),
	_supportedObjectNames = ["material", "materials", "bones", "map"];
class PropertyBinding {
	constructor(rootNode, path, parsedPath) {
		this.path = path, this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path), this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName), this.rootNode = rootNode, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
	}
	static create(root, path, parsedPath) {
		return root && root.isAnimationObjectGroup ? new PropertyBinding.Composite(root, path, parsedPath) : new PropertyBinding(root, path, parsedPath)
	}
	static sanitizeNodeName(name) {
		return name.replace(/\s/g, "_").replace(_reservedRe, "")
	}
	static parseTrackName(trackName) {
		let matches = _trackRe.exec(trackName);
		if (null === matches) throw Error("PropertyBinding: Cannot parse trackName: " + trackName);
		let results = {
				nodeName: matches[2],
				objectName: matches[3],
				objectIndex: matches[4],
				propertyName: matches[5],
				propertyIndex: matches[6]
			},
			lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
		if (void 0 !== lastDot && -1 !== lastDot) {
			let objectName = results.nodeName.substring(lastDot + 1); - 1 !== _supportedObjectNames.indexOf(objectName) && (results.nodeName = results.nodeName.substring(0, lastDot), results.objectName = objectName)
		}
		if (null === results.propertyName || 0 === results.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
		return results
	}
	static findNode(root, nodeName) {
		if (void 0 === nodeName || "" === nodeName || "." === nodeName || -1 === nodeName || nodeName === root.name || nodeName === root.uuid) return root;
		if (root.skeleton) {
			let bone = root.skeleton.getBoneByName(nodeName);
			if (void 0 !== bone) return bone
		}
		if (root.children) {
			let searchNodeSubtree = function(children) {
					for (let i = 0; i < children.length; i++) {
						let childNode = children[i];
						if (childNode.name === nodeName || childNode.uuid === nodeName) return childNode;
						let result = searchNodeSubtree(childNode.children);
						if (result) return result
					}
					return null
				},
				subTreeNode = searchNodeSubtree(root.children);
			if (subTreeNode) return subTreeNode
		}
		return null
	}
	_getValue_unavailable() {}
	_setValue_unavailable() {}
	_getValue_direct(buffer, offset) {
		buffer[offset] = this.targetObject[this.propertyName]
	}
	_getValue_array(buffer, offset) {
		let source = this.resolvedProperty;
		for (let i = 0, n = source.length; i !== n; ++i) buffer[offset++] = source[i]
	}
	_getValue_arrayElement(buffer, offset) {
		buffer[offset] = this.resolvedProperty[this.propertyIndex]
	}
	_getValue_toArray(buffer, offset) {
		this.resolvedProperty.toArray(buffer, offset)
	}
	_setValue_direct(buffer, offset) {
		this.targetObject[this.propertyName] = buffer[offset]
	}
	_setValue_direct_setNeedsUpdate(buffer, offset) {
		this.targetObject[this.propertyName] = buffer[offset], this.targetObject.needsUpdate = !0
	}
	_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
		this.targetObject[this.propertyName] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_setValue_array(buffer, offset) {
		let dest = this.resolvedProperty;
		for (let i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++]
	}
	_setValue_array_setNeedsUpdate(buffer, offset) {
		let dest = this.resolvedProperty;
		for (let i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
		this.targetObject.needsUpdate = !0
	}
	_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
		let dest = this.resolvedProperty;
		for (let i = 0, n = dest.length; i !== n; ++i) dest[i] = buffer[offset++];
		this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_setValue_arrayElement(buffer, offset) {
		this.resolvedProperty[this.propertyIndex] = buffer[offset]
	}
	_setValue_arrayElement_setNeedsUpdate(buffer, offset) {
		this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.needsUpdate = !0
	}
	_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
		this.resolvedProperty[this.propertyIndex] = buffer[offset], this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_setValue_fromArray(buffer, offset) {
		this.resolvedProperty.fromArray(buffer, offset)
	}
	_setValue_fromArray_setNeedsUpdate(buffer, offset) {
		this.resolvedProperty.fromArray(buffer, offset), this.targetObject.needsUpdate = !0
	}
	_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
		this.resolvedProperty.fromArray(buffer, offset), this.targetObject.matrixWorldNeedsUpdate = !0
	}
	_getValue_unbound(targetArray, offset) {
		this.bind(), this.getValue(targetArray, offset)
	}
	_setValue_unbound(sourceArray, offset) {
		this.bind(), this.setValue(sourceArray, offset)
	}
	bind() {
		let targetObject = this.node,
			parsedPath = this.parsedPath,
			objectName = parsedPath.objectName,
			propertyName = parsedPath.propertyName,
			propertyIndex = parsedPath.propertyIndex;
		if (targetObject || (targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName), this.node = targetObject), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !targetObject) {
			console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
			return
		}
		if (objectName) {
			let objectIndex = parsedPath.objectIndex;
			switch (objectName) {
				case "materials":
					if (!targetObject.material) {
						console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
						return
					}
					if (!targetObject.material.materials) {
						console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
						return
					}
					targetObject = targetObject.material.materials;
					break;
				case "bones":
					if (!targetObject.skeleton) {
						console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
						return
					}
					targetObject = targetObject.skeleton.bones;
					for (let i = 0; i < targetObject.length; i++)
						if (targetObject[i].name === objectIndex) {
							objectIndex = i;
							break
						} break;
				case "map":
					if ("map" in targetObject) {
						targetObject = targetObject.map;
						break
					}
					if (!targetObject.material) {
						console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
						return
					}
					if (!targetObject.material.map) {
						console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
						return
					}
					targetObject = targetObject.material.map;
					break;
				default:
					if (void 0 === targetObject[objectName]) {
						console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
						return
					}
					targetObject = targetObject[objectName]
			}
			if (void 0 !== objectIndex) {
				if (void 0 === targetObject[objectIndex]) {
					console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
					return
				}
				targetObject = targetObject[objectIndex]
			}
		}
		let nodeProperty = targetObject[propertyName];
		if (void 0 === nodeProperty) {
			console.error("THREE.PropertyBinding: Trying to update property for track: " + parsedPath.nodeName + "." + propertyName + " but it wasn't found.", targetObject);
			return
		}
		let versioning = this.Versioning.None;
		this.targetObject = targetObject, void 0 !== targetObject.needsUpdate ? versioning = this.Versioning.NeedsUpdate : void 0 !== targetObject.matrixWorldNeedsUpdate && (versioning = this.Versioning.MatrixWorldNeedsUpdate);
		let bindingType = this.BindingType.Direct;
		if (void 0 !== propertyIndex) {
			if ("morphTargetInfluences" === propertyName) {
				if (!targetObject.geometry) {
					console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
					return
				}
				if (!targetObject.geometry.morphAttributes) {
					console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
					return
				}
				void 0 !== targetObject.morphTargetDictionary[propertyIndex] && (propertyIndex = targetObject.morphTargetDictionary[propertyIndex])
			}
			bindingType = this.BindingType.ArrayElement, this.resolvedProperty = nodeProperty, this.propertyIndex = propertyIndex
		} else void 0 !== nodeProperty.fromArray && void 0 !== nodeProperty.toArray ? (bindingType = this.BindingType.HasFromToArray, this.resolvedProperty = nodeProperty) : Array.isArray(nodeProperty) ? (bindingType = this.BindingType.EntireArray, this.resolvedProperty = nodeProperty) : this.propertyName = propertyName;
		this.getValue = this.GetterByBindingType[bindingType], this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning]
	}
	unbind() {
		this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
	}
}
PropertyBinding.Composite = class {
	constructor(targetGroup, path, optionalParsedPath) {
		let parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
		this._targetGroup = targetGroup, this._bindings = targetGroup.subscribe_(path, parsedPath)
	}
	getValue(array, offset) {
		this.bind();
		let firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[firstValidIndex];
		void 0 !== binding && binding.getValue(array, offset)
	}
	setValue(array, offset) {
		let bindings = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].setValue(array, offset)
	}
	bind() {
		let bindings = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].bind()
	}
	unbind() {
		let bindings = this._bindings;
		for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) bindings[i].unbind()
	}
}, PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
}, PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
}, PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray], PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
	[PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
	[PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],
	[PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
	[PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class AnimationAction {
	constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
		this._mixer = mixer, this._clip = clip, this._localRoot = localRoot, this.blendMode = blendMode;
		let tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = Array(nTracks),
			interpolantSettings = {
				endingStart: 2400,
				endingEnd: 2400
			};
		for (let i = 0; i !== nTracks; ++i) {
			let interpolant = tracks[i].createInterpolant(null);
			interpolants[i] = interpolant, interpolant.settings = interpolantSettings
		}
		this._interpolantSettings = interpolantSettings, this._interpolants = interpolants, this._propertyBindings = Array(nTracks), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
	}
	play() {
		return this._mixer._activateAction(this), this
	}
	stop() {
		return this._mixer._deactivateAction(this), this.reset()
	}
	reset() {
		return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
	}
	isRunning() {
		return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
	}
	isScheduled() {
		return this._mixer._isActiveAction(this)
	}
	startAt(time) {
		return this._startTime = time, this
	}
	setLoop(mode, repetitions) {
		return this.loop = mode, this.repetitions = repetitions, this
	}
	setEffectiveWeight(weight) {
		return this.weight = weight, this._effectiveWeight = this.enabled ? weight : 0, this.stopFading()
	}
	getEffectiveWeight() {
		return this._effectiveWeight
	}
	fadeIn(duration) {
		return this._scheduleFading(duration, 0, 1)
	}
	fadeOut(duration) {
		return this._scheduleFading(duration, 1, 0)
	}
	crossFadeFrom(fadeOutAction, duration, warp) {
		if (fadeOutAction.fadeOut(duration), this.fadeIn(duration), warp) {
			let fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration;
			fadeOutAction.warp(1, fadeOutDuration / fadeInDuration, duration), this.warp(fadeInDuration / fadeOutDuration, 1, duration)
		}
		return this
	}
	crossFadeTo(fadeInAction, duration, warp) {
		return fadeInAction.crossFadeFrom(this, duration, warp)
	}
	stopFading() {
		let weightInterpolant = this._weightInterpolant;
		return null !== weightInterpolant && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(weightInterpolant)), this
	}
	setEffectiveTimeScale(timeScale) {
		return this.timeScale = timeScale, this._effectiveTimeScale = this.paused ? 0 : timeScale, this.stopWarping()
	}
	getEffectiveTimeScale() {
		return this._effectiveTimeScale
	}
	setDuration(duration) {
		return this.timeScale = this._clip.duration / duration, this.stopWarping()
	}
	syncWith(action) {
		return this.time = action.time, this.timeScale = action.timeScale, this.stopWarping()
	}
	halt(duration) {
		return this.warp(this._effectiveTimeScale, 0, duration)
	}
	warp(startTimeScale, endTimeScale, duration) {
		let mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale,
			interpolant = this._timeScaleInterpolant;
		null === interpolant && (interpolant = mixer._lendControlInterpolant(), this._timeScaleInterpolant = interpolant);
		let times = interpolant.parameterPositions,
			values = interpolant.sampleValues;
		return times[0] = now, times[1] = now + duration, values[0] = startTimeScale / timeScale, values[1] = endTimeScale / timeScale, this
	}
	stopWarping() {
		let timeScaleInterpolant = this._timeScaleInterpolant;
		return null !== timeScaleInterpolant && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(timeScaleInterpolant)), this
	}
	getMixer() {
		return this._mixer
	}
	getClip() {
		return this._clip
	}
	getRoot() {
		return this._localRoot || this._mixer._root
	}
	_update(time, deltaTime, timeDirection, accuIndex) {
		if (!this.enabled) {
			this._updateWeight(time);
			return
		}
		let startTime = this._startTime;
		if (null !== startTime) {
			let timeRunning = (time - startTime) * timeDirection;
			timeRunning < 0 || 0 === timeDirection ? deltaTime = 0 : (this._startTime = null, deltaTime = timeDirection * timeRunning)
		}
		deltaTime *= this._updateTimeScale(time);
		let clipTime = this._updateTime(deltaTime),
			weight = this._updateWeight(time);
		if (weight > 0) {
			let interpolants = this._interpolants,
				propertyMixers = this._propertyBindings;
			if (2501 === this.blendMode)
				for (let j = 0, m = interpolants.length; j !== m; ++j) interpolants[j].evaluate(clipTime), propertyMixers[j].accumulateAdditive(weight);
			else
				for (let j = 0, m = interpolants.length; j !== m; ++j) interpolants[j].evaluate(clipTime), propertyMixers[j].accumulate(accuIndex, weight)
		}
	}
	_updateWeight(time) {
		let weight = 0;
		if (this.enabled) {
			weight = this.weight;
			let interpolant = this._weightInterpolant;
			if (null !== interpolant) {
				let interpolantValue = interpolant.evaluate(time)[0];
				weight *= interpolantValue, time > interpolant.parameterPositions[1] && (this.stopFading(), 0 === interpolantValue && (this.enabled = !1))
			}
		}
		return this._effectiveWeight = weight, weight
	}
	_updateTimeScale(time) {
		let timeScale = 0;
		if (!this.paused) {
			timeScale = this.timeScale;
			let interpolant = this._timeScaleInterpolant;
			null !== interpolant && (timeScale *= interpolant.evaluate(time)[0], time > interpolant.parameterPositions[1] && (this.stopWarping(), 0 === timeScale ? this.paused = !0 : this.timeScale = timeScale))
		}
		return this._effectiveTimeScale = timeScale, timeScale
	}
	_updateTime(deltaTime) {
		let duration = this._clip.duration,
			loop = this.loop,
			time = this.time + deltaTime,
			loopCount = this._loopCount,
			pingPong = 2202 === loop;
		if (0 === deltaTime) return -1 === loopCount ? time : pingPong && (1 & loopCount) == 1 ? duration - time : time;
		if (2200 === loop) {
			-1 === loopCount && (this._loopCount = 0, this._setEndings(!0, !0, !1));
			handle_stop: {
				if (time >= duration) time = duration;
				else if (time < 0) time = 0;
				else {
					this.time = time;
					break handle_stop
				}
				this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
				this.time = time,
				this._mixer.dispatchEvent({
					type: "finished",
					action: this,
					direction: deltaTime < 0 ? -1 : 1
				})
			}
		} else {
			if (-1 === loopCount && (deltaTime >= 0 ? (loopCount = 0, this._setEndings(!0, 0 === this.repetitions, pingPong)) : this._setEndings(0 === this.repetitions, !0, pingPong)), time >= duration || time < 0) {
				let loopDelta = Math.floor(time / duration);
				time -= duration * loopDelta, loopCount += Math.abs(loopDelta);
				let pending = this.repetitions - loopCount;
				if (pending <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, time = deltaTime > 0 ? duration : 0, this.time = time, this._mixer.dispatchEvent({
					type: "finished",
					action: this,
					direction: deltaTime > 0 ? 1 : -1
				});
				else {
					if (1 === pending) {
						let atStart = deltaTime < 0;
						this._setEndings(atStart, !atStart, pingPong)
					} else this._setEndings(!1, !1, pingPong);
					this._loopCount = loopCount, this.time = time, this._mixer.dispatchEvent({
						type: "loop",
						action: this,
						loopDelta: loopDelta
					})
				}
			} else this.time = time;
			if (pingPong && (1 & loopCount) == 1) return duration - time
		}
		return time
	}
	_setEndings(atStart, atEnd, pingPong) {
		let settings = this._interpolantSettings;
		pingPong ? (settings.endingStart = 2401, settings.endingEnd = 2401) : (atStart ? settings.endingStart = this.zeroSlopeAtStart ? 2401 : 2400 : settings.endingStart = 2402, atEnd ? settings.endingEnd = this.zeroSlopeAtEnd ? 2401 : 2400 : settings.endingEnd = 2402)
	}
	_scheduleFading(duration, weightNow, weightThen) {
		let mixer = this._mixer,
			now = mixer.time,
			interpolant = this._weightInterpolant;
		null === interpolant && (interpolant = mixer._lendControlInterpolant(), this._weightInterpolant = interpolant);
		let times = interpolant.parameterPositions,
			values = interpolant.sampleValues;
		return times[0] = now, values[0] = weightNow, times[1] = now + duration, values[1] = weightThen, this
	}
}
let _controlInterpolantsResultBuffer = new Float32Array(1);
class AnimationMixer extends EventDispatcher {
	constructor(root) {
		super(), this._root = root, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
	}
	_bindAction(action, prototypeAction) {
		let root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingsByName = bindingsByRoot[rootUuid];
		void 0 === bindingsByName && (bindingsByName = {}, bindingsByRoot[rootUuid] = bindingsByName);
		for (let i = 0; i !== nTracks; ++i) {
			let track = tracks[i],
				trackName = track.name,
				binding = bindingsByName[trackName];
			if (void 0 !== binding) ++binding.referenceCount, bindings[i] = binding;
			else {
				if (void 0 !== (binding = bindings[i])) {
					null === binding._cacheIndex && (++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName));
					continue
				}
				let path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
				binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize()), ++binding.referenceCount, this._addInactiveBinding(binding, rootUuid, trackName), bindings[i] = binding
			}
			interpolants[i].resultBuffer = binding.buffer
		}
	}
	_activateAction(action) {
		if (!this._isActiveAction(action)) {
			if (null === action._cacheIndex) {
				let rootUuid = (action._localRoot || this._root).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[clipUuid];
				this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]), this._addInactiveAction(action, clipUuid, rootUuid)
			}
			let bindings = action._propertyBindings;
			for (let i = 0, n = bindings.length; i !== n; ++i) {
				let binding = bindings[i];
				0 == binding.useCount++ && (this._lendBinding(binding), binding.saveOriginalState())
			}
			this._lendAction(action)
		}
	}
	_deactivateAction(action) {
		if (this._isActiveAction(action)) {
			let bindings = action._propertyBindings;
			for (let i = 0, n = bindings.length; i !== n; ++i) {
				let binding = bindings[i];
				0 == --binding.useCount && (binding.restoreOriginalState(), this._takeBackBinding(binding))
			}
			this._takeBackAction(action)
		}
	}
	_initMemoryManager() {
		this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
		let scope = this;
		this.stats = {
			actions: {
				get total() {
					return scope._actions.length
				},
				get inUse() {
					return scope._nActiveActions
				}
			},
			bindings: {
				get total() {
					return scope._bindings.length
				},
				get inUse() {
					return scope._nActiveBindings
				}
			},
			controlInterpolants: {
				get total() {
					return scope._controlInterpolants.length
				},
				get inUse() {
					return scope._nActiveControlInterpolants
				}
			}
		}
	}
	_isActiveAction(action) {
		let index = action._cacheIndex;
		return null !== index && index < this._nActiveActions
	}
	_addInactiveAction(action, clipUuid, rootUuid) {
		let actions = this._actions,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[clipUuid];
		if (void 0 === actionsForClip) actionsForClip = {
			knownActions: [action],
			actionByRoot: {}
		}, action._byClipCacheIndex = 0, actionsByClip[clipUuid] = actionsForClip;
		else {
			let knownActions = actionsForClip.knownActions;
			action._byClipCacheIndex = knownActions.length, knownActions.push(action)
		}
		action._cacheIndex = actions.length, actions.push(action), actionsForClip.actionByRoot[rootUuid] = action
	}
	_removeInactiveAction(action) {
		let actions = this._actions,
			lastInactiveAction = actions[actions.length - 1],
			cacheIndex = action._cacheIndex;
		lastInactiveAction._cacheIndex = cacheIndex, actions[cacheIndex] = lastInactiveAction, actions.pop(), action._cacheIndex = null;
		let clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[clipUuid],
			knownActionsForClip = actionsForClip.knownActions,
			lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
			byClipCacheIndex = action._byClipCacheIndex;
		lastKnownAction._byClipCacheIndex = byClipCacheIndex, knownActionsForClip[byClipCacheIndex] = lastKnownAction, knownActionsForClip.pop(), action._byClipCacheIndex = null;
		let actionByRoot = actionsForClip.actionByRoot,
			rootUuid = (action._localRoot || this._root).uuid;
		delete actionByRoot[rootUuid], 0 === knownActionsForClip.length && delete actionsByClip[clipUuid], this._removeInactiveBindingsForAction(action)
	}
	_removeInactiveBindingsForAction(action) {
		let bindings = action._propertyBindings;
		for (let i = 0, n = bindings.length; i !== n; ++i) {
			let binding = bindings[i];
			0 == --binding.referenceCount && this._removeInactiveBinding(binding)
		}
	}
	_lendAction(action) {
		let actions = this._actions,
			prevIndex = action._cacheIndex,
			lastActiveIndex = this._nActiveActions++,
			firstInactiveAction = actions[lastActiveIndex];
		action._cacheIndex = lastActiveIndex, actions[lastActiveIndex] = action, firstInactiveAction._cacheIndex = prevIndex, actions[prevIndex] = firstInactiveAction
	}
	_takeBackAction(action) {
		let actions = this._actions,
			prevIndex = action._cacheIndex,
			firstInactiveIndex = --this._nActiveActions,
			lastActiveAction = actions[firstInactiveIndex];
		action._cacheIndex = firstInactiveIndex, actions[firstInactiveIndex] = action, lastActiveAction._cacheIndex = prevIndex, actions[prevIndex] = lastActiveAction
	}
	_addInactiveBinding(binding, rootUuid, trackName) {
		let bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings,
			bindingByName = bindingsByRoot[rootUuid];
		void 0 === bindingByName && (bindingByName = {}, bindingsByRoot[rootUuid] = bindingByName), bindingByName[trackName] = binding, binding._cacheIndex = bindings.length, bindings.push(binding)
	}
	_removeInactiveBinding(binding) {
		let bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[rootUuid],
			lastInactiveBinding = bindings[bindings.length - 1],
			cacheIndex = binding._cacheIndex;
		lastInactiveBinding._cacheIndex = cacheIndex, bindings[cacheIndex] = lastInactiveBinding, bindings.pop(), delete bindingByName[trackName], 0 === Object.keys(bindingByName).length && delete bindingsByRoot[rootUuid]
	}
	_lendBinding(binding) {
		let bindings = this._bindings,
			prevIndex = binding._cacheIndex,
			lastActiveIndex = this._nActiveBindings++,
			firstInactiveBinding = bindings[lastActiveIndex];
		binding._cacheIndex = lastActiveIndex, bindings[lastActiveIndex] = binding, firstInactiveBinding._cacheIndex = prevIndex, bindings[prevIndex] = firstInactiveBinding
	}
	_takeBackBinding(binding) {
		let bindings = this._bindings,
			prevIndex = binding._cacheIndex,
			firstInactiveIndex = --this._nActiveBindings,
			lastActiveBinding = bindings[firstInactiveIndex];
		binding._cacheIndex = firstInactiveIndex, bindings[firstInactiveIndex] = binding, lastActiveBinding._cacheIndex = prevIndex, bindings[prevIndex] = lastActiveBinding
	}
	_lendControlInterpolant() {
		let interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants++,
			interpolant = interpolants[lastActiveIndex];
		return void 0 === interpolant && ((interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer)).__cacheIndex = lastActiveIndex, interpolants[lastActiveIndex] = interpolant), interpolant
	}
	_takeBackControlInterpolant(interpolant) {
		let interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,
			firstInactiveIndex = --this._nActiveControlInterpolants,
			lastActiveInterpolant = interpolants[firstInactiveIndex];
		interpolant.__cacheIndex = firstInactiveIndex, interpolants[firstInactiveIndex] = interpolant, lastActiveInterpolant.__cacheIndex = prevIndex, interpolants[prevIndex] = lastActiveInterpolant
	}
	clipAction(clip, optionalRoot, blendMode) {
		let root = optionalRoot || this._root,
			rootUuid = root.uuid,
			clipObject = "string" == typeof clip ? AnimationClip.findByName(root, clip) : clip,
			clipUuid = null !== clipObject ? clipObject.uuid : clip,
			actionsForClip = this._actionsByClip[clipUuid],
			prototypeAction = null;
		if (void 0 === blendMode && (blendMode = null !== clipObject ? clipObject.blendMode : 2500), void 0 !== actionsForClip) {
			let existingAction = actionsForClip.actionByRoot[rootUuid];
			if (void 0 !== existingAction && existingAction.blendMode === blendMode) return existingAction;
			prototypeAction = actionsForClip.knownActions[0], null === clipObject && (clipObject = prototypeAction._clip)
		}
		if (null === clipObject) return null;
		let newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
		return this._bindAction(newAction, prototypeAction), this._addInactiveAction(newAction, clipUuid, rootUuid), newAction
	}
	existingAction(clip, optionalRoot) {
		let root = optionalRoot || this._root,
			rootUuid = root.uuid,
			clipObject = "string" == typeof clip ? AnimationClip.findByName(root, clip) : clip,
			clipUuid = clipObject ? clipObject.uuid : clip,
			actionsForClip = this._actionsByClip[clipUuid];
		return void 0 !== actionsForClip && actionsForClip.actionByRoot[rootUuid] || null
	}
	stopAllAction() {
		let actions = this._actions,
			nActions = this._nActiveActions;
		for (let i = nActions - 1; i >= 0; --i) actions[i].stop();
		return this
	}
	update(deltaTime) {
		deltaTime *= this.timeScale;
		let actions = this._actions,
			nActions = this._nActiveActions,
			time = this.time += deltaTime,
			timeDirection = Math.sign(deltaTime),
			accuIndex = this._accuIndex ^= 1;
		for (let i = 0; i !== nActions; ++i) actions[i]._update(time, deltaTime, timeDirection, accuIndex);
		let bindings = this._bindings,
			nBindings = this._nActiveBindings;
		for (let i = 0; i !== nBindings; ++i) bindings[i].apply(accuIndex);
		return this
	}
	setTime(timeInSeconds) {
		this.time = 0;
		for (let i = 0; i < this._actions.length; i++) this._actions[i].time = 0;
		return this.update(timeInSeconds)
	}
	getRoot() {
		return this._root
	}
	uncacheClip(clip) {
		let actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[clipUuid];
		if (void 0 !== actionsForClip) {
			let actionsToRemove = actionsForClip.knownActions;
			for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
				let action = actionsToRemove[i];
				this._deactivateAction(action);
				let cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[actions.length - 1];
				action._cacheIndex = null, action._byClipCacheIndex = null, lastInactiveAction._cacheIndex = cacheIndex, actions[cacheIndex] = lastInactiveAction, actions.pop(), this._removeInactiveBindingsForAction(action)
			}
			delete actionsByClip[clipUuid]
		}
	}
	uncacheRoot(root) {
		let rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;
		for (let clipUuid in actionsByClip) {
			let action = actionsByClip[clipUuid].actionByRoot[rootUuid];
			void 0 !== action && (this._deactivateAction(action), this._removeInactiveAction(action))
		}
		let bindingByName = this._bindingsByRootAndName[rootUuid];
		if (void 0 !== bindingByName)
			for (let trackName in bindingByName) {
				let binding = bindingByName[trackName];
				binding.restoreOriginalState(), this._removeInactiveBinding(binding)
			}
	}
	uncacheAction(clip, optionalRoot) {
		let action = this.existingAction(clip, optionalRoot);
		null !== action && (this._deactivateAction(action), this._removeInactiveAction(action))
	}
}
class Uniform {
	constructor(value) {
		this.value = value
	}
	clone() {
		return new Uniform(void 0 === this.value.clone ? this.value : this.value.clone())
	}
}

function ascSort(a, b) {
	return a.distance - b.distance
}

function intersectObject(object, raycaster, intersects, recursive) {
	if (object.layers.test(raycaster.layers) && object.raycast(raycaster, intersects), !0 === recursive) {
		let children = object.children;
		for (let i = 0, l = children.length; i < l; i++) intersectObject(children[i], raycaster, intersects, !0)
	}
}
class Spherical {
	constructor(radius = 1, phi = 0, theta = 0) {
		return this.radius = radius, this.phi = phi, this.theta = theta, this
	}
	set(radius, phi, theta) {
		return this.radius = radius, this.phi = phi, this.theta = theta, this
	}
	copy(other) {
		return this.radius = other.radius, this.phi = other.phi, this.theta = other.theta, this
	}
	makeSafe() {
		return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
	}
	setFromVector3(v) {
		return this.setFromCartesianCoords(v.x, v.y, v.z)
	}
	setFromCartesianCoords(x, y, z) {
		return this.radius = Math.sqrt(x * x + y * y + z * z), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(x, z), this.phi = Math.acos(clamp$1(y / this.radius, -1, 1))), this
	}
	clone() {
		return new this.constructor().copy(this)
	}
}
"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
	detail: {
		revision: "160"
	}
})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "160");
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let t$3 = window,
	e$4 = t$3.ShadowRoot && (void 0 === t$3.ShadyCSS || t$3.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
	s$5 = Symbol(),
	n$6 = new WeakMap;
class o$5 {
	constructor(t, e, n) {
		if (this._$cssResult$ = !0, n !== s$5) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
		this.cssText = t, this.t = e
	}
	get styleSheet() {
		let t = this.o,
			s = this.t;
		if (e$4 && void 0 === t) {
			let e = void 0 !== s && 1 === s.length;
			e && (t = n$6.get(s)), void 0 === t && ((this.o = t = new CSSStyleSheet).replaceSync(this.cssText), e && n$6.set(s, t))
		}
		return t
	}
	toString() {
		return this.cssText
	}
}
let r$4 = t => new o$5("string" == typeof t ? t : t + "", void 0, s$5),
	S$2 = (s, n) => {
		e$4 ? s.adoptedStyleSheets = n.map(t => t instanceof CSSStyleSheet ? t : t.styleSheet) : n.forEach(e => {
			let n = document.createElement("style"),
				o = t$3.litNonce;
			void 0 !== o && n.setAttribute("nonce", o), n.textContent = e.cssText, s.appendChild(n)
		})
	},
	c$3 = e$4 ? t => t : t => t instanceof CSSStyleSheet ? (t => {
		let e = "";
		for (let s of t.cssRules) e += s.cssText;
		return r$4(e)
	})(t) : t,
	e$3 = window,
	r$3 = e$3.trustedTypes,
	h$2 = r$3 ? r$3.emptyScript : "",
	o$4 = e$3.reactiveElementPolyfillSupport,
	n$5 = {
		toAttribute(t, i) {
			switch (i) {
				case Boolean:
					t = t ? h$2 : null;
					break;
				case Object:
				case Array:
					t = null == t ? t : JSON.stringify(t)
			}
			return t
		},
		fromAttribute(t, i) {
			let s = t;
			switch (i) {
				case Boolean:
					s = null !== t;
					break;
				case Number:
					s = null === t ? null : Number(t);
					break;
				case Object:
				case Array:
					try {
						s = JSON.parse(t)
					} catch (t) {
						s = null
					}
			}
			return s
		}
	},
	a$3 = (t, i) => i !== t && (i == i || t == t),
	l$3 = {
		attribute: !0,
		type: String,
		converter: n$5,
		reflect: !1,
		hasChanged: a$3
	},
	d$2 = "finalized";
class u$2 extends HTMLElement {
	constructor() {
		super(), this._$Ei = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu()
	}
	static addInitializer(t) {
		var i;
		this.finalize(), (null !== (i = this.h) && void 0 !== i ? i : this.h = []).push(t)
	}
	static get observedAttributes() {
		this.finalize();
		let t = [];
		return this.elementProperties.forEach((i, s) => {
			let e = this._$Ep(s, i);
			void 0 !== e && (this._$Ev.set(e, s), t.push(e))
		}), t
	}
	static createProperty(t, i = l$3) {
		if (i.state && (i.attribute = !1), this.finalize(), this.elementProperties.set(t, i), !i.noAccessor && !this.prototype.hasOwnProperty(t)) {
			let s = "symbol" == typeof t ? Symbol() : "__" + t,
				e = this.getPropertyDescriptor(t, s, i);
			void 0 !== e && Object.defineProperty(this.prototype, t, e)
		}
	}
	static getPropertyDescriptor(t, i, s) {
		return {
			get() {
				return this[i]
			},
			set(e) {
				let r = this[t];
				this[i] = e, this.requestUpdate(t, r, s)
			},
			configurable: !0,
			enumerable: !0
		}
	}
	static getPropertyOptions(t) {
		return this.elementProperties.get(t) || l$3
	}
	static finalize() {
		if (this.hasOwnProperty(d$2)) return !1;
		this[d$2] = !0;
		let t = Object.getPrototypeOf(this);
		if (t.finalize(), void 0 !== t.h && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = new Map, this.hasOwnProperty("properties")) {
			let t = this.properties;
			for (let s of [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)]) this.createProperty(s, t[s])
		}
		return this.elementStyles = this.finalizeStyles(this.styles), !0
	}
	static finalizeStyles(i) {
		let s = [];
		if (Array.isArray(i))
			for (let i1 of new Set(i.flat(1 / 0).reverse())) s.unshift(c$3(i1));
		else void 0 !== i && s.push(c$3(i));
		return s
	}
	static _$Ep(t, i) {
		let s = i.attribute;
		return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof t ? t.toLowerCase() : void 0
	}
	_$Eu() {
		var t;
		this._$E_ = new Promise(t => this.enableUpdating = t), this._$AL = new Map, this._$Eg(), this.requestUpdate(), null === (t = this.constructor.h) || void 0 === t || t.forEach(t => t(this))
	}
	addController(t) {
		var i, s;
		(null !== (i = this._$ES) && void 0 !== i ? i : this._$ES = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (s = t.hostConnected) || void 0 === s || s.call(t))
	}
	removeController(t) {
		var i;
		null === (i = this._$ES) || void 0 === i || i.splice(this._$ES.indexOf(t) >>> 0, 1)
	}
	_$Eg() {
		this.constructor.elementProperties.forEach((t, i) => {
			this.hasOwnProperty(i) && (this._$Ei.set(i, this[i]), delete this[i])
		})
	}
	createRenderRoot() {
		var t;
		let s = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);
		return S$2(s, this.constructor.elementStyles), s
	}
	connectedCallback() {
		var t;
		void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this._$ES) || void 0 === t || t.forEach(t => {
			var i;
			return null === (i = t.hostConnected) || void 0 === i ? void 0 : i.call(t)
		})
	}
	enableUpdating(t) {}
	disconnectedCallback() {
		var t;
		null === (t = this._$ES) || void 0 === t || t.forEach(t => {
			var i;
			return null === (i = t.hostDisconnected) || void 0 === i ? void 0 : i.call(t)
		})
	}
	attributeChangedCallback(t, i, s) {
		this._$AK(t, s)
	}
	_$EO(t, i, s = l$3) {
		var e;
		let r = this.constructor._$Ep(t, s);
		if (void 0 !== r && !0 === s.reflect) {
			let h = (void 0 !== (null === (e = s.converter) || void 0 === e ? void 0 : e.toAttribute) ? s.converter : n$5).toAttribute(i, s.type);
			this._$El = t, null == h ? this.removeAttribute(r) : this.setAttribute(r, h), this._$El = null
		}
	}
	_$AK(t, i) {
		var s;
		let e = this.constructor,
			r = e._$Ev.get(t);
		if (void 0 !== r && this._$El !== r) {
			let t = e.getPropertyOptions(r),
				h = "function" == typeof t.converter ? {
					fromAttribute: t.converter
				} : void 0 !== (null === (s = t.converter) || void 0 === s ? void 0 : s.fromAttribute) ? t.converter : n$5;
			this._$El = r, this[r] = h.fromAttribute(i, t.type), this._$El = null
		}
	}
	requestUpdate(t, i, s) {
		let e = !0;
		void 0 !== t && (((s = s || this.constructor.getPropertyOptions(t)).hasChanged || a$3)(this[t], i) ? (this._$AL.has(t) || this._$AL.set(t, i), !0 === s.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(t, s))) : e = !1), !this.isUpdatePending && e && (this._$E_ = this._$Ej())
	}
	async _$Ej() {
		this.isUpdatePending = !0;
		try {
			await this._$E_
		} catch (t) {
			Promise.reject(t)
		}
		let t = this.scheduleUpdate();
		return null != t && await t, !this.isUpdatePending
	}
	scheduleUpdate() {
		return this.performUpdate()
	}
	performUpdate() {
		var t;
		if (!this.isUpdatePending) return;
		this.hasUpdated, this._$Ei && (this._$Ei.forEach((t, i) => this[i] = t), this._$Ei = void 0);
		let i = !1,
			s = this._$AL;
		try {
			(i = this.shouldUpdate(s)) ? (this.willUpdate(s), null === (t = this._$ES) || void 0 === t || t.forEach(t => {
				var i;
				return null === (i = t.hostUpdate) || void 0 === i ? void 0 : i.call(t)
			}), this.update(s)) : this._$Ek()
		} catch (t) {
			throw i = !1, this._$Ek(), t
		}
		i && this._$AE(s)
	}
	willUpdate(t) {}
	_$AE(t) {
		var i;
		null === (i = this._$ES) || void 0 === i || i.forEach(t => {
			var i;
			return null === (i = t.hostUpdated) || void 0 === i ? void 0 : i.call(t)
		}), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t)
	}
	_$Ek() {
		this._$AL = new Map, this.isUpdatePending = !1
	}
	get updateComplete() {
		return this.getUpdateComplete()
	}
	getUpdateComplete() {
		return this._$E_
	}
	shouldUpdate(t) {
		return !0
	}
	update(t) {
		void 0 !== this._$EC && (this._$EC.forEach((t, i) => this._$EO(i, this[i], t)), this._$EC = void 0), this._$Ek()
	}
	updated(t) {}
	firstUpdated(t) {}
}
u$2[d$2] = !0, u$2.elementProperties = new Map, u$2.elementStyles = [], u$2.shadowRootOptions = {
	mode: "open"
}, null == o$4 || o$4({
	ReactiveElement: u$2
}), (null !== (s$4 = e$3.reactiveElementVersions) && void 0 !== s$4 ? s$4 : e$3.reactiveElementVersions = []).push("1.6.3");
let i$1 = window,
	s$3 = i$1.trustedTypes,
	e$2 = s$3 ? s$3.createPolicy("lit-html", {
		createHTML: t => t
	}) : void 0,
	o$3 = "$lit$",
	n$4 = `lit$${(Math.random()+"").slice(9)}$`,
	l$2 = "?" + n$4,
	h$1 = `<${l$2}>`,
	r$2 = document,
	u$1 = () => r$2.createComment(""),
	d$1 = t => null === t || "object" != typeof t && "function" != typeof t,
	c$2 = Array.isArray,
	v = t => c$2(t) || "function" == typeof(null == t ? void 0 : t[Symbol.iterator]),
	a$2 = "[ 	\n\f\r]",
	f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,
	_ = /-->/g,
	m = />/g,
	p$1 = RegExp(`>|${a$2}(?:([^\\s"'>=/]+)(${a$2}*=${a$2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"),
	g$1 = /'/g,
	$ = /"/g,
	y = /^(?:script|style|textarea|title)$/i,
	x$2 = (i, ...s) => ({
		_$litType$: 1,
		strings: i,
		values: s
	}),
	T = Symbol.for("lit-noChange"),
	A$1 = Symbol.for("lit-nothing"),
	E$1 = new WeakMap,
	C$1 = r$2.createTreeWalker(r$2, 129, null, !1);

function P(t, i) {
	if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");
	return void 0 !== e$2 ? e$2.createHTML(i) : i
}
let V = (t, i) => {
	let s = t.length - 1,
		e = [],
		l, r = 2 === i ? "<svg>" : "",
		u = f;
	for (let i = 0; i < s; i++) {
		let s = t[i],
			d, c, v = -1,
			a = 0;
		for (; a < s.length && (u.lastIndex = a, null !== (c = u.exec(s)));) a = u.lastIndex, u === f ? "!--" === c[1] ? u = _ : void 0 !== c[1] ? u = m : void 0 !== c[2] ? (y.test(c[2]) && (l = RegExp("</" + c[2], "g")), u = p$1) : void 0 !== c[3] && (u = p$1) : u === p$1 ? ">" === c[0] ? (u = null != l ? l : f, v = -1) : void 0 === c[1] ? v = -2 : (v = u.lastIndex - c[2].length, d = c[1], u = void 0 === c[3] ? p$1 : '"' === c[3] ? $ : g$1) : u === $ || u === g$1 ? u = p$1 : u === _ || u === m ? u = f : (u = p$1, l = void 0);
		let w = u === p$1 && t[i + 1].startsWith("/>") ? " " : "";
		r += u === f ? s + h$1 : v >= 0 ? (e.push(d), s.slice(0, v) + o$3 + s.slice(v) + n$4 + w) : s + n$4 + (-2 === v ? (e.push(void 0), i) : w)
	}
	return [P(t, r + (t[s] || "<?>") + (2 === i ? "</svg>" : "")), e]
};
class N {
	constructor({
		strings: t,
		_$litType$: i
	}, e) {
		let h;
		this.parts = [];
		let r = 0,
			d = 0,
			c = t.length - 1,
			v = this.parts,
			[a, f] = V(t, i);
		if (this.el = N.createElement(a, e), C$1.currentNode = this.el.content, 2 === i) {
			let t = this.el.content,
				i = t.firstChild;
			i.remove(), t.append(...i.childNodes)
		}
		for (; null !== (h = C$1.nextNode()) && v.length < c;) {
			if (1 === h.nodeType) {
				if (h.hasAttributes()) {
					let t = [];
					for (let i of h.getAttributeNames())
						if (i.endsWith(o$3) || i.startsWith(n$4)) {
							let s = f[d++];
							if (t.push(i), void 0 !== s) {
								let t = h.getAttribute(s.toLowerCase() + o$3).split(n$4),
									i = /([.?@])?(.*)/.exec(s);
								v.push({
									type: 1,
									index: r,
									name: i[2],
									strings: t,
									ctor: "." === i[1] ? H : "?" === i[1] ? L : "@" === i[1] ? z : k
								})
							} else v.push({
								type: 6,
								index: r
							})
						} for (let i of t) h.removeAttribute(i)
				}
				if (y.test(h.tagName)) {
					let t = h.textContent.split(n$4),
						i = t.length - 1;
					if (i > 0) {
						h.textContent = s$3 ? s$3.emptyScript : "";
						for (let s = 0; s < i; s++) h.append(t[s], u$1()), C$1.nextNode(), v.push({
							type: 2,
							index: ++r
						});
						h.append(t[i], u$1())
					}
				}
			} else if (8 === h.nodeType) {
				if (h.data === l$2) v.push({
					type: 2,
					index: r
				});
				else {
					let t = -1;
					for (; - 1 !== (t = h.data.indexOf(n$4, t + 1));) v.push({
						type: 7,
						index: r
					}), t += n$4.length - 1
				}
			}
			r++
		}
	}
	static createElement(t, i) {
		let s = r$2.createElement("template");
		return s.innerHTML = t, s
	}
}

function S$1(t, i, s = t, e) {
	var o, n, l;
	if (i === T) return i;
	let r = void 0 !== e ? null === (o = s._$Co) || void 0 === o ? void 0 : o[e] : s._$Cl,
		u = d$1(i) ? void 0 : i._$litDirective$;
	return (null == r ? void 0 : r.constructor) !== u && (null === (n = null == r ? void 0 : r._$AO) || void 0 === n || n.call(r, !1), void 0 === u ? r = void 0 : (r = new u(t))._$AT(t, s, e), void 0 !== e ? (null !== (l = s._$Co) && void 0 !== l ? l : s._$Co = [])[e] = r : s._$Cl = r), void 0 !== r && (i = S$1(t, r._$AS(t, i.values), r, e)), i
}
class M {
	constructor(t, i) {
		this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = i
	}
	get parentNode() {
		return this._$AM.parentNode
	}
	get _$AU() {
		return this._$AM._$AU
	}
	u(t) {
		var i;
		let {
			el: {
				content: s
			},
			parts: e
		} = this._$AD, o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : r$2).importNode(s, !0);
		C$1.currentNode = o;
		let n = C$1.nextNode(),
			l = 0,
			h = 0,
			u = e[0];
		for (; void 0 !== u;) {
			if (l === u.index) {
				let i;
				2 === u.type ? i = new R(n, n.nextSibling, this, t) : 1 === u.type ? i = new u.ctor(n, u.name, u.strings, this, t) : 6 === u.type && (i = new Z(n, this, t)), this._$AV.push(i), u = e[++h]
			}
			l !== (null == u ? void 0 : u.index) && (n = C$1.nextNode(), l++)
		}
		return C$1.currentNode = r$2, o
	}
	v(t) {
		let i = 0;
		for (let s of this._$AV) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++
	}
}
class R {
	constructor(t, i, s, e) {
		var o;
		this.type = 2, this._$AH = A$1, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cp = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o
	}
	get _$AU() {
		var t, i;
		return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$Cp
	}
	get parentNode() {
		let t = this._$AA.parentNode,
			i = this._$AM;
		return void 0 !== i && 11 === (null == t ? void 0 : t.nodeType) && (t = i.parentNode), t
	}
	get startNode() {
		return this._$AA
	}
	get endNode() {
		return this._$AB
	}
	_$AI(t, i = this) {
		d$1(t = S$1(this, t, i)) ? t === A$1 || null == t || "" === t ? (this._$AH !== A$1 && this._$AR(), this._$AH = A$1) : t !== this._$AH && t !== T && this._(t) : void 0 !== t._$litType$ ? this.g(t) : void 0 !== t.nodeType ? this.$(t) : v(t) ? this.T(t) : this._(t)
	}
	k(t) {
		return this._$AA.parentNode.insertBefore(t, this._$AB)
	}
	$(t) {
		this._$AH !== t && (this._$AR(), this._$AH = this.k(t))
	}
	_(t) {
		this._$AH !== A$1 && d$1(this._$AH) ? this._$AA.nextSibling.data = t : this.$(r$2.createTextNode(t)), this._$AH = t
	}
	g(t) {
		var i;
		let {
			values: s,
			_$litType$: e
		} = t, o = "number" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = N.createElement(P(e.h, e.h[0]), this.options)), e);
		if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.v(s);
		else {
			let t = new M(o, this),
				i = t.u(this.options);
			t.v(s), this.$(i), this._$AH = t
		}
	}
	_$AC(t) {
		let i = E$1.get(t.strings);
		return void 0 === i && E$1.set(t.strings, i = new N(t)), i
	}
	T(t) {
		c$2(this._$AH) || (this._$AH = [], this._$AR());
		let i = this._$AH,
			s, e = 0;
		for (let o of t) e === i.length ? i.push(s = new R(this.k(u$1()), this.k(u$1()), this, this.options)) : s = i[e], s._$AI(o), e++;
		e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e)
	}
	_$AR(t = this._$AA.nextSibling, i) {
		var s;
		for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) {
			let i = t.nextSibling;
			t.remove(), t = i
		}
	}
	setConnected(t) {
		var i;
		void 0 === this._$AM && (this._$Cp = t, null === (i = this._$AP) || void 0 === i || i.call(this, t))
	}
}
class k {
	constructor(t, i, s, e, o) {
		this.type = 1, this._$AH = A$1, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || "" !== s[0] || "" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String), this.strings = s) : this._$AH = A$1
	}
	get tagName() {
		return this.element.tagName
	}
	get _$AU() {
		return this._$AM._$AU
	}
	_$AI(t, i = this, s, e) {
		let o = this.strings,
			n = !1;
		if (void 0 === o)(n = !d$1(t = S$1(this, t, i, 0)) || t !== this._$AH && t !== T) && (this._$AH = t);
		else {
			let l, h;
			let e = t;
			for (t = o[0], l = 0; l < o.length - 1; l++)(h = S$1(this, e[s + l], i, l)) === T && (h = this._$AH[l]), n || (n = !d$1(h) || h !== this._$AH[l]), h === A$1 ? t = A$1 : t !== A$1 && (t += (null != h ? h : "") + o[l + 1]), this._$AH[l] = h
		}
		n && !e && this.j(t)
	}
	j(t) {
		t === A$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "")
	}
}
class H extends k {
	constructor() {
		super(...arguments), this.type = 3
	}
	j(t) {
		this.element[this.name] = t === A$1 ? void 0 : t
	}
}
let I$1 = s$3 ? s$3.emptyScript : "";
class L extends k {
	constructor() {
		super(...arguments), this.type = 4
	}
	j(t) {
		t && t !== A$1 ? this.element.setAttribute(this.name, I$1) : this.element.removeAttribute(this.name)
	}
}
class z extends k {
	constructor(t, i, s, e, o) {
		super(t, i, s, e, o), this.type = 5
	}
	_$AI(t, i = this) {
		var s;
		if ((t = null !== (s = S$1(this, t, i, 0)) && void 0 !== s ? s : A$1) === T) return;
		let e = this._$AH,
			o = t === A$1 && e !== A$1 || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,
			n = t !== A$1 && (e === A$1 || o);
		o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t
	}
	handleEvent(t) {
		var i, s;
		"function" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t)
	}
}
class Z {
	constructor(t, i, s) {
		this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s
	}
	get _$AU() {
		return this._$AM._$AU
	}
	_$AI(t) {
		S$1(this, t)
	}
}
let B$1 = i$1.litHtmlPolyfillSupport;
null == B$1 || B$1(N, R), (null !== (t$2 = i$1.litHtmlVersions) && void 0 !== t$2 ? t$2 : i$1.litHtmlVersions = []).push("2.8.0");
let D = (t, i, s) => {
		var e, o;
		let n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i,
			l = n._$litPart$;
		if (void 0 === l) {
			let t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;
			n._$litPart$ = l = new R(i.insertBefore(u$1(), t), t, void 0, null != s ? s : {})
		}
		return l._$AI(t), l
	},
	t$1 = window,
	e$1 = t$1.ShadowRoot && (void 0 === t$1.ShadyCSS || t$1.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,
	s$2 = Symbol(),
	n$3 = new WeakMap;
class o$2 {
	constructor(t, e, n) {
		if (this._$cssResult$ = !0, n !== s$2) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
		this.cssText = t, this.t = e
	}
	get styleSheet() {
		let t = this.o,
			s = this.t;
		if (e$1 && void 0 === t) {
			let e = void 0 !== s && 1 === s.length;
			e && (t = n$3.get(s)), void 0 === t && ((this.o = t = new CSSStyleSheet).replaceSync(this.cssText), e && n$3.set(s, t))
		}
		return t
	}
	toString() {
		return this.cssText
	}
}
let r$1 = t => new o$2("string" == typeof t ? t : t + "", void 0, s$2),
	S = (s, n) => {
		e$1 ? s.adoptedStyleSheets = n.map(t => t instanceof CSSStyleSheet ? t : t.styleSheet) : n.forEach(e => {
			let n = document.createElement("style"),
				o = t$1.litNonce;
			void 0 !== o && n.setAttribute("nonce", o), n.textContent = e.cssText, s.appendChild(n)
		})
	},
	c$1 = e$1 ? t => t : t => t instanceof CSSStyleSheet ? (t => {
		let e = "";
		for (let s of t.cssRules) e += s.cssText;
		return r$1(e)
	})(t) : t,
	e = window,
	r = e.trustedTypes,
	h = r ? r.emptyScript : "",
	o$1 = e.reactiveElementPolyfillSupport,
	n$2 = {
		toAttribute(t, i) {
			switch (i) {
				case Boolean:
					t = t ? h : null;
					break;
				case Object:
				case Array:
					t = null == t ? t : JSON.stringify(t)
			}
			return t
		},
		fromAttribute(t, i) {
			let s = t;
			switch (i) {
				case Boolean:
					s = null !== t;
					break;
				case Number:
					s = null === t ? null : Number(t);
					break;
				case Object:
				case Array:
					try {
						s = JSON.parse(t)
					} catch (t) {
						s = null
					}
			}
			return s
		}
	},
	a$1 = (t, i) => i !== t && (i == i || t == t),
	l$1 = {
		attribute: !0,
		type: String,
		converter: n$2,
		reflect: !1,
		hasChanged: a$1
	},
	d = "finalized";
class u extends HTMLElement {
	constructor() {
		super(), this._$Ei = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this._$El = null, this._$Eu()
	}
	static addInitializer(t) {
		var i;
		this.finalize(), (null !== (i = this.h) && void 0 !== i ? i : this.h = []).push(t)
	}
	static get observedAttributes() {
		this.finalize();
		let t = [];
		return this.elementProperties.forEach((i, s) => {
			let e = this._$Ep(s, i);
			void 0 !== e && (this._$Ev.set(e, s), t.push(e))
		}), t
	}
	static createProperty(t, i = l$1) {
		if (i.state && (i.attribute = !1), this.finalize(), this.elementProperties.set(t, i), !i.noAccessor && !this.prototype.hasOwnProperty(t)) {
			let s = "symbol" == typeof t ? Symbol() : "__" + t,
				e = this.getPropertyDescriptor(t, s, i);
			void 0 !== e && Object.defineProperty(this.prototype, t, e)
		}
	}
	static getPropertyDescriptor(t, i, s) {
		return {
			get() {
				return this[i]
			},
			set(e) {
				let r = this[t];
				this[i] = e, this.requestUpdate(t, r, s)
			},
			configurable: !0,
			enumerable: !0
		}
	}
	static getPropertyOptions(t) {
		return this.elementProperties.get(t) || l$1
	}
	static finalize() {
		if (this.hasOwnProperty(d)) return !1;
		this[d] = !0;
		let t = Object.getPrototypeOf(this);
		if (t.finalize(), void 0 !== t.h && (this.h = [...t.h]), this.elementProperties = new Map(t.elementProperties), this._$Ev = new Map, this.hasOwnProperty("properties")) {
			let t = this.properties;
			for (let s of [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)]) this.createProperty(s, t[s])
		}
		return this.elementStyles = this.finalizeStyles(this.styles), !0
	}
	static finalizeStyles(i) {
		let s = [];
		if (Array.isArray(i))
			for (let i1 of new Set(i.flat(1 / 0).reverse())) s.unshift(c$1(i1));
		else void 0 !== i && s.push(c$1(i));
		return s
	}
	static _$Ep(t, i) {
		let s = i.attribute;
		return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof t ? t.toLowerCase() : void 0
	}
	_$Eu() {
		var t;
		this._$E_ = new Promise(t => this.enableUpdating = t), this._$AL = new Map, this._$Eg(), this.requestUpdate(), null === (t = this.constructor.h) || void 0 === t || t.forEach(t => t(this))
	}
	addController(t) {
		var i, s;
		(null !== (i = this._$ES) && void 0 !== i ? i : this._$ES = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (s = t.hostConnected) || void 0 === s || s.call(t))
	}
	removeController(t) {
		var i;
		null === (i = this._$ES) || void 0 === i || i.splice(this._$ES.indexOf(t) >>> 0, 1)
	}
	_$Eg() {
		this.constructor.elementProperties.forEach((t, i) => {
			this.hasOwnProperty(i) && (this._$Ei.set(i, this[i]), delete this[i])
		})
	}
	createRenderRoot() {
		var t;
		let s = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);
		return S(s, this.constructor.elementStyles), s
	}
	connectedCallback() {
		var t;
		void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this._$ES) || void 0 === t || t.forEach(t => {
			var i;
			return null === (i = t.hostConnected) || void 0 === i ? void 0 : i.call(t)
		})
	}
	enableUpdating(t) {}
	disconnectedCallback() {
		var t;
		null === (t = this._$ES) || void 0 === t || t.forEach(t => {
			var i;
			return null === (i = t.hostDisconnected) || void 0 === i ? void 0 : i.call(t)
		})
	}
	attributeChangedCallback(t, i, s) {
		this._$AK(t, s)
	}
	_$EO(t, i, s = l$1) {
		var e;
		let r = this.constructor._$Ep(t, s);
		if (void 0 !== r && !0 === s.reflect) {
			let h = (void 0 !== (null === (e = s.converter) || void 0 === e ? void 0 : e.toAttribute) ? s.converter : n$2).toAttribute(i, s.type);
			this._$El = t, null == h ? this.removeAttribute(r) : this.setAttribute(r, h), this._$El = null
		}
	}
	_$AK(t, i) {
		var s;
		let e = this.constructor,
			r = e._$Ev.get(t);
		if (void 0 !== r && this._$El !== r) {
			let t = e.getPropertyOptions(r),
				h = "function" == typeof t.converter ? {
					fromAttribute: t.converter
				} : void 0 !== (null === (s = t.converter) || void 0 === s ? void 0 : s.fromAttribute) ? t.converter : n$2;
			this._$El = r, this[r] = h.fromAttribute(i, t.type), this._$El = null
		}
	}
	requestUpdate(t, i, s) {
		let e = !0;
		void 0 !== t && (((s = s || this.constructor.getPropertyOptions(t)).hasChanged || a$1)(this[t], i) ? (this._$AL.has(t) || this._$AL.set(t, i), !0 === s.reflect && this._$El !== t && (void 0 === this._$EC && (this._$EC = new Map), this._$EC.set(t, s))) : e = !1), !this.isUpdatePending && e && (this._$E_ = this._$Ej())
	}
	async _$Ej() {
		this.isUpdatePending = !0;
		try {
			await this._$E_
		} catch (t) {
			Promise.reject(t)
		}
		let t = this.scheduleUpdate();
		return null != t && await t, !this.isUpdatePending
	}
	scheduleUpdate() {
		return this.performUpdate()
	}
	performUpdate() {
		var t;
		if (!this.isUpdatePending) return;
		this.hasUpdated, this._$Ei && (this._$Ei.forEach((t, i) => this[i] = t), this._$Ei = void 0);
		let i = !1,
			s = this._$AL;
		try {
			(i = this.shouldUpdate(s)) ? (this.willUpdate(s), null === (t = this._$ES) || void 0 === t || t.forEach(t => {
				var i;
				return null === (i = t.hostUpdate) || void 0 === i ? void 0 : i.call(t)
			}), this.update(s)) : this._$Ek()
		} catch (t) {
			throw i = !1, this._$Ek(), t
		}
		i && this._$AE(s)
	}
	willUpdate(t) {}
	_$AE(t) {
		var i;
		null === (i = this._$ES) || void 0 === i || i.forEach(t => {
			var i;
			return null === (i = t.hostUpdated) || void 0 === i ? void 0 : i.call(t)
		}), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t)
	}
	_$Ek() {
		this._$AL = new Map, this.isUpdatePending = !1
	}
	get updateComplete() {
		return this.getUpdateComplete()
	}
	getUpdateComplete() {
		return this._$E_
	}
	shouldUpdate(t) {
		return !0
	}
	update(t) {
		void 0 !== this._$EC && (this._$EC.forEach((t, i) => this._$EO(i, this[i], t)), this._$EC = void 0), this._$Ek()
	}
	updated(t) {}
	firstUpdated(t) {}
}
u[d] = !0, u.elementProperties = new Map, u.elementStyles = [], u.shadowRootOptions = {
	mode: "open"
}, null == o$1 || o$1({
	ReactiveElement: u
}), (null !== (s$1 = e.reactiveElementVersions) && void 0 !== s$1 ? s$1 : e.reactiveElementVersions = []).push("1.6.3");
class s extends u {
	constructor() {
		super(...arguments), this.renderOptions = {
			host: this
		}, this._$Do = void 0
	}
	createRenderRoot() {
		var t, e;
		let i = super.createRenderRoot();
		return null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t || (e.renderBefore = i.firstChild), i
	}
	update(t) {
		let i = this.render();
		this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this._$Do = D(i, this.renderRoot, this.renderOptions)
	}
	connectedCallback() {
		var t;
		super.connectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!0)
	}
	disconnectedCallback() {
		var t;
		super.disconnectedCallback(), null === (t = this._$Do) || void 0 === t || t.setConnected(!1)
	}
	render() {
		return T
	}
}
s.finalized = !0, s._$litElement$ = !0, null === (l = globalThis.litElementHydrateSupport) || void 0 === l || l.call(globalThis, {
	LitElement: s
});
let n$1 = globalThis.litElementPolyfillSupport;
null == n$1 || n$1({
	LitElement: s
}), (null !== (o = globalThis.litElementVersions) && void 0 !== o ? o : globalThis.litElementVersions = []).push("3.3.3");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let HAS_WEBXR_DEVICE_API = null != navigator.xr && null != self.XRSession && null != navigator.xr.isSessionSupported,
	HAS_WEBXR_HIT_TEST_API = HAS_WEBXR_DEVICE_API && null != self.XRSession.prototype.requestHitTestSource,
	HAS_RESIZE_OBSERVER = null != self.ResizeObserver,
	HAS_INTERSECTION_OBSERVER = null != self.IntersectionObserver;
(() => {
	let userAgent = navigator.userAgent || navigator.vendor || self.opera;
	/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(userAgent.substr(0, 4))
})(), /\bCrOS\b/.test(navigator.userAgent);
let IS_ANDROID = /android/i.test(navigator.userAgent),
	IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !self.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1;
/Safari\//.test(navigator.userAgent);
let IS_FIREFOX = /firefox/i.test(navigator.userAgent),
	IS_OCULUS = /OculusBrowser/.test(navigator.userAgent);
IS_IOS && /CriOS\//.test(navigator.userAgent);
let IS_SCENEVIEWER_CANDIDATE = IS_ANDROID && !IS_FIREFOX && !IS_OCULUS,
	IS_WKWEBVIEW = !!(window.webkit && window.webkit.messageHandlers),
	IS_AR_QUICKLOOK_CANDIDATE = (() => {
		if (!IS_IOS) return !1;
		if (IS_WKWEBVIEW) return !!/CriOS\/|EdgiOS\/|FxiOS\/|GSA\/|DuckDuckGo\//.test(navigator.userAgent);
		{
			let tempAnchor = document.createElement("a");
			return !!(tempAnchor.relList && tempAnchor.relList.supports && tempAnchor.relList.supports("ar"))
		}
	})(),
	deserializeUrl = url => url && "null" !== url ? toFullUrl(url) : null,
	assertIsArCandidate = () => {
		if (HAS_WEBXR_HIT_TEST_API) return;
		let missingApis = [];
		throw HAS_WEBXR_DEVICE_API || missingApis.push("WebXR Device API"), HAS_WEBXR_HIT_TEST_API || missingApis.push("WebXR Hit Test API"), Error(`The following APIs are required for AR, but are missing in this browser: ${missingApis.join(", ")}`)
	},
	toFullUrl = partialUrl => new URL(partialUrl, window.location.toString()).toString(),
	throttle = (fn, ms) => {
		let timer = null,
			throttled = (...args) => {
				null == timer && (fn(...args), timer = self.setTimeout(() => timer = null, ms))
			};
		return throttled.flush = () => {
			null != timer && (self.clearTimeout(timer), timer = null)
		}, throttled
	},
	debounce = (fn, ms) => {
		let timer = null;
		return (...args) => {
			null != timer && self.clearTimeout(timer), timer = self.setTimeout(() => {
				timer = null, fn(...args)
			}, ms)
		}
	},
	clamp = (value, lowerLimit, upperLimit) => Math.max(lowerLimit, Math.min(upperLimit, value)),
	resolveDpr = (() => {
		let HAS_META_VIEWPORT_TAG = (() => {
			var _a;
			if (null === (_a = document.documentElement.getAttribute("itemtype")) || void 0 === _a ? void 0 : _a.includes("schema.org/SearchResultsPage")) return !0;
			for (let meta of null != document.head ? Array.from(document.head.querySelectorAll("meta")) : [])
				if ("viewport" === meta.name) return !0;
			return !1
		})();
		return HAS_META_VIEWPORT_TAG || console.warn('No <meta name="viewport"> detected; <model-viewer> will cap pixel density at 1.'), () => HAS_META_VIEWPORT_TAG ? window.devicePixelRatio : 1
	})(),
	isDebugMode = (() => {
		let debugQueryParameter = RegExp("[?&]model-viewer-debug-mode(&|$)");
		return () => self.ModelViewerElement && self.ModelViewerElement.debugMode || self.location && self.location.search && self.location.search.match(debugQueryParameter)
	})(),
	timePasses = (ms = 0) => new Promise(resolve => setTimeout(resolve, ms)),
	waitForEvent = (target, eventName, predicate = null) => new Promise(resolve => {
		target.addEventListener(eventName, function handler(event) {
			(!predicate || predicate(event)) && (resolve(event), target.removeEventListener(eventName, handler))
		})
	});
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var n$7, s$4, t$2, s$1, l, o, _a$9, _b$9, _a$8, _b$8, _a$6, _b$6, _c$4, _a$5, _b$5, _c$3, _d$2, Filter, Wrap, _a$4, _b$4, _c$2, TextureUsage, _a$3, _b$3, _a$2, _b$2, _c$1, _d$1, _e$1, _f$1, _a$1, _b$1, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, Filter1, Wrap1, TextureUsage1, __decorate$7 = function(decorators, target, key, desc) {
	for (var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, i = decorators.length - 1; i >= 0; i--)(d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	return c > 3 && r && Object.defineProperty(target, key, r), r
};
let $currentEnvironmentMap = Symbol("currentEnvironmentMap"),
	$currentBackground = Symbol("currentBackground"),
	$updateEnvironment = Symbol("updateEnvironment"),
	$cancelEnvironmentUpdate = Symbol("cancelEnvironmentUpdate");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var CloseIcon = x$2`
<svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 24 24" fill="#000000">
    <!-- NOTE(cdata): This SVG filter is a stop-gap until we can implement
         support for dynamic re-coloring of UI components -->
    <defs>
      <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
        <feGaussianBlur in="SourceAlpha" stdDeviation="1"/>
        <feOffset dx="0" dy="0" result="offsetblur"/>
        <feFlood flood-color="#000000"/>
        <feComposite in2="offsetblur" operator="in"/>
        <feMerge>
          <feMergeNode/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
    </defs>
    <path filter="url(#drop-shadow)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`,
	ControlsPrompt = x$2`
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z" />
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z" />
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4" />
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000" />
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff" />
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A" />
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)" />
            </g>
        </g>
    </g>
</svg>`,
	ARGlyph = x$2`
<svg version="1.1" id="view_x5F_in_x5F_AR_x5F_icon"
	 xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="24px" height="24px"
	 viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve">
<rect id="Bounding_Box" x="0" y="0" fill="none" width="24" height="24"/>
<g id="Art_layer">
	<path d="M3,4c0-0.55,0.45-1,1-1h2V1H4C2.35,1,1,2.35,1,4v2h2V4z"/>
	<path d="M20,3c0.55,0,1,0.45,1,1v2h2V4c0-1.65-1.35-3-3-3h-2v2H20z"/>
	<path d="M4,21c-0.55,0-1-0.45-1-1v-2H1v2c0,1.65,1.35,3,3,3h2v-2H4z"/>
	<path d="M20,21c0.55,0,1-0.45,1-1v-2h2v2c0,1.65-1.35,3-3,3h-2v-2H20z"/>
	<g>
		<path d="M18.25,7.6l-5.5-3.18c-0.46-0.27-1.04-0.27-1.5,0L5.75,7.6C5.29,7.87,5,8.36,5,8.9v6.35c0,0.54,0.29,1.03,0.75,1.3
			l5.5,3.18c0.46,0.27,1.04,0.27,1.5,0l5.5-3.18c0.46-0.27,0.75-0.76,0.75-1.3V8.9C19,8.36,18.71,7.87,18.25,7.6z M7,14.96v-4.62
			l4,2.32v4.61L7,14.96z M12,10.93L8,8.61l4-2.31l4,2.31L12,10.93z M13,17.27v-4.61l4-2.32v4.62L13,17.27z"/>
	</g>
</g>
</svg>`;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let templateResult = x$2`
<style>
:host {
  display: block;
  position: relative;
  contain: strict;
  width: 300px;
  height: 150px;
}

.container {
  position: relative;
  overflow: hidden;
}

.userInput {
  width: 100%;
  height: 100%;
  display: none;
  position: relative;
  outline-offset: -1px;
  outline-width: 1px;
}

canvas {
  position: absolute;
  display: none;
  pointer-events: none;
  /* NOTE(cdata): Chrome 76 and below apparently have a bug
   * that causes our canvas not to display pixels unless it is
   * on its own render layer
   * @see https://github.com/google/model-viewer/pull/755#issuecomment-536597893
   */
  transform: translateZ(0);
}

.show {
  display: block;
}

/* Adapted from HTML5 Boilerplate
 *
 * @see https://github.com/h5bp/html5-boilerplate/blob/ceb4620c78fc82e13534fc44202a3f168754873f/dist/css/main.css#L122-L133 */
.screen-reader-only {
  border: 0;
  left: 0;
  top: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  white-space: nowrap;
  width: 1px;
  pointer-events: none;
}

.slot {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.slot > * {
  pointer-events: initial;
}

.annotation-wrapper ::slotted(*) {
  opacity: var(--max-hotspot-opacity, 1);
  transition: opacity 0.3s;
}

.pointer-tumbling .annotation-wrapper ::slotted(*) {
  pointer-events: none;
}

.annotation-wrapper ::slotted(*) {
  pointer-events: initial;
}

.annotation-wrapper.hide ::slotted(*) {
  opacity: var(--min-hotspot-opacity, 0.25);
}

.slot.poster {
  display: none;
  background-color: inherit;
}

.slot.poster.show {
  display: inherit;
}

.slot.poster > * {
  pointer-events: initial;
}

.slot.poster:not(.show) > * {
  pointer-events: none;
}

#default-poster {
  width: 100%;
  height: 100%;
  /* The default poster is a <button> so we need to set display
   * to prevent it from being affected by text-align: */
  display: block;
  position: absolute;
  border: none;
  padding: 0;
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  background-color: #fff0;
}

#default-progress-bar {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  pointer-events: none;
  overflow: hidden;
}

#default-progress-bar > .bar {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--progress-bar-height, 5px);
  background-color: var(--progress-bar-color, rgba(0, 0, 0, 0.4));
  transition: transform 0.09s;
  transform-origin: top left;
  transform: scaleX(0);
  overflow: hidden;
}

#default-progress-bar > .bar.hide {
  transition: opacity 0.3s 1s;
  opacity: 0;
}

.centered {
  align-items: center;
  justify-content: center;
}

.cover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.slot.interaction-prompt {
  display: var(--interaction-prompt-display, flex);
  overflow: hidden;
  opacity: 0;
  will-change: opacity;
  transition: opacity 0.3s;
}

.slot.interaction-prompt.visible {
  opacity: 1;
}

.animated-container {
  will-change: transform, opacity;
  opacity: 0;
  transition: opacity 0.3s;
}

.slot.interaction-prompt > * {
  pointer-events: none;
}

.slot.ar-button {
  -moz-user-select: none;
  -webkit-tap-highlight-color: transparent;
  user-select: none;

  display: var(--ar-button-display, block);
}

.slot.ar-button:not(.enabled) {
  display: none;
}

.fab {
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  width: 40px;
  height: 40px;
  cursor: pointer;
  background-color: #fff;
  box-shadow: 0px 0px 4px rgba(0, 0, 0, 0.15);
  border-radius: 100px;
}

.fab > * {
  opacity: 0.87;
}

#default-ar-button {
  position: absolute;
  bottom: 16px;
  right: 16px;
  transform: scale(var(--ar-button-scale, 1));
  transform-origin: bottom right;
}

.slot.pan-target {
  display: block;
  position: absolute;
  width: 0;
  height: 0;
  left: 50%;
  top: 50%;
  transform: translate3d(-50%, -50%, 0);
  background-color: transparent;
  opacity: 0;
  transition: opacity 0.3s;
}

#default-pan-target {
  width: 6px;
  height: 6px;
  border-radius: 6px;
  border: 1px solid white;
  box-shadow: 0px 0px 2px 1px rgba(0, 0, 0, 0.8);
}

.slot.default {
  pointer-events: none;
}

.slot.progress-bar {
  pointer-events: none;
}

.slot.exit-webxr-ar-button {
  pointer-events: none;
}

.slot.exit-webxr-ar-button:not(.enabled) {
  display: none;
}

#default-exit-webxr-ar-button {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: env(safe-area-inset-top, 16px);
  right: 16px;
  width: 40px;
  height: 40px;
  box-sizing: border-box;
}

#default-exit-webxr-ar-button > svg {
  fill: #fff;
}
</style>
<div class="container">
  <div class="userInput" tabindex="0" role="img"
      aria-label="3D model">
      <div class="slot canvas">
        <slot name="canvas">
          <canvas></canvas>
        </slot>
      </div>

  </div>

  <!-- NOTE(cdata): We need to wrap slots because browsers without ShadowDOM
        will have their <slot> elements removed by ShadyCSS -->
  <div class="slot poster">
    <slot name="poster">
      <button type="button" id="default-poster" aria-hidden="true" aria-label="Loading 3D model"></button>
    </slot>
  </div>

  <div class="slot ar-button">
    <slot name="ar-button">
      <a id="default-ar-button" part="default-ar-button" class="fab"
          tabindex="2"
          role="button"
          href="javascript:void(0);"
          aria-label="View in your space">
        ${ARGlyph}
      </a>
    </slot>
  </div>

  <div class="slot pan-target">
    <slot name="pan-target">
      <div id="default-pan-target">
      </div>
    </slot>
  </div>

  <div class="slot interaction-prompt cover centered">
    <div id="prompt" class="animated-container">
      <slot name="interaction-prompt" aria-hidden="true">
        ${ControlsPrompt}
      </slot>
    </div>
  </div>

  <div id="finger0" class="animated-container cover">
    <slot name="finger0" aria-hidden="true">
    </slot>
  </div>
  <div id="finger1" class="animated-container cover">
    <slot name="finger1" aria-hidden="true">
    </slot>
  </div>

  <div class="slot default">
    <slot></slot>

    <div class="slot progress-bar">
      <slot name="progress-bar">
        <div id="default-progress-bar" aria-hidden="true">
          <div class="bar" part="default-progress-bar"></div>
        </div>
      </slot>
    </div>

    <div class="slot exit-webxr-ar-button">
      <slot name="exit-webxr-ar-button">
        <a id="default-exit-webxr-ar-button" part="default-exit-webxr-ar-button"
            tabindex="3"
            aria-label="Exit AR"
            aria-hidden="true">
          ${CloseIcon}
        </a>
      </slot>
    </div>
  </div>
</div>
<div class="screen-reader-only" role="region" aria-label="Live announcements">
  <span id="status" role="status"></span>
</div>`,
	makeTemplate = shadowRoot => {
		D(templateResult, shadowRoot)
	},
	_taskCache$1 = new WeakMap;

function DRACOWorker() {
	let decoderConfig, decoderPending;
	onmessage = function(e) {
		let message = e.data;
		switch (message.type) {
			case "init":
				decoderConfig = message.decoderConfig, decoderPending = new Promise(function(resolve) {
					decoderConfig.onModuleLoaded = function(draco) {
						resolve({
							draco: draco
						})
					}, DracoDecoderModule(decoderConfig)
				});
				break;
			case "decode":
				let buffer = message.buffer,
					taskConfig = message.taskConfig;
				decoderPending.then(module => {
					let draco = module.draco,
						decoder = new draco.Decoder;
					try {
						let geometry = function(draco, decoder, array, taskConfig) {
								let dracoGeometry, decodingStatus;
								let attributeIDs = taskConfig.attributeIDs,
									attributeTypes = taskConfig.attributeTypes,
									geometryType = decoder.GetEncodedGeometryType(array);
								if (geometryType === draco.TRIANGULAR_MESH) dracoGeometry = new draco.Mesh, decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);
								else if (geometryType === draco.POINT_CLOUD) dracoGeometry = new draco.PointCloud, decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);
								else throw Error("THREE.DRACOLoader: Unexpected geometry type.");
								if (!decodingStatus.ok() || 0 === dracoGeometry.ptr) throw Error("THREE.DRACOLoader: Decoding failed: " + decodingStatus.error_msg());
								let geometry = {
									index: null,
									attributes: []
								};
								for (let attributeName in attributeIDs) {
									let attribute, attributeID;
									let attributeType = self[attributeTypes[attributeName]];
									if (taskConfig.useUniqueIDs) attributeID = attributeIDs[attributeName], attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);
									else {
										if (-1 === (attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]))) continue;
										attribute = decoder.GetAttribute(dracoGeometry, attributeID)
									}
									let attributeResult = function(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
										let numComponents = attribute.num_components(),
											numValues = dracoGeometry.num_points() * numComponents,
											byteLength = numValues * attributeType.BYTES_PER_ELEMENT,
											dataType = function(draco, attributeType) {
												switch (attributeType) {
													case Float32Array:
														return draco.DT_FLOAT32;
													case Int8Array:
														return draco.DT_INT8;
													case Int16Array:
														return draco.DT_INT16;
													case Int32Array:
														return draco.DT_INT32;
													case Uint8Array:
														return draco.DT_UINT8;
													case Uint16Array:
														return draco.DT_UINT16;
													case Uint32Array:
														return draco.DT_UINT32
												}
											}(draco, attributeType),
											ptr = draco._malloc(byteLength);
										decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
										let array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
										return draco._free(ptr), {
											name: attributeName,
											array: array,
											itemSize: numComponents
										}
									}(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
									"color" === attributeName && (attributeResult.vertexColorSpace = taskConfig.vertexColorSpace), geometry.attributes.push(attributeResult)
								}
								return geometryType === draco.TRIANGULAR_MESH && (geometry.index = function(draco, decoder, dracoGeometry) {
									let numIndices = 3 * dracoGeometry.num_faces(),
										byteLength = 4 * numIndices,
										ptr = draco._malloc(byteLength);
									decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
									let index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
									return draco._free(ptr), {
										array: index,
										itemSize: 1
									}
								}(draco, decoder, dracoGeometry)), draco.destroy(dracoGeometry), geometry
							}(draco, decoder, new Int8Array(buffer), taskConfig),
							buffers = geometry.attributes.map(attr => attr.array.buffer);
						geometry.index && buffers.push(geometry.index.array.buffer), self.postMessage({
							type: "decode",
							id: message.id,
							geometry
						}, buffers)
					} catch (error) {
						console.error(error), self.postMessage({
							type: "error",
							id: message.id,
							error: error.message
						})
					} finally {
						draco.destroy(decoder)
					}
				})
		}
	}
}

function toTrianglesDrawMode(geometry, drawMode) {
	if (0 === drawMode) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), geometry;
	if (2 !== drawMode && 1 !== drawMode) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode), geometry;
	{
		let index = geometry.getIndex();
		if (null === index) {
			let indices = [],
				position = geometry.getAttribute("position");
			if (void 0 === position) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), geometry;
			for (let i = 0; i < position.count; i++) indices.push(i);
			geometry.setIndex(indices), index = geometry.getIndex()
		}
		let numberOfTriangles = index.count - 2,
			newIndices = [];
		if (2 === drawMode)
			for (let i = 1; i <= numberOfTriangles; i++) newIndices.push(index.getX(0)), newIndices.push(index.getX(i)), newIndices.push(index.getX(i + 1));
		else
			for (let i = 0; i < numberOfTriangles; i++) i % 2 == 0 ? (newIndices.push(index.getX(i)), newIndices.push(index.getX(i + 1)), newIndices.push(index.getX(i + 2))) : (newIndices.push(index.getX(i + 2)), newIndices.push(index.getX(i + 1)), newIndices.push(index.getX(i)));
		newIndices.length / 3 !== numberOfTriangles && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
		let newGeometry = geometry.clone();
		return newGeometry.setIndex(newIndices), newGeometry.clearGroups(), newGeometry
	}
}
class GLTFLoader extends Loader {
	constructor(manager) {
		super(manager), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(parser) {
			return new GLTFMaterialsClearcoatExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFTextureBasisUExtension(parser)
		}), this.register(function(parser) {
			return new GLTFTextureWebPExtension(parser)
		}), this.register(function(parser) {
			return new GLTFTextureAVIFExtension(parser)
		}), this.register(function(parser) {
			return new GLTFMaterialsSheenExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFMaterialsTransmissionExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFMaterialsVolumeExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFMaterialsIorExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFMaterialsEmissiveStrengthExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFMaterialsSpecularExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFMaterialsIridescenceExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFMaterialsAnisotropyExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFMaterialsBumpExtension$1(parser)
		}), this.register(function(parser) {
			return new GLTFLightsExtension(parser)
		}), this.register(function(parser) {
			return new GLTFMeshoptCompression(parser)
		}), this.register(function(parser) {
			return new GLTFMeshGpuInstancing$1(parser)
		})
	}
	load(url, onLoad, onProgress, onError) {
		let resourcePath;
		let scope = this;
		if ("" !== this.resourcePath) resourcePath = this.resourcePath;
		else if ("" !== this.path) {
			let relativeUrl = LoaderUtils.extractUrlBase(url);
			resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path)
		} else resourcePath = LoaderUtils.extractUrlBase(url);
		this.manager.itemStart(url);
		let _onError = function(e) {
				onError ? onError(e) : console.error(e), scope.manager.itemError(url), scope.manager.itemEnd(url)
			},
			loader = new FileLoader(this.manager);
		loader.setPath(this.path), loader.setResponseType("arraybuffer"), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials), loader.load(url, function(data) {
			try {
				scope.parse(data, resourcePath, function(gltf) {
					onLoad(gltf), scope.manager.itemEnd(url)
				}, _onError)
			} catch (e) {
				_onError(e)
			}
		}, onProgress, _onError)
	}
	setDRACOLoader(dracoLoader) {
		return this.dracoLoader = dracoLoader, this
	}
	setDDSLoader() {
		throw Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
	}
	setKTX2Loader(ktx2Loader) {
		return this.ktx2Loader = ktx2Loader, this
	}
	setMeshoptDecoder(meshoptDecoder) {
		return this.meshoptDecoder = meshoptDecoder, this
	}
	register(callback) {
		return -1 === this.pluginCallbacks.indexOf(callback) && this.pluginCallbacks.push(callback), this
	}
	unregister(callback) {
		return -1 !== this.pluginCallbacks.indexOf(callback) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1), this
	}
	parse(data, path, onLoad, onError) {
		let json;
		let extensions = {},
			plugins = {},
			textDecoder = new TextDecoder;
		if ("string" == typeof data) json = JSON.parse(data);
		else if (data instanceof ArrayBuffer) {
			if (textDecoder.decode(new Uint8Array(data, 0, 4)) === BINARY_EXTENSION_HEADER_MAGIC) {
				try {
					extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)
				} catch (error) {
					onError && onError(error);
					return
				}
				json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)
			} else json = JSON.parse(textDecoder.decode(data))
		} else json = data;
		if (void 0 === json.asset || json.asset.version[0] < 2) {
			onError && onError(Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
			return
		}
		let parser = new GLTFParser(json, {
			path: path || this.resourcePath || "",
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder
		});
		parser.fileLoader.setRequestHeader(this.requestHeader);
		for (let i = 0; i < this.pluginCallbacks.length; i++) {
			let plugin = this.pluginCallbacks[i](parser);
			plugin.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), plugins[plugin.name] = plugin, extensions[plugin.name] = !0
		}
		if (json.extensionsUsed)
			for (let i = 0; i < json.extensionsUsed.length; ++i) {
				let extensionName = json.extensionsUsed[i],
					extensionsRequired = json.extensionsRequired || [];
				switch (extensionName) {
					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[extensionName] = new GLTFMaterialsUnlitExtension$1;
						break;
					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
						break;
					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[extensionName] = new GLTFTextureTransformExtension;
						break;
					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[extensionName] = new GLTFMeshQuantizationExtension;
						break;
					default:
						extensionsRequired.indexOf(extensionName) >= 0 && void 0 === plugins[extensionName] && console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".')
				}
			}
		parser.setExtensions(extensions), parser.setPlugins(plugins), parser.parse(onLoad, onError)
	}
	parseAsync(data, path) {
		let scope = this;
		return new Promise(function(resolve, reject) {
			scope.parse(data, path, resolve, reject)
		})
	}
}

function GLTFRegistry() {
	let objects = {};
	return {
		get: function(key) {
			return objects[key]
		},
		add: function(key, object) {
			objects[key] = object
		},
		remove: function(key) {
			delete objects[key]
		},
		removeAll: function() {
			objects = {}
		}
	}
}
let EXTENSIONS = {
	KHR_BINARY_GLTF: "KHR_binary_glTF",
	KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
	KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
	KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
	KHR_MATERIALS_IOR: "KHR_materials_ior",
	KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
	KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
	KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
	KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
	KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
	KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
	KHR_MATERIALS_VOLUME: "KHR_materials_volume",
	KHR_TEXTURE_BASISU: "KHR_texture_basisu",
	KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
	KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
	KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
	EXT_MATERIALS_BUMP: "EXT_materials_bump",
	EXT_TEXTURE_WEBP: "EXT_texture_webp",
	EXT_TEXTURE_AVIF: "EXT_texture_avif",
	EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
	EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class GLTFLightsExtension {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL, this.cache = {
			refs: {},
			uses: {}
		}
	}
	_markDefs() {
		let parser = this.parser,
			nodeDefs = this.parser.json.nodes || [];
		for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
			let nodeDef = nodeDefs[nodeIndex];
			nodeDef.extensions && nodeDef.extensions[this.name] && void 0 !== nodeDef.extensions[this.name].light && parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)
		}
	}
	_loadLight(lightIndex) {
		let lightNode;
		let parser = this.parser,
			cacheKey = "light:" + lightIndex,
			dependency = parser.cache.get(cacheKey);
		if (dependency) return dependency;
		let json = parser.json,
			lightDef = ((json.extensions && json.extensions[this.name] || {}).lights || [])[lightIndex],
			color = new Color(16777215);
		void 0 !== lightDef.color && color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
		let range = void 0 !== lightDef.range ? lightDef.range : 0;
		switch (lightDef.type) {
			case "directional":
				(lightNode = new DirectionalLight(color)).target.position.set(0, 0, -1), lightNode.add(lightNode.target);
				break;
			case "point":
				(lightNode = new PointLight(color)).distance = range;
				break;
			case "spot":
				(lightNode = new SpotLight(color)).distance = range, lightDef.spot = lightDef.spot || {}, lightDef.spot.innerConeAngle = void 0 !== lightDef.spot.innerConeAngle ? lightDef.spot.innerConeAngle : 0, lightDef.spot.outerConeAngle = void 0 !== lightDef.spot.outerConeAngle ? lightDef.spot.outerConeAngle : Math.PI / 4, lightNode.angle = lightDef.spot.outerConeAngle, lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle, lightNode.target.position.set(0, 0, -1), lightNode.add(lightNode.target);
				break;
			default:
				throw Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type)
		}
		return lightNode.position.set(0, 0, 0), lightNode.decay = 2, assignExtrasToUserData(lightNode, lightDef), void 0 !== lightDef.intensity && (lightNode.intensity = lightDef.intensity), lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex), dependency = Promise.resolve(lightNode), parser.cache.add(cacheKey, dependency), dependency
	}
	getDependency(type, index) {
		if ("light" === type) return this._loadLight(index)
	}
	createNodeAttachment(nodeIndex) {
		let self1 = this,
			parser = this.parser,
			nodeDef = parser.json.nodes[nodeIndex],
			lightIndex = (nodeDef.extensions && nodeDef.extensions[this.name] || {}).light;
		return void 0 === lightIndex ? null : this._loadLight(lightIndex).then(function(light) {
			return parser._getNodeRef(self1.cache, lightIndex, light)
		})
	}
}
class GLTFMaterialsUnlitExtension$1 {
	constructor() {
		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT
	}
	getMaterialType() {
		return MeshBasicMaterial
	}
	extendParams(materialParams, materialDef, parser) {
		let pending = [];
		materialParams.color = new Color(1, 1, 1), materialParams.opacity = 1;
		let metallicRoughness = materialDef.pbrMetallicRoughness;
		if (metallicRoughness) {
			if (Array.isArray(metallicRoughness.baseColorFactor)) {
				let array = metallicRoughness.baseColorFactor;
				materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace), materialParams.opacity = array[3]
			}
			void 0 !== metallicRoughness.baseColorTexture && pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace))
		}
		return Promise.all(pending)
	}
}
class GLTFMaterialsEmissiveStrengthExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH
	}
	extendMaterialParams(materialIndex, materialParams) {
		let materialDef = this.parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
		return void 0 !== emissiveStrength && (materialParams.emissiveIntensity = emissiveStrength), Promise.resolve()
	}
}
class GLTFMaterialsClearcoatExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT
	}
	getMaterialType(materialIndex) {
		let materialDef = this.parser.json.materials[materialIndex];
		return materialDef.extensions && materialDef.extensions[this.name] ? MeshPhysicalMaterial : null
	}
	extendMaterialParams(materialIndex, materialParams) {
		let parser = this.parser,
			materialDef = parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let pending = [],
			extension = materialDef.extensions[this.name];
		if (void 0 !== extension.clearcoatFactor && (materialParams.clearcoat = extension.clearcoatFactor), void 0 !== extension.clearcoatTexture && pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture)), void 0 !== extension.clearcoatRoughnessFactor && (materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor), void 0 !== extension.clearcoatRoughnessTexture && pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture)), void 0 !== extension.clearcoatNormalTexture && (pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture)), void 0 !== extension.clearcoatNormalTexture.scale)) {
			let scale = extension.clearcoatNormalTexture.scale;
			materialParams.clearcoatNormalScale = new Vector2(scale, scale)
		}
		return Promise.all(pending)
	}
}
class GLTFMaterialsIridescenceExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE
	}
	getMaterialType(materialIndex) {
		let materialDef = this.parser.json.materials[materialIndex];
		return materialDef.extensions && materialDef.extensions[this.name] ? MeshPhysicalMaterial : null
	}
	extendMaterialParams(materialIndex, materialParams) {
		let parser = this.parser,
			materialDef = parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let pending = [],
			extension = materialDef.extensions[this.name];
		return void 0 !== extension.iridescenceFactor && (materialParams.iridescence = extension.iridescenceFactor), void 0 !== extension.iridescenceTexture && pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture)), void 0 !== extension.iridescenceIor && (materialParams.iridescenceIOR = extension.iridescenceIor), void 0 === materialParams.iridescenceThicknessRange && (materialParams.iridescenceThicknessRange = [100, 400]), void 0 !== extension.iridescenceThicknessMinimum && (materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum), void 0 !== extension.iridescenceThicknessMaximum && (materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum), void 0 !== extension.iridescenceThicknessTexture && pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture)), Promise.all(pending)
	}
}
class GLTFMaterialsSheenExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_SHEEN
	}
	getMaterialType(materialIndex) {
		let materialDef = this.parser.json.materials[materialIndex];
		return materialDef.extensions && materialDef.extensions[this.name] ? MeshPhysicalMaterial : null
	}
	extendMaterialParams(materialIndex, materialParams) {
		let parser = this.parser,
			materialDef = parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let pending = [];
		materialParams.sheenColor = new Color(0, 0, 0), materialParams.sheenRoughness = 0, materialParams.sheen = 1;
		let extension = materialDef.extensions[this.name];
		if (void 0 !== extension.sheenColorFactor) {
			let colorFactor = extension.sheenColorFactor;
			materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace)
		}
		return void 0 !== extension.sheenRoughnessFactor && (materialParams.sheenRoughness = extension.sheenRoughnessFactor), void 0 !== extension.sheenColorTexture && pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace)), void 0 !== extension.sheenRoughnessTexture && pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture)), Promise.all(pending)
	}
}
class GLTFMaterialsTransmissionExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION
	}
	getMaterialType(materialIndex) {
		let materialDef = this.parser.json.materials[materialIndex];
		return materialDef.extensions && materialDef.extensions[this.name] ? MeshPhysicalMaterial : null
	}
	extendMaterialParams(materialIndex, materialParams) {
		let parser = this.parser,
			materialDef = parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let pending = [],
			extension = materialDef.extensions[this.name];
		return void 0 !== extension.transmissionFactor && (materialParams.transmission = extension.transmissionFactor), void 0 !== extension.transmissionTexture && pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture)), Promise.all(pending)
	}
}
class GLTFMaterialsVolumeExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_VOLUME
	}
	getMaterialType(materialIndex) {
		let materialDef = this.parser.json.materials[materialIndex];
		return materialDef.extensions && materialDef.extensions[this.name] ? MeshPhysicalMaterial : null
	}
	extendMaterialParams(materialIndex, materialParams) {
		let parser = this.parser,
			materialDef = parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let pending = [],
			extension = materialDef.extensions[this.name];
		materialParams.thickness = void 0 !== extension.thicknessFactor ? extension.thicknessFactor : 0, void 0 !== extension.thicknessTexture && pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture)), materialParams.attenuationDistance = extension.attenuationDistance || 1 / 0;
		let colorArray = extension.attenuationColor || [1, 1, 1];
		return materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace), Promise.all(pending)
	}
}
class GLTFMaterialsIorExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_IOR
	}
	getMaterialType(materialIndex) {
		let materialDef = this.parser.json.materials[materialIndex];
		return materialDef.extensions && materialDef.extensions[this.name] ? MeshPhysicalMaterial : null
	}
	extendMaterialParams(materialIndex, materialParams) {
		let materialDef = this.parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let extension = materialDef.extensions[this.name];
		return materialParams.ior = void 0 !== extension.ior ? extension.ior : 1.5, Promise.resolve()
	}
}
class GLTFMaterialsSpecularExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR
	}
	getMaterialType(materialIndex) {
		let materialDef = this.parser.json.materials[materialIndex];
		return materialDef.extensions && materialDef.extensions[this.name] ? MeshPhysicalMaterial : null
	}
	extendMaterialParams(materialIndex, materialParams) {
		let parser = this.parser,
			materialDef = parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let pending = [],
			extension = materialDef.extensions[this.name];
		materialParams.specularIntensity = void 0 !== extension.specularFactor ? extension.specularFactor : 1, void 0 !== extension.specularTexture && pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
		let colorArray = extension.specularColorFactor || [1, 1, 1];
		return materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace), void 0 !== extension.specularColorTexture && pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace)), Promise.all(pending)
	}
}
class GLTFMaterialsBumpExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.EXT_MATERIALS_BUMP
	}
	getMaterialType(materialIndex) {
		let materialDef = this.parser.json.materials[materialIndex];
		return materialDef.extensions && materialDef.extensions[this.name] ? MeshPhysicalMaterial : null
	}
	extendMaterialParams(materialIndex, materialParams) {
		let parser = this.parser,
			materialDef = parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let pending = [],
			extension = materialDef.extensions[this.name];
		return materialParams.bumpScale = void 0 !== extension.bumpFactor ? extension.bumpFactor : 1, void 0 !== extension.bumpTexture && pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture)), Promise.all(pending)
	}
}
class GLTFMaterialsAnisotropyExtension$1 {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY
	}
	getMaterialType(materialIndex) {
		let materialDef = this.parser.json.materials[materialIndex];
		return materialDef.extensions && materialDef.extensions[this.name] ? MeshPhysicalMaterial : null
	}
	extendMaterialParams(materialIndex, materialParams) {
		let parser = this.parser,
			materialDef = parser.json.materials[materialIndex];
		if (!materialDef.extensions || !materialDef.extensions[this.name]) return Promise.resolve();
		let pending = [],
			extension = materialDef.extensions[this.name];
		return void 0 !== extension.anisotropyStrength && (materialParams.anisotropy = extension.anisotropyStrength), void 0 !== extension.anisotropyRotation && (materialParams.anisotropyRotation = extension.anisotropyRotation), void 0 !== extension.anisotropyTexture && pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture)), Promise.all(pending)
	}
}
class GLTFTextureBasisUExtension {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.KHR_TEXTURE_BASISU
	}
	loadTexture(textureIndex) {
		let parser = this.parser,
			json = parser.json,
			textureDef = json.textures[textureIndex];
		if (!textureDef.extensions || !textureDef.extensions[this.name]) return null;
		let extension = textureDef.extensions[this.name],
			loader = parser.options.ktx2Loader;
		if (!loader) {
			if (!(json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0)) return null;
			throw Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures")
		}
		return parser.loadTextureImage(textureIndex, extension.source, loader)
	}
}
class GLTFTextureWebPExtension {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.EXT_TEXTURE_WEBP, this.isSupported = null
	}
	loadTexture(textureIndex) {
		let name = this.name,
			parser = this.parser,
			json = parser.json,
			textureDef = json.textures[textureIndex];
		if (!textureDef.extensions || !textureDef.extensions[name]) return null;
		let extension = textureDef.extensions[name],
			source = json.images[extension.source],
			loader = parser.textureLoader;
		if (source.uri) {
			let handler = parser.options.manager.getHandler(source.uri);
			null !== handler && (loader = handler)
		}
		return this.detectSupport().then(function(isSupported) {
			if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
			if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) throw Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
			return parser.loadTexture(textureIndex)
		})
	}
	detectSupport() {
		return this.isSupported || (this.isSupported = new Promise(function(resolve) {
			let image = new Image;
			image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", image.onload = image.onerror = function() {
				resolve(1 === image.height)
			}
		})), this.isSupported
	}
}
class GLTFTextureAVIFExtension {
	constructor(parser) {
		this.parser = parser, this.name = EXTENSIONS.EXT_TEXTURE_AVIF, this.isSupported = null
	}
	loadTexture(textureIndex) {
		let name = this.name,
			parser = this.parser,
			json = parser.json,
			textureDef = json.textures[textureIndex];
		if (!textureDef.extensions || !textureDef.extensions[name]) return null;
		let extension = textureDef.extensions[name],
			source = json.images[extension.source],
			loader = parser.textureLoader;
		if (source.uri) {
			let handler = parser.options.manager.getHandler(source.uri);
			null !== handler && (loader = handler)
		}
		return this.detectSupport().then(function(isSupported) {
			if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
			if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) throw Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
			return parser.loadTexture(textureIndex)
		})
	}
	detectSupport() {
		return this.isSupported || (this.isSupported = new Promise(function(resolve) {
			let image = new Image;
			image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", image.onload = image.onerror = function() {
				resolve(1 === image.height)
			}
		})), this.isSupported
	}
}
class GLTFMeshoptCompression {
	constructor(parser) {
		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION, this.parser = parser
	}
	loadBufferView(index) {
		let json = this.parser.json,
			bufferView = json.bufferViews[index];
		if (!bufferView.extensions || !bufferView.extensions[this.name]) return null;
		{
			let extensionDef = bufferView.extensions[this.name],
				buffer = this.parser.getDependency("buffer", extensionDef.buffer),
				decoder = this.parser.options.meshoptDecoder;
			if (!decoder || !decoder.supported) {
				if (!(json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0)) return null;
				throw Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files")
			}
			return buffer.then(function(res) {
				let byteOffset = extensionDef.byteOffset || 0,
					byteLength = extensionDef.byteLength || 0,
					count = extensionDef.count,
					stride = extensionDef.byteStride,
					source = new Uint8Array(res, byteOffset, byteLength);
				return decoder.decodeGltfBufferAsync ? decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res) {
					return res.buffer
				}) : decoder.ready.then(function() {
					let result = new ArrayBuffer(count * stride);
					return decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter), result
				})
			})
		}
	}
}
class GLTFMeshGpuInstancing$1 {
	constructor(parser) {
		this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING, this.parser = parser
	}
	createNodeMesh(nodeIndex) {
		let json = this.parser.json,
			nodeDef = json.nodes[nodeIndex];
		if (!nodeDef.extensions || !nodeDef.extensions[this.name] || void 0 === nodeDef.mesh) return null;
		for (let primitive of json.meshes[nodeDef.mesh].primitives)
			if (primitive.mode !== WEBGL_CONSTANTS$1.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS$1.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS$1.TRIANGLE_FAN && void 0 !== primitive.mode) return null;
		let attributesDef = nodeDef.extensions[this.name].attributes,
			pending = [],
			attributes = {};
		for (let key in attributesDef) pending.push(this.parser.getDependency("accessor", attributesDef[key]).then(accessor => (attributes[key] = accessor, attributes[key])));
		return pending.length < 1 ? null : (pending.push(this.parser.createNodeMesh(nodeIndex)), Promise.all(pending).then(results => {
			let nodeObject = results.pop(),
				meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject],
				count = results[0].count,
				instancedMeshes = [];
			for (let mesh of meshes) {
				let m = new Matrix4,
					p = new Vector3,
					q = new Quaternion,
					s = new Vector3(1, 1, 1),
					instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
				for (let i = 0; i < count; i++) attributes.TRANSLATION && p.fromBufferAttribute(attributes.TRANSLATION, i), attributes.ROTATION && q.fromBufferAttribute(attributes.ROTATION, i), attributes.SCALE && s.fromBufferAttribute(attributes.SCALE, i), instancedMesh.setMatrixAt(i, m.compose(p, q, s));
				for (let attributeName in attributes)
					if ("_COLOR_0" === attributeName) {
						let attr = attributes[attributeName];
						instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized)
					} else "TRANSLATION" !== attributeName && "ROTATION" !== attributeName && "SCALE" !== attributeName && mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
				Object3D.prototype.copy.call(instancedMesh, mesh), this.parser.assignFinalMaterial(instancedMesh), instancedMeshes.push(instancedMesh)
			}
			return nodeObject.isGroup ? (nodeObject.clear(), nodeObject.add(...instancedMeshes), nodeObject) : instancedMeshes[0]
		}))
	}
}
let BINARY_EXTENSION_HEADER_MAGIC = "glTF",
	BINARY_EXTENSION_CHUNK_TYPES = {
		JSON: 1313821514,
		BIN: 5130562
	};
class GLTFBinaryExtension {
	constructor(data) {
		this.name = EXTENSIONS.KHR_BINARY_GLTF, this.content = null, this.body = null;
		let headerView = new DataView(data, 0, 12),
			textDecoder = new TextDecoder;
		if (this.header = {
				magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
				version: headerView.getUint32(4, !0),
				length: headerView.getUint32(8, !0)
			}, this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) throw Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
		if (this.header.version < 2) throw Error("THREE.GLTFLoader: Legacy binary file detected.");
		let chunkContentsLength = this.header.length - 12,
			chunkView = new DataView(data, 12),
			chunkIndex = 0;
		for (; chunkIndex < chunkContentsLength;) {
			let chunkLength = chunkView.getUint32(chunkIndex, !0);
			chunkIndex += 4;
			let chunkType = chunkView.getUint32(chunkIndex, !0);
			if (chunkIndex += 4, chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
				let contentArray = new Uint8Array(data, 12 + chunkIndex, chunkLength);
				this.content = textDecoder.decode(contentArray)
			} else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
				let byteOffset = 12 + chunkIndex;
				this.body = data.slice(byteOffset, byteOffset + chunkLength)
			}
			chunkIndex += chunkLength
		}
		if (null === this.content) throw Error("THREE.GLTFLoader: JSON content not found.")
	}
}
class GLTFDracoMeshCompressionExtension {
	constructor(json, dracoLoader) {
		if (!dracoLoader) throw Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION, this.json = json, this.dracoLoader = dracoLoader, this.dracoLoader.preload()
	}
	decodePrimitive(primitive, parser) {
		let json = this.json,
			dracoLoader = this.dracoLoader,
			bufferViewIndex = primitive.extensions[this.name].bufferView,
			gltfAttributeMap = primitive.extensions[this.name].attributes,
			threeAttributeMap = {},
			attributeNormalizedMap = {},
			attributeTypeMap = {};
		for (let attributeName in gltfAttributeMap) threeAttributeMap[ATTRIBUTES[attributeName] || attributeName.toLowerCase()] = gltfAttributeMap[attributeName];
		for (let attributeName in primitive.attributes) {
			let threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
			if (void 0 !== gltfAttributeMap[attributeName]) {
				let accessorDef = json.accessors[primitive.attributes[attributeName]],
					componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
				attributeTypeMap[threeAttributeName] = componentType.name, attributeNormalizedMap[threeAttributeName] = !0 === accessorDef.normalized
			}
		}
		return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
			return new Promise(function(resolve, reject) {
				dracoLoader.decodeDracoFile(bufferView, function(geometry) {
					for (let attributeName in geometry.attributes) {
						let attribute = geometry.attributes[attributeName],
							normalized = attributeNormalizedMap[attributeName];
						void 0 !== normalized && (attribute.normalized = normalized)
					}
					resolve(geometry)
				}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject)
			})
		})
	}
}
class GLTFTextureTransformExtension {
	constructor() {
		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM
	}
	extendTexture(texture, transform) {
		return (void 0 === transform.texCoord || transform.texCoord === texture.channel) && void 0 === transform.offset && void 0 === transform.rotation && void 0 === transform.scale || (texture = texture.clone(), void 0 !== transform.texCoord && (texture.channel = transform.texCoord), void 0 !== transform.offset && texture.offset.fromArray(transform.offset), void 0 !== transform.rotation && (texture.rotation = transform.rotation), void 0 !== transform.scale && texture.repeat.fromArray(transform.scale), texture.needsUpdate = !0), texture
	}
}
class GLTFMeshQuantizationExtension {
	constructor() {
		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION
	}
}
class GLTFCubicSplineInterpolant extends Interpolant {
	constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
		super(parameterPositions, sampleValues, sampleSize, resultBuffer)
	}
	copySampleValue_(index) {
		let result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;
		for (let i = 0; i !== valueSize; i++) result[i] = values[offset + i];
		return result
	}
	interpolate_(i1, t0, t, t1) {
		let result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			stride2 = 2 * stride,
			stride3 = 3 * stride,
			td = t1 - t0,
			p = (t - t0) / td,
			pp = p * p,
			ppp = pp * p,
			offset1 = i1 * stride3,
			offset0 = offset1 - stride3,
			s2 = -2 * ppp + 3 * pp,
			s3 = ppp - pp,
			s0 = 1 - s2,
			s1 = s3 - pp + p;
		for (let i = 0; i !== stride; i++) {
			let p0 = values[offset0 + i + stride],
				m0 = values[offset0 + i + stride2] * td,
				p1 = values[offset1 + i + stride],
				m1 = values[offset1 + i] * td;
			result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1
		}
		return result
	}
}
let _q = new Quaternion;
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
	interpolate_(i1, t0, t, t1) {
		let result = super.interpolate_(i1, t0, t, t1);
		return _q.fromArray(result).normalize().toArray(result), result
	}
}
let WEBGL_CONSTANTS$1 = {
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		TRIANGLE_STRIP: 5,
		TRIANGLE_FAN: 6
	},
	WEBGL_COMPONENT_TYPES = {
		5120: Int8Array,
		5121: Uint8Array,
		5122: Int16Array,
		5123: Uint16Array,
		5125: Uint32Array,
		5126: Float32Array
	},
	WEBGL_FILTERS = {
		9728: NearestFilter,
		9729: 1006,
		9984: 1004,
		9985: 1007,
		9986: 1005,
		9987: 1008
	},
	WEBGL_WRAPPINGS = {
		33071: 1001,
		33648: 1002,
		10497: 1e3
	},
	WEBGL_TYPE_SIZES = {
		SCALAR: 1,
		VEC2: 2,
		VEC3: 3,
		VEC4: 4,
		MAT2: 4,
		MAT3: 9,
		MAT4: 16
	},
	ATTRIBUTES = {
		POSITION: "position",
		NORMAL: "normal",
		TANGENT: "tangent",
		TEXCOORD_0: "uv",
		TEXCOORD_1: "uv1",
		TEXCOORD_2: "uv2",
		TEXCOORD_3: "uv3",
		COLOR_0: "color",
		WEIGHTS_0: "skinWeight",
		JOINTS_0: "skinIndex"
	},
	PATH_PROPERTIES$1 = {
		scale: "scale",
		translation: "position",
		rotation: "quaternion",
		weights: "morphTargetInfluences"
	},
	INTERPOLATION = {
		CUBICSPLINE: void 0,
		LINEAR: 2301,
		STEP: 2300
	},
	ALPHA_MODES = {
		OPAQUE: "OPAQUE",
		MASK: "MASK",
		BLEND: "BLEND"
	};

function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
	for (let name in objectDef.extensions) void 0 === knownExtensions[name] && (object.userData.gltfExtensions = object.userData.gltfExtensions || {}, object.userData.gltfExtensions[name] = objectDef.extensions[name])
}

function assignExtrasToUserData(object, gltfDef) {
	void 0 !== gltfDef.extras && ("object" == typeof gltfDef.extras ? Object.assign(object.userData, gltfDef.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras))
}

function createAttributesKey(attributes) {
	let attributesKey = "",
		keys = Object.keys(attributes).sort();
	for (let i = 0, il = keys.length; i < il; i++) attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
	return attributesKey
}

function getNormalizedComponentScale(constructor) {
	switch (constructor) {
		case Int8Array:
			return 1 / 127;
		case Uint8Array:
			return 1 / 255;
		case Int16Array:
			return 1 / 32767;
		case Uint16Array:
			return 1 / 65535;
		default:
			throw Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
	}
}
let _identityMatrix = new Matrix4;
class GLTFParser {
	constructor(json = {}, options = {}) {
		this.json = json, this.extensions = {}, this.plugins = {}, this.options = options, this.cache = new GLTFRegistry, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
			refs: {},
			uses: {}
		}, this.cameraCache = {
			refs: {},
			uses: {}
		}, this.lightCache = {
			refs: {},
			uses: {}
		}, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
		let isSafari = !1,
			isFirefox = !1,
			firefoxVersion = -1;
		"undefined" != typeof navigator && (isSafari = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), firefoxVersion = (isFirefox = navigator.userAgent.indexOf("Firefox") > -1) ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || isSafari || isFirefox && firefoxVersion < 98 ? this.textureLoader = new TextureLoader(this.options.manager) : this.textureLoader = new ImageBitmapLoader(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new FileLoader(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
	}
	setExtensions(extensions) {
		this.extensions = extensions
	}
	setPlugins(plugins) {
		this.plugins = plugins
	}
	parse(onLoad, onError) {
		let parser = this,
			json = this.json,
			extensions = this.extensions;
		this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(ext) {
			return ext._markDefs && ext._markDefs()
		}), Promise.all(this._invokeAll(function(ext) {
			return ext.beforeRoot && ext.beforeRoot()
		})).then(function() {
			return Promise.all([parser.getDependencies("scene"), parser.getDependencies("animation"), parser.getDependencies("camera")])
		}).then(function(dependencies) {
			let result = {
				scene: dependencies[0][json.scene || 0],
				scenes: dependencies[0],
				animations: dependencies[1],
				cameras: dependencies[2],
				asset: json.asset,
				parser: parser,
				userData: {}
			};
			return addUnknownExtensionsToUserData(extensions, result, json), assignExtrasToUserData(result, json), Promise.all(parser._invokeAll(function(ext) {
				return ext.afterRoot && ext.afterRoot(result)
			})).then(function() {
				onLoad(result)
			})
		}).catch(onError)
	}
	_markDefs() {
		let nodeDefs = this.json.nodes || [],
			skinDefs = this.json.skins || [],
			meshDefs = this.json.meshes || [];
		for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
			let joints = skinDefs[skinIndex].joints;
			for (let i = 0, il = joints.length; i < il; i++) nodeDefs[joints[i]].isBone = !0
		}
		for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
			let nodeDef = nodeDefs[nodeIndex];
			void 0 !== nodeDef.mesh && (this._addNodeRef(this.meshCache, nodeDef.mesh), void 0 !== nodeDef.skin && (meshDefs[nodeDef.mesh].isSkinnedMesh = !0)), void 0 !== nodeDef.camera && this._addNodeRef(this.cameraCache, nodeDef.camera)
		}
	}
	_addNodeRef(cache, index) {
		void 0 !== index && (void 0 === cache.refs[index] && (cache.refs[index] = cache.uses[index] = 0), cache.refs[index]++)
	}
	_getNodeRef(cache, index, object) {
		if (cache.refs[index] <= 1) return object;
		let ref = object.clone(),
			updateMappings = (original, clone) => {
				let mappings = this.associations.get(original);
				for (let [i, child] of(null != mappings && this.associations.set(clone, mappings), original.children.entries())) updateMappings(child, clone.children[i])
			};
		return updateMappings(object, ref), ref.name += "_instance_" + cache.uses[index]++, ref
	}
	_invokeOne(func) {
		let extensions = Object.values(this.plugins);
		extensions.push(this);
		for (let i = 0; i < extensions.length; i++) {
			let result = func(extensions[i]);
			if (result) return result
		}
		return null
	}
	_invokeAll(func) {
		let extensions = Object.values(this.plugins);
		extensions.unshift(this);
		let pending = [];
		for (let i = 0; i < extensions.length; i++) {
			let result = func(extensions[i]);
			result && pending.push(result)
		}
		return pending
	}
	getDependency(type, index) {
		let cacheKey = type + ":" + index,
			dependency = this.cache.get(cacheKey);
		if (!dependency) {
			switch (type) {
				case "scene":
					dependency = this.loadScene(index);
					break;
				case "node":
					dependency = this._invokeOne(function(ext) {
						return ext.loadNode && ext.loadNode(index)
					});
					break;
				case "mesh":
					dependency = this._invokeOne(function(ext) {
						return ext.loadMesh && ext.loadMesh(index)
					});
					break;
				case "accessor":
					dependency = this.loadAccessor(index);
					break;
				case "bufferView":
					dependency = this._invokeOne(function(ext) {
						return ext.loadBufferView && ext.loadBufferView(index)
					});
					break;
				case "buffer":
					dependency = this.loadBuffer(index);
					break;
				case "material":
					dependency = this._invokeOne(function(ext) {
						return ext.loadMaterial && ext.loadMaterial(index)
					});
					break;
				case "texture":
					dependency = this._invokeOne(function(ext) {
						return ext.loadTexture && ext.loadTexture(index)
					});
					break;
				case "skin":
					dependency = this.loadSkin(index);
					break;
				case "animation":
					dependency = this._invokeOne(function(ext) {
						return ext.loadAnimation && ext.loadAnimation(index)
					});
					break;
				case "camera":
					dependency = this.loadCamera(index);
					break;
				default:
					if (!(dependency = this._invokeOne(function(ext) {
							return ext != this && ext.getDependency && ext.getDependency(type, index)
						}))) throw Error("Unknown type: " + type)
			}
			this.cache.add(cacheKey, dependency)
		}
		return dependency
	}
	getDependencies(type) {
		let dependencies = this.cache.get(type);
		if (!dependencies) {
			let parser = this;
			dependencies = Promise.all((this.json[type + ("mesh" === type ? "es" : "s")] || []).map(function(def, index) {
				return parser.getDependency(type, index)
			})), this.cache.add(type, dependencies)
		}
		return dependencies
	}
	loadBuffer(bufferIndex) {
		let bufferDef = this.json.buffers[bufferIndex],
			loader = this.fileLoader;
		if (bufferDef.type && "arraybuffer" !== bufferDef.type) throw Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
		if (void 0 === bufferDef.uri && 0 === bufferIndex) return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
		let options = this.options;
		return new Promise(function(resolve, reject) {
			loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
				reject(Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'))
			})
		})
	}
	loadBufferView(bufferViewIndex) {
		let bufferViewDef = this.json.bufferViews[bufferViewIndex];
		return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
			let byteLength = bufferViewDef.byteLength || 0,
				byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice(byteOffset, byteOffset + byteLength)
		})
	}
	loadAccessor(accessorIndex) {
		let parser = this,
			json = this.json,
			accessorDef = this.json.accessors[accessorIndex];
		if (void 0 === accessorDef.bufferView && void 0 === accessorDef.sparse) {
			let itemSize = WEBGL_TYPE_SIZES[accessorDef.type],
				TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType],
				normalized = !0 === accessorDef.normalized;
			return Promise.resolve(new BufferAttribute(new TypedArray(accessorDef.count * itemSize), itemSize, normalized))
		}
		let pendingBufferViews = [];
		return void 0 !== accessorDef.bufferView ? pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView)) : pendingBufferViews.push(null), void 0 !== accessorDef.sparse && (pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView)), pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView))), Promise.all(pendingBufferViews).then(function(bufferViews) {
			let bufferAttribute;
			let bufferView = bufferViews[0],
				itemSize = WEBGL_TYPE_SIZES[accessorDef.type],
				TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType],
				elementBytes = TypedArray.BYTES_PER_ELEMENT,
				itemBytes = elementBytes * itemSize,
				byteOffset = accessorDef.byteOffset || 0,
				byteStride = void 0 !== accessorDef.bufferView ? json.bufferViews[accessorDef.bufferView].byteStride : void 0,
				normalized = !0 === accessorDef.normalized;
			if (byteStride && byteStride !== itemBytes) {
				let ibSlice = Math.floor(byteOffset / byteStride),
					ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count,
					ib = parser.cache.get(ibCacheKey);
				ib || (ib = new InterleavedBuffer(new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes), byteStride / elementBytes), parser.cache.add(ibCacheKey, ib)), bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized)
			} else bufferAttribute = new BufferAttribute(null === bufferView ? new TypedArray(accessorDef.count * itemSize) : new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize), itemSize, normalized);
			if (void 0 !== accessorDef.sparse) {
				let itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR,
					TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType],
					byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0,
					byteOffsetValues = accessorDef.sparse.values.byteOffset || 0,
					sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices),
					sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
				null !== bufferView && (bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized));
				for (let i = 0, il = sparseIndices.length; i < il; i++) {
					let index = sparseIndices[i];
					if (bufferAttribute.setX(index, sparseValues[i * itemSize]), itemSize >= 2 && bufferAttribute.setY(index, sparseValues[i * itemSize + 1]), itemSize >= 3 && bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]), itemSize >= 4 && bufferAttribute.setW(index, sparseValues[i * itemSize + 3]), itemSize >= 5) throw Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
				}
			}
			return bufferAttribute
		})
	}
	loadTexture(textureIndex) {
		let json = this.json,
			options = this.options,
			sourceIndex = json.textures[textureIndex].source,
			sourceDef = json.images[sourceIndex],
			loader = this.textureLoader;
		if (sourceDef.uri) {
			let handler = options.manager.getHandler(sourceDef.uri);
			null !== handler && (loader = handler)
		}
		return this.loadTextureImage(textureIndex, sourceIndex, loader)
	}
	loadTextureImage(textureIndex, sourceIndex, loader) {
		let parser = this,
			json = this.json,
			textureDef = json.textures[textureIndex],
			sourceDef = json.images[sourceIndex],
			cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
		if (this.textureCache[cacheKey]) return this.textureCache[cacheKey];
		let promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
			texture.flipY = !1, texture.name = textureDef.name || sourceDef.name || "", "" === texture.name && "string" == typeof sourceDef.uri && !1 === sourceDef.uri.startsWith("data:image/") && (texture.name = sourceDef.uri);
			let sampler = (json.samplers || {})[textureDef.sampler] || {};
			return texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || 1006, texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || 1008, texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || 1e3, texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || 1e3, parser.associations.set(texture, {
				textures: textureIndex
			}), texture
		}).catch(function() {
			return null
		});
		return this.textureCache[cacheKey] = promise, promise
	}
	loadImageSource(sourceIndex, loader) {
		let json = this.json,
			options = this.options;
		if (void 0 !== this.sourceCache[sourceIndex]) return this.sourceCache[sourceIndex].then(texture => texture.clone());
		let sourceDef = json.images[sourceIndex],
			URL1 = self.URL || self.webkitURL,
			sourceURI = sourceDef.uri || "",
			isObjectURL = !1;
		if (void 0 !== sourceDef.bufferView) sourceURI = this.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
			isObjectURL = !0;
			let blob = new Blob([bufferView], {
				type: sourceDef.mimeType
			});
			return sourceURI = URL1.createObjectURL(blob)
		});
		else if (void 0 === sourceDef.uri) throw Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
		let promise = Promise.resolve(sourceURI).then(function(sourceURI) {
			return new Promise(function(resolve, reject) {
				let onLoad = resolve;
				!0 === loader.isImageBitmapLoader && (onLoad = function(imageBitmap) {
					let texture = new Texture$1(imageBitmap);
					texture.needsUpdate = !0, resolve(texture)
				}), loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, void 0, reject)
			})
		}).then(function(texture) {
			var uri;
			return !0 === isObjectURL && URL1.revokeObjectURL(sourceURI), texture.userData.mimeType = sourceDef.mimeType || ((uri = sourceDef.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === uri.search(/^data\:image\/jpeg/) ? "image/jpeg" : uri.search(/\.webp($|\?)/i) > 0 || 0 === uri.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), texture
		}).catch(function(error) {
			throw console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI), error
		});
		return this.sourceCache[sourceIndex] = promise, promise
	}
	assignTexture(materialParams, mapName, mapDef, colorSpace1) {
		let parser = this;
		return this.getDependency("texture", mapDef.index).then(function(texture) {
			if (!texture) return null;
			if (void 0 !== mapDef.texCoord && mapDef.texCoord > 0 && ((texture = texture.clone()).channel = mapDef.texCoord), parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
				let transform = void 0 !== mapDef.extensions ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
				if (transform) {
					let gltfReference = parser.associations.get(texture);
					texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform), parser.associations.set(texture, gltfReference)
				}
			}
			return void 0 !== colorSpace1 && (texture.colorSpace = colorSpace1), materialParams[mapName] = texture, texture
		})
	}
	assignFinalMaterial(mesh) {
		let geometry = mesh.geometry,
			material = mesh.material,
			useDerivativeTangents = void 0 === geometry.attributes.tangent,
			useVertexColors = void 0 !== geometry.attributes.color,
			useFlatShading = void 0 === geometry.attributes.normal;
		if (mesh.isPoints) {
			let cacheKey = "PointsMaterial:" + material.uuid,
				pointsMaterial = this.cache.get(cacheKey);
			pointsMaterial || (pointsMaterial = new PointsMaterial, Material$1.prototype.copy.call(pointsMaterial, material), pointsMaterial.color.copy(material.color), pointsMaterial.map = material.map, pointsMaterial.sizeAttenuation = !1, this.cache.add(cacheKey, pointsMaterial)), material = pointsMaterial
		} else if (mesh.isLine) {
			let cacheKey = "LineBasicMaterial:" + material.uuid,
				lineMaterial = this.cache.get(cacheKey);
			lineMaterial || (lineMaterial = new LineBasicMaterial, Material$1.prototype.copy.call(lineMaterial, material), lineMaterial.color.copy(material.color), lineMaterial.map = material.map, this.cache.add(cacheKey, lineMaterial)), material = lineMaterial
		}
		if (useDerivativeTangents || useVertexColors || useFlatShading) {
			let cacheKey = "ClonedMaterial:" + material.uuid + ":";
			useDerivativeTangents && (cacheKey += "derivative-tangents:"), useVertexColors && (cacheKey += "vertex-colors:"), useFlatShading && (cacheKey += "flat-shading:");
			let cachedMaterial = this.cache.get(cacheKey);
			cachedMaterial || (cachedMaterial = material.clone(), useVertexColors && (cachedMaterial.vertexColors = !0), useFlatShading && (cachedMaterial.flatShading = !0), useDerivativeTangents && (cachedMaterial.normalScale && (cachedMaterial.normalScale.y *= -1), cachedMaterial.clearcoatNormalScale && (cachedMaterial.clearcoatNormalScale.y *= -1)), this.cache.add(cacheKey, cachedMaterial), this.associations.set(cachedMaterial, this.associations.get(material))), material = cachedMaterial
		}
		mesh.material = material
	}
	getMaterialType() {
		return MeshStandardMaterial
	}
	loadMaterial(materialIndex) {
		let materialType;
		let parser = this,
			json = this.json,
			extensions = this.extensions,
			materialDef = json.materials[materialIndex],
			materialParams = {},
			materialExtensions = materialDef.extensions || {},
			pending = [];
		if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
			let kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
			materialType = kmuExtension.getMaterialType(), pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))
		} else {
			let metallicRoughness = materialDef.pbrMetallicRoughness || {};
			if (materialParams.color = new Color(1, 1, 1), materialParams.opacity = 1, Array.isArray(metallicRoughness.baseColorFactor)) {
				let array = metallicRoughness.baseColorFactor;
				materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace), materialParams.opacity = array[3]
			}
			void 0 !== metallicRoughness.baseColorTexture && pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace)), materialParams.metalness = void 0 !== metallicRoughness.metallicFactor ? metallicRoughness.metallicFactor : 1, materialParams.roughness = void 0 !== metallicRoughness.roughnessFactor ? metallicRoughness.roughnessFactor : 1, void 0 !== metallicRoughness.metallicRoughnessTexture && (pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture)), pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture))), materialType = this._invokeOne(function(ext) {
				return ext.getMaterialType && ext.getMaterialType(materialIndex)
			}), pending.push(Promise.all(this._invokeAll(function(ext) {
				return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)
			})))
		}!0 === materialDef.doubleSided && (materialParams.side = 2);
		let alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
		if (alphaMode === ALPHA_MODES.BLEND ? (materialParams.transparent = !0, materialParams.depthWrite = !1) : (materialParams.transparent = !1, alphaMode === ALPHA_MODES.MASK && (materialParams.alphaTest = void 0 !== materialDef.alphaCutoff ? materialDef.alphaCutoff : .5)), void 0 !== materialDef.normalTexture && materialType !== MeshBasicMaterial && (pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture)), materialParams.normalScale = new Vector2(1, 1), void 0 !== materialDef.normalTexture.scale)) {
			let scale = materialDef.normalTexture.scale;
			materialParams.normalScale.set(scale, scale)
		}
		if (void 0 !== materialDef.occlusionTexture && materialType !== MeshBasicMaterial && (pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture)), void 0 !== materialDef.occlusionTexture.strength && (materialParams.aoMapIntensity = materialDef.occlusionTexture.strength)), void 0 !== materialDef.emissiveFactor && materialType !== MeshBasicMaterial) {
			let emissiveFactor = materialDef.emissiveFactor;
			materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace)
		}
		return void 0 !== materialDef.emissiveTexture && materialType !== MeshBasicMaterial && pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace)), Promise.all(pending).then(function() {
			let material = new materialType(materialParams);
			return materialDef.name && (material.name = materialDef.name), assignExtrasToUserData(material, materialDef), parser.associations.set(material, {
				materials: materialIndex
			}), materialDef.extensions && addUnknownExtensionsToUserData(extensions, material, materialDef), material
		})
	}
	createUniqueName(originalName) {
		let sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
		return sanitizedName in this.nodeNamesUsed ? sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName] : (this.nodeNamesUsed[sanitizedName] = 0, sanitizedName)
	}
	loadGeometries(primitives) {
		let parser = this,
			extensions = this.extensions,
			cache = this.primitiveCache,
			pending = [];
		for (let i = 0, il = primitives.length; i < il; i++) {
			let primitive = primitives[i],
				cacheKey = function(primitiveDef) {
					let geometryKey;
					let dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
					if (geometryKey = dracoExtension ? "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes) : primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode, void 0 !== primitiveDef.targets)
						for (let i = 0, il = primitiveDef.targets.length; i < il; i++) geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
					return geometryKey
				}(primitive),
				cached = cache[cacheKey];
			if (cached) pending.push(cached.promise);
			else {
				let geometryPromise;
				geometryPromise = primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? function(primitive) {
					return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
						return addPrimitiveAttributes(geometry, primitive, parser)
					})
				}(primitive) : addPrimitiveAttributes(new BufferGeometry, primitive, parser), cache[cacheKey] = {
					primitive: primitive,
					promise: geometryPromise
				}, pending.push(geometryPromise)
			}
		}
		return Promise.all(pending)
	}
	loadMesh(meshIndex) {
		let parser = this,
			json = this.json,
			extensions = this.extensions,
			meshDef = json.meshes[meshIndex],
			primitives = meshDef.primitives,
			pending = [];
		for (let i = 0, il = primitives.length; i < il; i++) {
			var cache;
			let material = void 0 === primitives[i].material ? (void 0 === (cache = this.cache).DefaultMaterial && (cache.DefaultMaterial = new MeshStandardMaterial({
				color: 16777215,
				emissive: 0,
				metalness: 1,
				roughness: 1,
				transparent: !1,
				depthTest: !0,
				side: 0
			})), cache.DefaultMaterial) : this.getDependency("material", primitives[i].material);
			pending.push(material)
		}
		return pending.push(parser.loadGeometries(primitives)), Promise.all(pending).then(function(results) {
			let materials = results.slice(0, results.length - 1),
				geometries = results[results.length - 1],
				meshes = [];
			for (let i = 0, il = geometries.length; i < il; i++) {
				let mesh;
				let geometry = geometries[i],
					primitive = primitives[i],
					material = materials[i];
				if (primitive.mode === WEBGL_CONSTANTS$1.TRIANGLES || primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN || void 0 === primitive.mode) !0 === (mesh = !0 === meshDef.isSkinnedMesh ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)).isSkinnedMesh && mesh.normalizeSkinWeights(), primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ? mesh.geometry = toTrianglesDrawMode(mesh.geometry, 1) : primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN && (mesh.geometry = toTrianglesDrawMode(mesh.geometry, 2));
				else if (primitive.mode === WEBGL_CONSTANTS$1.LINES) mesh = new LineSegments(geometry, material);
				else if (primitive.mode === WEBGL_CONSTANTS$1.LINE_STRIP) mesh = new Line(geometry, material);
				else if (primitive.mode === WEBGL_CONSTANTS$1.LINE_LOOP) mesh = new LineLoop(geometry, material);
				else if (primitive.mode === WEBGL_CONSTANTS$1.POINTS) mesh = new Points(geometry, material);
				else throw Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
				Object.keys(mesh.geometry.morphAttributes).length > 0 && function(mesh, meshDef) {
					if (mesh.updateMorphTargets(), void 0 !== meshDef.weights)
						for (let i = 0, il = meshDef.weights.length; i < il; i++) mesh.morphTargetInfluences[i] = meshDef.weights[i];
					if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
						let targetNames = meshDef.extras.targetNames;
						if (mesh.morphTargetInfluences.length === targetNames.length) {
							mesh.morphTargetDictionary = {};
							for (let i = 0, il = targetNames.length; i < il; i++) mesh.morphTargetDictionary[targetNames[i]] = i
						} else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
					}
				}(mesh, meshDef), mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex), assignExtrasToUserData(mesh, meshDef), primitive.extensions && addUnknownExtensionsToUserData(extensions, mesh, primitive), parser.assignFinalMaterial(mesh), meshes.push(mesh)
			}
			for (let i = 0, il = meshes.length; i < il; i++) parser.associations.set(meshes[i], {
				meshes: meshIndex,
				primitives: i
			});
			if (1 === meshes.length) return meshDef.extensions && addUnknownExtensionsToUserData(extensions, meshes[0], meshDef), meshes[0];
			let group = new Group;
			meshDef.extensions && addUnknownExtensionsToUserData(extensions, group, meshDef), parser.associations.set(group, {
				meshes: meshIndex
			});
			for (let i = 0, il = meshes.length; i < il; i++) group.add(meshes[i]);
			return group
		})
	}
	loadCamera(cameraIndex) {
		let camera;
		let cameraDef = this.json.cameras[cameraIndex],
			params = cameraDef[cameraDef.type];
		if (!params) {
			console.warn("THREE.GLTFLoader: Missing camera parameters.");
			return
		}
		return "perspective" === cameraDef.type ? camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6) : "orthographic" === cameraDef.type && (camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)), cameraDef.name && (camera.name = this.createUniqueName(cameraDef.name)), assignExtrasToUserData(camera, cameraDef), Promise.resolve(camera)
	}
	loadSkin(skinIndex) {
		let skinDef = this.json.skins[skinIndex],
			pending = [];
		for (let i = 0, il = skinDef.joints.length; i < il; i++) pending.push(this._loadNodeShallow(skinDef.joints[i]));
		return void 0 !== skinDef.inverseBindMatrices ? pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices)) : pending.push(null), Promise.all(pending).then(function(results) {
			let inverseBindMatrices = results.pop(),
				bones = [],
				boneInverses = [];
			for (let i = 0, il = results.length; i < il; i++) {
				let jointNode = results[i];
				if (jointNode) {
					bones.push(jointNode);
					let mat = new Matrix4;
					null !== inverseBindMatrices && mat.fromArray(inverseBindMatrices.array, 16 * i), boneInverses.push(mat)
				} else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i])
			}
			return new Skeleton(bones, boneInverses)
		})
	}
	loadAnimation(animationIndex) {
		let json = this.json,
			parser = this,
			animationDef = json.animations[animationIndex],
			animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex,
			pendingNodes = [],
			pendingInputAccessors = [],
			pendingOutputAccessors = [],
			pendingSamplers = [],
			pendingTargets = [];
		for (let i = 0, il = animationDef.channels.length; i < il; i++) {
			let channel = animationDef.channels[i],
				sampler = animationDef.samplers[channel.sampler],
				target = channel.target,
				name = target.node,
				input = void 0 !== animationDef.parameters ? animationDef.parameters[sampler.input] : sampler.input,
				output = void 0 !== animationDef.parameters ? animationDef.parameters[sampler.output] : sampler.output;
			void 0 !== target.node && (pendingNodes.push(this.getDependency("node", name)), pendingInputAccessors.push(this.getDependency("accessor", input)), pendingOutputAccessors.push(this.getDependency("accessor", output)), pendingSamplers.push(sampler), pendingTargets.push(target))
		}
		return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function(dependencies) {
			let nodes = dependencies[0],
				inputAccessors = dependencies[1],
				outputAccessors = dependencies[2],
				samplers = dependencies[3],
				targets = dependencies[4],
				tracks = [];
			for (let i = 0, il = nodes.length; i < il; i++) {
				let node = nodes[i],
					inputAccessor = inputAccessors[i],
					outputAccessor = outputAccessors[i],
					sampler = samplers[i],
					target = targets[i];
				if (void 0 === node) continue;
				node.updateMatrix && node.updateMatrix();
				let createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
				if (createdTracks)
					for (let k = 0; k < createdTracks.length; k++) tracks.push(createdTracks[k])
			}
			return new AnimationClip(animationName, void 0, tracks)
		})
	}
	createNodeMesh(nodeIndex) {
		let json = this.json,
			parser = this,
			nodeDef = json.nodes[nodeIndex];
		return void 0 === nodeDef.mesh ? null : parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
			let node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
			return void 0 !== nodeDef.weights && node.traverse(function(o) {
				if (o.isMesh)
					for (let i = 0, il = nodeDef.weights.length; i < il; i++) o.morphTargetInfluences[i] = nodeDef.weights[i]
			}), node
		})
	}
	loadNode(nodeIndex) {
		let nodeDef = this.json.nodes[nodeIndex],
			nodePending = this._loadNodeShallow(nodeIndex),
			childPending = [],
			childrenDef = nodeDef.children || [];
		for (let i = 0, il = childrenDef.length; i < il; i++) childPending.push(this.getDependency("node", childrenDef[i]));
		let skeletonPending = void 0 === nodeDef.skin ? Promise.resolve(null) : this.getDependency("skin", nodeDef.skin);
		return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {
			let node = results[0],
				children = results[1],
				skeleton = results[2];
			null !== skeleton && node.traverse(function(mesh) {
				mesh.isSkinnedMesh && mesh.bind(skeleton, _identityMatrix)
			});
			for (let i = 0, il = children.length; i < il; i++) node.add(children[i]);
			return node
		})
	}
	_loadNodeShallow(nodeIndex) {
		let json = this.json,
			extensions = this.extensions,
			parser = this;
		if (void 0 !== this.nodeCache[nodeIndex]) return this.nodeCache[nodeIndex];
		let nodeDef = json.nodes[nodeIndex],
			nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "",
			pending = [],
			meshPromise = parser._invokeOne(function(ext) {
				return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)
			});
		return meshPromise && pending.push(meshPromise), void 0 !== nodeDef.camera && pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
			return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)
		})), parser._invokeAll(function(ext) {
			return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)
		}).forEach(function(promise) {
			pending.push(promise)
		}), this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
			let node;
			if ((node = !0 === nodeDef.isBone ? new Bone : objects.length > 1 ? new Group : 1 === objects.length ? objects[0] : new Object3D) !== objects[0])
				for (let i = 0, il = objects.length; i < il; i++) node.add(objects[i]);
			if (nodeDef.name && (node.userData.name = nodeDef.name, node.name = nodeName), assignExtrasToUserData(node, nodeDef), nodeDef.extensions && addUnknownExtensionsToUserData(extensions, node, nodeDef), void 0 !== nodeDef.matrix) {
				let matrix = new Matrix4;
				matrix.fromArray(nodeDef.matrix), node.applyMatrix4(matrix)
			} else void 0 !== nodeDef.translation && node.position.fromArray(nodeDef.translation), void 0 !== nodeDef.rotation && node.quaternion.fromArray(nodeDef.rotation), void 0 !== nodeDef.scale && node.scale.fromArray(nodeDef.scale);
			return parser.associations.has(node) || parser.associations.set(node, {}), parser.associations.get(node).nodes = nodeIndex, node
		}), this.nodeCache[nodeIndex]
	}
	loadScene(sceneIndex) {
		let extensions = this.extensions,
			sceneDef = this.json.scenes[sceneIndex],
			parser = this,
			scene = new Group;
		sceneDef.name && (scene.name = parser.createUniqueName(sceneDef.name)), assignExtrasToUserData(scene, sceneDef), sceneDef.extensions && addUnknownExtensionsToUserData(extensions, scene, sceneDef);
		let nodeIds = sceneDef.nodes || [],
			pending = [];
		for (let i = 0, il = nodeIds.length; i < il; i++) pending.push(parser.getDependency("node", nodeIds[i]));
		return Promise.all(pending).then(function(nodes) {
			for (let i = 0, il = nodes.length; i < il; i++) scene.add(nodes[i]);
			return parser.associations = (node => {
				let reducedAssociations = new Map;
				for (let [key, value] of parser.associations)(key instanceof Material$1 || key instanceof Texture$1) && reducedAssociations.set(key, value);
				return node.traverse(node => {
					let mappings = parser.associations.get(node);
					null != mappings && reducedAssociations.set(node, mappings)
				}), reducedAssociations
			})(scene), scene
		})
	}
	_createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
		let TypedKeyframeTrack;
		let tracks = [],
			targetName = node.name ? node.name : node.uuid,
			targetNames = [];
		switch (PATH_PROPERTIES$1[target.path] === PATH_PROPERTIES$1.weights ? node.traverse(function(object) {
				object.morphTargetInfluences && targetNames.push(object.name ? object.name : object.uuid)
			}) : targetNames.push(targetName), PATH_PROPERTIES$1[target.path]) {
			case PATH_PROPERTIES$1.weights:
				TypedKeyframeTrack = NumberKeyframeTrack;
				break;
			case PATH_PROPERTIES$1.rotation:
				TypedKeyframeTrack = QuaternionKeyframeTrack;
				break;
			case PATH_PROPERTIES$1.position:
			case PATH_PROPERTIES$1.scale:
				TypedKeyframeTrack = VectorKeyframeTrack;
				break;
			default:
				TypedKeyframeTrack = 1 === outputAccessor.itemSize ? NumberKeyframeTrack : VectorKeyframeTrack
		}
		let interpolation = void 0 !== sampler.interpolation ? INTERPOLATION[sampler.interpolation] : 2301,
			outputArray = this._getArrayFromAccessor(outputAccessor);
		for (let j = 0, jl = targetNames.length; j < jl; j++) {
			let track = new TypedKeyframeTrack(targetNames[j] + "." + PATH_PROPERTIES$1[target.path], inputAccessor.array, outputArray, interpolation);
			"CUBICSPLINE" === sampler.interpolation && this._createCubicSplineTrackInterpolant(track), tracks.push(track)
		}
		return tracks
	}
	_getArrayFromAccessor(accessor) {
		let outputArray = accessor.array;
		if (accessor.normalized) {
			let scale = getNormalizedComponentScale(outputArray.constructor),
				scaled = new Float32Array(outputArray.length);
			for (let j = 0, jl = outputArray.length; j < jl; j++) scaled[j] = outputArray[j] * scale;
			outputArray = scaled
		}
		return outputArray
	}
	_createCubicSplineTrackInterpolant(track) {
		track.createInterpolant = function(result) {
			return new(this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant)(this.times, this.values, this.getValueSize() / 3, result)
		}, track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
	}
}

function addPrimitiveAttributes(geometry, primitiveDef, parser) {
	let attributes = primitiveDef.attributes,
		pending = [];
	for (let gltfAttributeName in attributes) {
		let threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
		threeAttributeName in geometry.attributes || pending.push(function(accessorIndex, attributeName) {
			return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
				geometry.setAttribute(attributeName, accessor)
			})
		}(attributes[gltfAttributeName], threeAttributeName))
	}
	if (void 0 !== primitiveDef.indices && !geometry.index) {
		let accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor) {
			geometry.setIndex(accessor)
		});
		pending.push(accessor)
	}
	return ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`), assignExtrasToUserData(geometry, primitiveDef), ! function(geometry, primitiveDef, parser) {
		let attributes = primitiveDef.attributes,
			box = new Box3;
		if (void 0 === attributes.POSITION) return;
		{
			let accessor = parser.json.accessors[attributes.POSITION],
				min = accessor.min,
				max = accessor.max;
			if (void 0 !== min && void 0 !== max) {
				if (box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2])), accessor.normalized) {
					let boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
					box.min.multiplyScalar(boxScale), box.max.multiplyScalar(boxScale)
				}
			} else {
				console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
				return
			}
		}
		let targets = primitiveDef.targets;
		if (void 0 !== targets) {
			let maxDisplacement = new Vector3,
				vector = new Vector3;
			for (let i = 0, il = targets.length; i < il; i++) {
				let target = targets[i];
				if (void 0 !== target.POSITION) {
					let accessor = parser.json.accessors[target.POSITION],
						min = accessor.min,
						max = accessor.max;
					if (void 0 !== min && void 0 !== max) {
						if (vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0]))), vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1]))), vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2]))), accessor.normalized) {
							let boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
							vector.multiplyScalar(boxScale)
						}
						maxDisplacement.max(vector)
					} else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
				}
			}
			box.expandByVector(maxDisplacement)
		}
		geometry.boundingBox = box;
		let sphere = new Sphere;
		box.getCenter(sphere.center), sphere.radius = box.min.distanceTo(box.max) / 2, geometry.boundingSphere = sphere
	}(geometry, primitiveDef, parser), Promise.all(pending).then(function() {
		return void 0 !== primitiveDef.targets ? function(geometry, targets, parser) {
			let hasMorphPosition = !1,
				hasMorphNormal = !1,
				hasMorphColor = !1;
			for (let i = 0, il = targets.length; i < il; i++) {
				let target = targets[i];
				if (void 0 !== target.POSITION && (hasMorphPosition = !0), void 0 !== target.NORMAL && (hasMorphNormal = !0), void 0 !== target.COLOR_0 && (hasMorphColor = !0), hasMorphPosition && hasMorphNormal && hasMorphColor) break
			}
			if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
			let pendingPositionAccessors = [],
				pendingNormalAccessors = [],
				pendingColorAccessors = [];
			for (let i = 0, il = targets.length; i < il; i++) {
				let target = targets[i];
				if (hasMorphPosition) {
					let pendingAccessor = void 0 !== target.POSITION ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
					pendingPositionAccessors.push(pendingAccessor)
				}
				if (hasMorphNormal) {
					let pendingAccessor = void 0 !== target.NORMAL ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
					pendingNormalAccessors.push(pendingAccessor)
				}
				if (hasMorphColor) {
					let pendingAccessor = void 0 !== target.COLOR_0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
					pendingColorAccessors.push(pendingAccessor)
				}
			}
			return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors), Promise.all(pendingColorAccessors)]).then(function(accessors) {
				let morphPositions = accessors[0],
					morphNormals = accessors[1],
					morphColors = accessors[2];
				return hasMorphPosition && (geometry.morphAttributes.position = morphPositions), hasMorphNormal && (geometry.morphAttributes.normal = morphNormals), hasMorphColor && (geometry.morphAttributes.color = morphColors), geometry.morphTargetsRelative = !0, geometry
			})
		}(geometry, primitiveDef.targets, parser) : geometry
	})
}
class WorkerPool {
	constructor(pool = 4) {
		this.pool = pool, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
	}
	_initWorker(workerId) {
		if (!this.workers[workerId]) {
			let worker = this.workerCreator();
			worker.addEventListener("message", this._onMessage.bind(this, workerId)), this.workers[workerId] = worker
		}
	}
	_getIdleWorker() {
		for (let i = 0; i < this.pool; i++)
			if (!(this.workerStatus & 1 << i)) return i;
		return -1
	}
	_onMessage(workerId, msg) {
		let resolve = this.workersResolve[workerId];
		if (resolve && resolve(msg), this.queue.length) {
			let {
				resolve,
				msg,
				transfer
			} = this.queue.shift();
			this.workersResolve[workerId] = resolve, this.workers[workerId].postMessage(msg, transfer)
		} else this.workerStatus ^= 1 << workerId
	}
	setWorkerCreator(workerCreator) {
		this.workerCreator = workerCreator
	}
	setWorkerLimit(pool) {
		this.pool = pool
	}
	postMessage(msg, transfer) {
		return new Promise(resolve => {
			let workerId = this._getIdleWorker(); - 1 !== workerId ? (this._initWorker(workerId), this.workerStatus |= 1 << workerId, this.workersResolve[workerId] = resolve, this.workers[workerId].postMessage(msg, transfer)) : this.queue.push({
				resolve,
				msg,
				transfer
			})
		})
	}
	dispose() {
		this.workers.forEach(worker => worker.terminate()), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
	}
}
class Si {
	constructor() {
		this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
			vendorId: 0,
			descriptorType: 0,
			descriptorBlockSize: 0,
			versionNumber: 2,
			colorModel: 0,
			colorPrimaries: 1,
			transferFunction: 2,
			flags: 0,
			texelBlockDimension: [0, 0, 0, 0],
			bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
			samples: []
		}], this.keyValue = {}, this.globalData = null
	}
}
class Ii {
	constructor(t, e, n, i) {
		this._dataView = new DataView(t.buffer, t.byteOffset + e, n), this._littleEndian = i, this._offset = 0
	}
	_nextUint8() {
		let t = this._dataView.getUint8(this._offset);
		return this._offset += 1, t
	}
	_nextUint16() {
		let t = this._dataView.getUint16(this._offset, this._littleEndian);
		return this._offset += 2, t
	}
	_nextUint32() {
		let t = this._dataView.getUint32(this._offset, this._littleEndian);
		return this._offset += 4, t
	}
	_nextUint64() {
		let t = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
		return this._offset += 8, t
	}
	_nextInt32() {
		let t = this._dataView.getInt32(this._offset, this._littleEndian);
		return this._offset += 4, t
	}
	_skip(t) {
		return this._offset += t, this
	}
	_scan(t, e = 0) {
		let n = this._offset,
			i = 0;
		for (; this._dataView.getUint8(this._offset) !== e && i < t;) i++, this._offset++;
		return i < t && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i)
	}
}
let Ti = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

function Ei(t) {
	return "undefined" != typeof TextDecoder ? (new TextDecoder).decode(t) : Buffer.from(t).toString("utf8")
}
let g = {
	env: {
		emscripten_notify_memory_growth: function(A) {
			B = new Uint8Array(I.exports.memory.buffer)
		}
	}
};
class Q {
	init() {
		return A || (A = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + C).then(A => A.arrayBuffer()).then(A => WebAssembly.instantiate(A, g)).then(this._init) : WebAssembly.instantiate(Buffer.from(C, "base64"), g).then(this._init))
	}
	_init(A) {
		I = A.instance, g.env.emscripten_notify_memory_growth(0)
	}
	decode(A, g = 0) {
		if (!I) throw Error("ZSTDDecoder: Await .init() before decoding.");
		let Q = A.byteLength,
			C = I.exports.malloc(Q);
		B.set(A, C), g = g || Number(I.exports.ZSTD_findDecompressedSize(C, Q));
		let E = I.exports.malloc(g),
			i = I.exports.ZSTD_decompress(E, g, C, Q),
			D = B.slice(E, E + i);
		return I.exports.free(C), I.exports.free(E), D
	}
}
let C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",
	_taskCache = new WeakMap,
	_activeLoaders = 0;
class KTX2Loader extends Loader {
	constructor(manager) {
		super(manager), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new WorkerPool, this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
	}
	setTranscoderPath(path) {
		return this.transcoderPath = path, this
	}
	setWorkerLimit(num) {
		return this.workerPool.setWorkerLimit(num), this
	}
	detectSupport(renderer) {
		return !0 === renderer.isWebGPURenderer ? this.workerConfig = {
			astcSupported: renderer.hasFeature("texture-compression-astc"),
			etc1Supported: !1,
			etc2Supported: renderer.hasFeature("texture-compression-etc2"),
			dxtSupported: renderer.hasFeature("texture-compression-bc"),
			bptcSupported: !1,
			pvrtcSupported: !1
		} : (this.workerConfig = {
			astcSupported: renderer.extensions.has("WEBGL_compressed_texture_astc"),
			etc1Supported: renderer.extensions.has("WEBGL_compressed_texture_etc1"),
			etc2Supported: renderer.extensions.has("WEBGL_compressed_texture_etc"),
			dxtSupported: renderer.extensions.has("WEBGL_compressed_texture_s3tc"),
			bptcSupported: renderer.extensions.has("EXT_texture_compression_bptc"),
			pvrtcSupported: renderer.extensions.has("WEBGL_compressed_texture_pvrtc") || renderer.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
		}, renderer.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1)), this
	}
	init() {
		if (!this.transcoderPending) {
			let jsLoader = new FileLoader(this.manager);
			jsLoader.setPath(this.transcoderPath), jsLoader.setWithCredentials(this.withCredentials);
			let jsContent = jsLoader.loadAsync("basis_transcoder.js"),
				binaryLoader = new FileLoader(this.manager);
			binaryLoader.setPath(this.transcoderPath), binaryLoader.setResponseType("arraybuffer"), binaryLoader.setWithCredentials(this.withCredentials);
			let binaryContent = binaryLoader.loadAsync("basis_transcoder.wasm");
			this.transcoderPending = Promise.all([jsContent, binaryContent]).then(([jsContent, binaryContent]) => {
				let fn = KTX2Loader.BasisWorker.toString(),
					body = ["/* constants */", "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat), "/* basis_transcoder.js */", jsContent, "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
				this.workerSourceURL = URL.createObjectURL(new Blob([body])), this.transcoderBinary = binaryContent, this.workerPool.setWorkerCreator(() => {
					let worker = new Worker(this.workerSourceURL),
						transcoderBinary = this.transcoderBinary.slice(0);
					return worker.postMessage({
						type: "init",
						config: this.workerConfig,
						transcoderBinary
					}, [transcoderBinary]), worker
				})
			}), _activeLoaders > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), _activeLoaders++
		}
		return this.transcoderPending
	}
	load(url, onLoad, onProgress, onError) {
		if (null === this.workerConfig) throw Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
		let loader = new FileLoader(this.manager);
		loader.setResponseType("arraybuffer"), loader.setWithCredentials(this.withCredentials), loader.load(url, buffer => {
			if (_taskCache.has(buffer)) return _taskCache.get(buffer).promise.then(onLoad).catch(onError);
			this._createTexture(buffer).then(texture => onLoad ? onLoad(texture) : null).catch(onError)
		}, onProgress, onError)
	}
	_createTextureFrom(transcodeResult, container) {
		let texture;
		let {
			faces,
			width,
			height,
			format,
			type,
			error,
			dfdFlags
		} = transcodeResult;
		if ("error" === type) return Promise.reject(error);
		if (6 === container.faceCount) texture = new CompressedCubeTexture(faces, format, 1009);
		else {
			let mipmaps = faces[0].mipmaps;
			texture = container.layerCount > 1 ? new CompressedArrayTexture(mipmaps, width, height, container.layerCount, format, 1009) : new CompressedTexture(mipmaps, width, height, format, 1009)
		}
		return texture.minFilter = 1 === faces[0].mipmaps.length ? 1006 : 1008, texture.magFilter = 1006, texture.generateMipmaps = !1, texture.needsUpdate = !0, texture.colorSpace = parseColorSpace(container), texture.premultiplyAlpha = !!(1 & dfdFlags), texture
	}
	async _createTexture(buffer, config = {}) {
		let container = function(t) {
			let e = new Uint8Array(t.buffer, t.byteOffset, Ti.length);
			if (e[0] !== Ti[0] || e[1] !== Ti[1] || e[2] !== Ti[2] || e[3] !== Ti[3] || e[4] !== Ti[4] || e[5] !== Ti[5] || e[6] !== Ti[6] || e[7] !== Ti[7] || e[8] !== Ti[8] || e[9] !== Ti[9] || e[10] !== Ti[10] || e[11] !== Ti[11]) throw Error("Missing KTX 2.0 identifier.");
			let n = new Si,
				i = 17 * Uint32Array.BYTES_PER_ELEMENT,
				s = new Ii(t, Ti.length, i, !0);
			n.vkFormat = s._nextUint32(), n.typeSize = s._nextUint32(), n.pixelWidth = s._nextUint32(), n.pixelHeight = s._nextUint32(), n.pixelDepth = s._nextUint32(), n.layerCount = s._nextUint32(), n.faceCount = s._nextUint32();
			let a = s._nextUint32();
			n.supercompressionScheme = s._nextUint32();
			let r = s._nextUint32(),
				o = s._nextUint32(),
				l = s._nextUint32(),
				f = s._nextUint32(),
				U = s._nextUint64(),
				c = s._nextUint64(),
				h = new Ii(t, Ti.length + i, 3 * a * 8, !0);
			for (let e = 0; e < a; e++) n.levels.push({
				levelData: new Uint8Array(t.buffer, t.byteOffset + h._nextUint64(), h._nextUint64()),
				uncompressedByteLength: h._nextUint64()
			});
			let _ = new Ii(t, r, o, !0),
				p = {
					vendorId: _._skip(4)._nextUint16(),
					descriptorType: _._nextUint16(),
					versionNumber: _._nextUint16(),
					descriptorBlockSize: _._nextUint16(),
					colorModel: _._nextUint8(),
					colorPrimaries: _._nextUint8(),
					transferFunction: _._nextUint8(),
					flags: _._nextUint8(),
					texelBlockDimension: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()],
					bytesPlane: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()],
					samples: []
				},
				g = (p.descriptorBlockSize / 4 - 6) / 4;
			for (let t = 0; t < g; t++) {
				let e = {
					bitOffset: _._nextUint16(),
					bitLength: _._nextUint8(),
					channelType: _._nextUint8(),
					samplePosition: [_._nextUint8(), _._nextUint8(), _._nextUint8(), _._nextUint8()],
					sampleLower: -1 / 0,
					sampleUpper: 1 / 0
				};
				64 & e.channelType ? (e.sampleLower = _._nextInt32(), e.sampleUpper = _._nextInt32()) : (e.sampleLower = _._nextUint32(), e.sampleUpper = _._nextUint32()), p.samples[t] = e
			}
			n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(p);
			let y = new Ii(t, l, f, !0);
			for (; y._offset < f;) {
				let t = y._nextUint32(),
					e = y._scan(t),
					i = Ei(e),
					s = y._scan(t - e.byteLength);
				n.keyValue[i] = i.match(/^ktx/i) ? Ei(s) : s, y._offset % 4 && y._skip(4 - y._offset % 4)
			}
			if (c <= 0) return n;
			let x = new Ii(t, U, c, !0),
				u = x._nextUint16(),
				b = x._nextUint16(),
				d = x._nextUint32(),
				m = x._nextUint32(),
				w = x._nextUint32(),
				D = x._nextUint32(),
				B = [];
			for (let t = 0; t < a; t++) B.push({
				imageFlags: x._nextUint32(),
				rgbSliceByteOffset: x._nextUint32(),
				rgbSliceByteLength: x._nextUint32(),
				alphaSliceByteOffset: x._nextUint32(),
				alphaSliceByteLength: x._nextUint32()
			});
			let L = U + x._offset,
				A = L + d,
				k = A + m,
				v = k + w,
				S = new Uint8Array(t.buffer, t.byteOffset + L, d),
				I = new Uint8Array(t.buffer, t.byteOffset + A, m),
				O = new Uint8Array(t.buffer, t.byteOffset + k, w),
				T = new Uint8Array(t.buffer, t.byteOffset + v, D);
			return n.globalData = {
				endpointCount: u,
				selectorCount: b,
				imageDescs: B,
				endpointsData: S,
				selectorsData: I,
				tablesData: O,
				extendedData: T
			}, n
		}(new Uint8Array(buffer));
		if (0 !== container.vkFormat) return createRawTexture(container);
		let texturePending = this.init().then(() => this.workerPool.postMessage({
			type: "transcode",
			buffer,
			taskConfig: config
		}, [buffer])).then(e => this._createTextureFrom(e.data, container));
		return _taskCache.set(buffer, {
			promise: texturePending
		}), texturePending
	}
	dispose() {
		return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), _activeLoaders--, this
	}
}
KTX2Loader.BasisFormat = {
	ETC1S: 0,
	UASTC_4x4: 1
}, KTX2Loader.TranscoderFormat = {
	ETC1: 0,
	ETC2: 1,
	BC1: 2,
	BC3: 3,
	BC4: 4,
	BC5: 5,
	BC7_M6_OPAQUE_ONLY: 6,
	BC7_M5: 7,
	PVRTC1_4_RGB: 8,
	PVRTC1_4_RGBA: 9,
	ASTC_4x4: 10,
	ATC_RGB: 11,
	ATC_RGBA_INTERPOLATED_ALPHA: 12,
	RGBA32: 13,
	RGB565: 14,
	BGR565: 15,
	RGBA4444: 16
}, KTX2Loader.EngineFormat = {
	RGBAFormat: 1023,
	RGBA_ASTC_4x4_Format: 37808,
	RGBA_BPTC_Format: 36492,
	RGBA_ETC2_EAC_Format: 37496,
	RGBA_PVRTC_4BPPV1_Format: 35842,
	RGBA_S3TC_DXT5_Format: 33779,
	RGB_ETC1_Format: 36196,
	RGB_ETC2_Format: 37492,
	RGB_PVRTC_4BPPV1_Format: 35840,
	RGB_S3TC_DXT1_Format: 33776
}, KTX2Loader.BasisWorker = function() {
	let config, transcoderPending, BasisModule;
	let EngineFormat = _EngineFormat,
		TranscoderFormat = _TranscoderFormat,
		BasisFormat = _BasisFormat;
	self.addEventListener("message", function(e) {
		let message = e.data;
		switch (message.type) {
			case "init":
				var wasmBinary;
				config = message.config, wasmBinary = message.transcoderBinary, transcoderPending = new Promise(resolve => {
					BASIS(BasisModule = {
						wasmBinary,
						onRuntimeInitialized: resolve
					})
				}).then(() => {
					BasisModule.initializeBasis(), void 0 === BasisModule.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
				});
				break;
			case "transcode":
				transcoderPending.then(() => {
					try {
						let {
							faces,
							buffers,
							width,
							height,
							hasAlpha,
							format,
							dfdFlags
						} = function(buffer) {
							let ktx2File = new BasisModule.KTX2File(new Uint8Array(buffer));

							function cleanup() {
								ktx2File.close(), ktx2File.delete()
							}
							if (!ktx2File.isValid()) throw cleanup(), Error("THREE.KTX2Loader:	Invalid or unsupported .ktx2 file");
							let basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S,
								width = ktx2File.getWidth(),
								height = ktx2File.getHeight(),
								layerCount = ktx2File.getLayers() || 1,
								levelCount = ktx2File.getLevels(),
								faceCount = ktx2File.getFaces(),
								hasAlpha = ktx2File.getHasAlpha(),
								dfdFlags = ktx2File.getDFDFlags(),
								{
									transcoderFormat,
									engineFormat
								} = function(basisFormat, width, height, hasAlpha) {
									let transcoderFormat;
									let options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;
									for (let i = 0; i < options.length; i++) {
										let opt = options[i];
										if (config[opt.if] && opt.basisFormat.includes(basisFormat) && (!hasAlpha || !(opt.transcoderFormat.length < 2)) && (!opt.needsPowerOfTwo || isPowerOfTwo(width) && isPowerOfTwo(height))) return {
											transcoderFormat: opt.transcoderFormat[hasAlpha ? 1 : 0],
											engineFormat: opt.engineFormat[hasAlpha ? 1 : 0]
										}
									}
									return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), {
										transcoderFormat: TranscoderFormat.RGBA32,
										engineFormat: EngineFormat.RGBAFormat
									}
								}(basisFormat, width, height, hasAlpha);
							if (!width || !height || !levelCount) throw cleanup(), Error("THREE.KTX2Loader:	Invalid texture");
							if (!ktx2File.startTranscoding()) throw cleanup(), Error("THREE.KTX2Loader: .startTranscoding failed");
							let faces = [],
								buffers = [];
							for (let face = 0; face < faceCount; face++) {
								let mipmaps = [];
								for (let mip = 0; mip < levelCount; mip++) {
									let mipWidth, mipHeight;
									let layerMips = [];
									for (let layer = 0; layer < layerCount; layer++) {
										let levelInfo = ktx2File.getImageLevelInfo(mip, layer, face);
										0 === face && 0 === mip && 0 === layer && (levelInfo.origWidth % 4 != 0 || levelInfo.origHeight % 4 != 0) && console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), levelCount > 1 ? (mipWidth = levelInfo.origWidth, mipHeight = levelInfo.origHeight) : (mipWidth = levelInfo.width, mipHeight = levelInfo.height);
										let dst = new Uint8Array(ktx2File.getImageTranscodedSizeInBytes(mip, layer, 0, transcoderFormat));
										if (!ktx2File.transcodeImage(dst, mip, layer, face, transcoderFormat, 0, -1, -1)) throw cleanup(), Error("THREE.KTX2Loader: .transcodeImage failed.");
										layerMips.push(dst)
									}
									let mipData = function(arrays) {
										if (1 === arrays.length) return arrays[0];
										let totalByteLength = 0;
										for (let i = 0; i < arrays.length; i++) totalByteLength += arrays[i].byteLength;
										let result = new Uint8Array(totalByteLength),
											byteOffset = 0;
										for (let i = 0; i < arrays.length; i++) {
											let array = arrays[i];
											result.set(array, byteOffset), byteOffset += array.byteLength
										}
										return result
									}(layerMips);
									mipmaps.push({
										data: mipData,
										width: mipWidth,
										height: mipHeight
									}), buffers.push(mipData.buffer)
								}
								faces.push({
									mipmaps,
									width,
									height,
									format: engineFormat
								})
							}
							return cleanup(), {
								faces,
								buffers,
								width,
								height,
								hasAlpha,
								format: engineFormat,
								dfdFlags
							}
						}(message.buffer);
						self.postMessage({
							type: "transcode",
							id: message.id,
							faces,
							width,
							height,
							hasAlpha,
							format,
							dfdFlags
						}, buffers)
					} catch (error) {
						console.error(error), self.postMessage({
							type: "error",
							id: message.id,
							error: error.message
						})
					}
				})
		}
	});
	let FORMAT_OPTIONS = [{
			if: "astcSupported",
			basisFormat: [BasisFormat.UASTC_4x4],
			transcoderFormat: [TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4],
			engineFormat: [EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format],
			priorityETC1S: 1 / 0,
			priorityUASTC: 1,
			needsPowerOfTwo: !1
		}, {
			if: "bptcSupported",
			basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
			transcoderFormat: [TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5],
			engineFormat: [EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format],
			priorityETC1S: 3,
			priorityUASTC: 2,
			needsPowerOfTwo: !1
		}, {
			if: "dxtSupported",
			basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
			transcoderFormat: [TranscoderFormat.BC1, TranscoderFormat.BC3],
			engineFormat: [EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format],
			priorityETC1S: 4,
			priorityUASTC: 5,
			needsPowerOfTwo: !1
		}, {
			if: "etc2Supported",
			basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
			transcoderFormat: [TranscoderFormat.ETC1, TranscoderFormat.ETC2],
			engineFormat: [EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format],
			priorityETC1S: 1,
			priorityUASTC: 3,
			needsPowerOfTwo: !1
		}, {
			if: "etc1Supported",
			basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
			transcoderFormat: [TranscoderFormat.ETC1],
			engineFormat: [EngineFormat.RGB_ETC1_Format],
			priorityETC1S: 2,
			priorityUASTC: 4,
			needsPowerOfTwo: !1
		}, {
			if: "pvrtcSupported",
			basisFormat: [BasisFormat.ETC1S, BasisFormat.UASTC_4x4],
			transcoderFormat: [TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA],
			engineFormat: [EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format],
			priorityETC1S: 5,
			priorityUASTC: 6,
			needsPowerOfTwo: !0
		}],
		ETC1S_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
			return a.priorityETC1S - b.priorityETC1S
		}),
		UASTC_OPTIONS = FORMAT_OPTIONS.sort(function(a, b) {
			return a.priorityUASTC - b.priorityUASTC
		});

	function isPowerOfTwo(value) {
		return value <= 2 || (value & value - 1) == 0 && 0 !== value
	}
};
let UNCOMPRESSED_FORMATS = new Set([1023, 1030, 1028]),
	FORMAT_MAP = {
		109: 1023,
		97: 1023,
		37: 1023,
		43: 1023,
		103: 1030,
		83: 1030,
		16: 1030,
		22: 1030,
		100: 1028,
		76: 1028,
		15: 1028,
		9: 1028,
		166: 37812,
		165: 37812
	},
	TYPE_MAP = {
		109: 1015,
		97: 1016,
		37: 1009,
		43: 1009,
		103: 1015,
		83: 1016,
		16: 1009,
		22: 1009,
		100: 1015,
		76: 1016,
		15: 1009,
		9: 1009,
		166: 1009,
		165: 1009
	};
async function createRawTexture(container) {
	let zstd, texture;
	let {
		vkFormat
	} = container;
	if (void 0 === FORMAT_MAP[vkFormat]) throw Error("THREE.KTX2Loader: Unsupported vkFormat.");
	2 === container.supercompressionScheme && (_zstd || (_zstd = new Promise(async resolve => {
		let zstd = new Q;
		await zstd.init(), resolve(zstd)
	})), zstd = await _zstd);
	let mipmaps = [];
	for (let levelIndex = 0; levelIndex < container.levels.length; levelIndex++) {
		let levelData, data;
		let levelWidth = Math.max(1, container.pixelWidth >> levelIndex),
			levelHeight = Math.max(1, container.pixelHeight >> levelIndex),
			levelDepth = container.pixelDepth ? Math.max(1, container.pixelDepth >> levelIndex) : 0,
			level = container.levels[levelIndex];
		if (0 === container.supercompressionScheme) levelData = level.levelData;
		else if (2 === container.supercompressionScheme) levelData = zstd.decode(level.levelData, level.uncompressedByteLength);
		else throw Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
		data = 1015 === TYPE_MAP[vkFormat] ? new Float32Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Float32Array.BYTES_PER_ELEMENT) : 1016 === TYPE_MAP[vkFormat] ? new Uint16Array(levelData.buffer, levelData.byteOffset, levelData.byteLength / Uint16Array.BYTES_PER_ELEMENT) : levelData, mipmaps.push({
			data: data,
			width: levelWidth,
			height: levelHeight,
			depth: levelDepth
		})
	}
	if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[vkFormat])) texture = 0 === container.pixelDepth ? new DataTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight) : new Data3DTexture(mipmaps[0].data, container.pixelWidth, container.pixelHeight, container.pixelDepth);
	else {
		if (container.pixelDepth > 0) throw Error("THREE.KTX2Loader: Unsupported pixelDepth.");
		texture = new CompressedTexture(mipmaps, container.pixelWidth, container.pixelHeight)
	}
	return texture.mipmaps = mipmaps, texture.type = TYPE_MAP[vkFormat], texture.format = FORMAT_MAP[vkFormat], texture.colorSpace = parseColorSpace(container), texture.needsUpdate = !0, Promise.resolve(texture)
}

function parseColorSpace(container) {
	let dfd = container.dataFormatDescriptor[0];
	return 1 === dfd.colorPrimaries ? 2 === dfd.transferFunction ? SRGBColorSpace : LinearSRGBColorSpace : 10 === dfd.colorPrimaries ? 2 === dfd.transferFunction ? DisplayP3ColorSpace : LinearDisplayP3ColorSpace : (0 === dfd.colorPrimaries || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${dfd.colorPrimaries}"`), "")
}
let $retainerCount = Symbol("retainerCount"),
	$recentlyUsed = Symbol("recentlyUsed"),
	$evict = Symbol("evict"),
	$evictionThreshold = Symbol("evictionThreshold"),
	$cache = Symbol("cache");
class CacheEvictionPolicy {
	constructor(cache, evictionThreshold = 5) {
		this[_a$9] = new Map, this[_b$9] = [], this[$cache] = cache, this[$evictionThreshold] = evictionThreshold
	}
	set evictionThreshold(value) {
		this[$evictionThreshold] = value, this[$evict]()
	}
	get evictionThreshold() {
		return this[$evictionThreshold]
	}
	get cache() {
		return this[$cache]
	}
	retainerCount(key) {
		return this[$retainerCount].get(key) || 0
	}
	reset() {
		this[$retainerCount].clear(), this[$recentlyUsed] = []
	}
	retain(key) {
		this[$retainerCount].has(key) || this[$retainerCount].set(key, 0), this[$retainerCount].set(key, this[$retainerCount].get(key) + 1);
		let recentlyUsedIndex = this[$recentlyUsed].indexOf(key); - 1 !== recentlyUsedIndex && this[$recentlyUsed].splice(recentlyUsedIndex, 1), this[$recentlyUsed].unshift(key), this[$evict]()
	}
	release(key) {
		this[$retainerCount].has(key) && this[$retainerCount].set(key, Math.max(this[$retainerCount].get(key) - 1, 0)), this[$evict]()
	} [(_a$9 = $retainerCount, _b$9 = $recentlyUsed, $evict)]() {
		if (!(this[$recentlyUsed].length < this[$evictionThreshold]))
			for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold]; --i) {
				let key = this[$recentlyUsed][i];
				0 === this[$retainerCount].get(key) && (this[$cache].delete(key), this[$recentlyUsed].splice(i, 1))
			}
	}
}
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let ensureUniqueNames = variantNames => {
		let uniqueNames = [],
			knownNames = new Set;
		for (let name of variantNames) {
			let uniqueName = name,
				suffix = 0;
			for (; knownNames.has(uniqueName);) uniqueName = name + "." + ++suffix;
			knownNames.add(uniqueName), uniqueNames.push(uniqueName)
		}
		return uniqueNames
	},
	mappingsArrayToTable = extensionDef => {
		let table = new Map;
		for (let mapping of extensionDef.mappings)
			for (let variant of mapping.variants) table.set(variant, {
				material: null,
				gltfMaterialIndex: mapping.material
			});
		return table
	};
class GLTFMaterialsVariantsExtension {
	constructor(parser) {
		this.parser = parser, this.name = "KHR_materials_variants"
	}
	afterRoot(gltf) {
		let parser = this.parser,
			json = parser.json;
		if (void 0 === json.extensions || void 0 === json.extensions[this.name]) return null;
		let variants = ensureUniqueNames((json.extensions[this.name].variants || []).map(v => v.name));
		for (let scene of gltf.scenes) scene.traverse(object => {
			if (!object.material) return;
			let association = parser.associations.get(object);
			if (null == association || null == association.meshes || null == association.primitives) return;
			let extensionsDef = json.meshes[association.meshes].primitives[association.primitives].extensions;
			extensionsDef && extensionsDef[this.name] && (object.userData.variantMaterials = mappingsArrayToTable(extensionsDef[this.name]))
		});
		return gltf.userData.variants = variants, Promise.resolve()
	}
}
Texture$1.DEFAULT_ANISOTROPY = 4;
let loadWithLoader = (url, loader, progressCallback = () => {}) => {
		let onProgress = event => {
			let fraction = event.loaded / event.total;
			progressCallback(Math.max(0, Math.min(1, isFinite(fraction) ? fraction : 1)))
		};
		return new Promise((resolve, reject) => {
			loader.load(url, resolve, onProgress, reject)
		})
	},
	fetchScript = src => new Promise((resolve, reject) => {
		let script = document.createElement("script");
		document.body.appendChild(script), script.onload = resolve, script.onerror = reject, script.async = !0, script.src = src
	}),
	cache = new Map,
	preloaded = new Map,
	dracoLoader = new class extends Loader {
		constructor(manager) {
			super(manager), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
				position: "POSITION",
				normal: "NORMAL",
				color: "COLOR",
				uv: "TEX_COORD"
			}, this.defaultAttributeTypes = {
				position: "Float32Array",
				normal: "Float32Array",
				color: "Float32Array",
				uv: "Float32Array"
			}
		}
		setDecoderPath(path) {
			return this.decoderPath = path, this
		}
		setDecoderConfig(config) {
			return this.decoderConfig = config, this
		}
		setWorkerLimit(workerLimit) {
			return this.workerLimit = workerLimit, this
		}
		load(url, onLoad, onProgress, onError) {
			let loader = new FileLoader(this.manager);
			loader.setPath(this.path), loader.setResponseType("arraybuffer"), loader.setRequestHeader(this.requestHeader), loader.setWithCredentials(this.withCredentials), loader.load(url, buffer => {
				this.parse(buffer, onLoad, onError)
			}, onProgress, onError)
		}
		parse(buffer, onLoad, onError = () => {}) {
			this.decodeDracoFile(buffer, onLoad, null, null, SRGBColorSpace).catch(onError)
		}
		decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = LinearSRGBColorSpace, onError = () => {}) {
			let taskConfig = {
				attributeIDs: attributeIDs || this.defaultAttributeIDs,
				attributeTypes: attributeTypes || this.defaultAttributeTypes,
				useUniqueIDs: !!attributeIDs,
				vertexColorSpace: vertexColorSpace
			};
			return this.decodeGeometry(buffer, taskConfig).then(callback).catch(onError)
		}
		decodeGeometry(buffer, taskConfig) {
			let worker;
			let taskKey = JSON.stringify(taskConfig);
			if (_taskCache$1.has(buffer)) {
				let cachedTask = _taskCache$1.get(buffer);
				if (cachedTask.key === taskKey) return cachedTask.promise;
				if (0 === buffer.byteLength) throw Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
			}
			let taskID = this.workerNextTaskID++,
				taskCost = buffer.byteLength,
				geometryPending = this._getWorker(taskID, taskCost).then(_worker => (worker = _worker, new Promise((resolve, reject) => {
					worker._callbacks[taskID] = {
						resolve,
						reject
					}, worker.postMessage({
						type: "decode",
						id: taskID,
						taskConfig,
						buffer
					}, [buffer])
				}))).then(message => this._createGeometry(message.geometry));
			return geometryPending.catch(() => !0).then(() => {
				worker && taskID && this._releaseTask(worker, taskID)
			}), _taskCache$1.set(buffer, {
				key: taskKey,
				promise: geometryPending
			}), geometryPending
		}
		_createGeometry(geometryData) {
			let geometry = new BufferGeometry;
			geometryData.index && geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));
			for (let i = 0; i < geometryData.attributes.length; i++) {
				let result = geometryData.attributes[i],
					name = result.name,
					array = result.array,
					attribute = new BufferAttribute(array, result.itemSize);
				"color" === name && (this._assignVertexColorSpace(attribute, result.vertexColorSpace), attribute.normalized = array instanceof Float32Array == !1), geometry.setAttribute(name, attribute)
			}
			return geometry
		}
		_assignVertexColorSpace(attribute, inputColorSpace) {
			if (inputColorSpace !== SRGBColorSpace) return;
			let _color = new Color;
			for (let i = 0, il = attribute.count; i < il; i++) _color.fromBufferAttribute(attribute, i).convertSRGBToLinear(), attribute.setXYZ(i, _color.r, _color.g, _color.b)
		}
		_loadLibrary(url, responseType) {
			let loader = new FileLoader(this.manager);
			return loader.setPath(this.decoderPath), loader.setResponseType(responseType), loader.setWithCredentials(this.withCredentials), new Promise((resolve, reject) => {
				loader.load(url, resolve, void 0, reject)
			})
		}
		preload() {
			return this._initDecoder(), this
		}
		_initDecoder() {
			if (this.decoderPending) return this.decoderPending;
			let useJS = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
				librariesPending = [];
			return useJS ? librariesPending.push(this._loadLibrary("draco_decoder.js", "text")) : (librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), librariesPending.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(librariesPending).then(libraries => {
				let jsContent = libraries[0];
				useJS || (this.decoderConfig.wasmBinary = libraries[1]);
				let fn = DRACOWorker.toString(),
					body = ["/* draco decoder */", jsContent, "", "/* worker */", fn.substring(fn.indexOf("{") + 1, fn.lastIndexOf("}"))].join("\n");
				this.workerSourceURL = URL.createObjectURL(new Blob([body]))
			}), this.decoderPending
		}
		_getWorker(taskID, taskCost) {
			return this._initDecoder().then(() => {
				if (this.workerPool.length < this.workerLimit) {
					let worker = new Worker(this.workerSourceURL);
					worker._callbacks = {}, worker._taskCosts = {}, worker._taskLoad = 0, worker.postMessage({
						type: "init",
						decoderConfig: this.decoderConfig
					}), worker.onmessage = function(e) {
						let message = e.data;
						switch (message.type) {
							case "decode":
								worker._callbacks[message.id].resolve(message);
								break;
							case "error":
								worker._callbacks[message.id].reject(message);
								break;
							default:
								console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"')
						}
					}, this.workerPool.push(worker)
				} else this.workerPool.sort(function(a, b) {
					return a._taskLoad > b._taskLoad ? -1 : 1
				});
				let worker = this.workerPool[this.workerPool.length - 1];
				return worker._taskCosts[taskID] = taskCost, worker._taskLoad += taskCost, worker
			})
		}
		_releaseTask(worker, taskID) {
			worker._taskLoad -= worker._taskCosts[taskID], delete worker._callbacks[taskID], delete worker._taskCosts[taskID]
		}
		debug() {
			console.log("Task load: ", this.workerPool.map(worker => worker._taskLoad))
		}
		dispose() {
			for (let i = 0; i < this.workerPool.length; ++i) this.workerPool[i].terminate();
			return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
		}
	},
	ktx2Loader = new KTX2Loader,
	$loader = Symbol("loader"),
	$evictionPolicy = Symbol("evictionPolicy"),
	$GLTFInstance = Symbol("GLTFInstance");
class CachingGLTFLoader extends EventDispatcher {
	constructor(GLTFInstance) {
		super(), this[_b$8] = new GLTFLoader().register(parser => new GLTFMaterialsVariantsExtension(parser)), this[$GLTFInstance] = GLTFInstance, this[$loader].setDRACOLoader(dracoLoader), this[$loader].setKTX2Loader(ktx2Loader)
	}
	static setDRACODecoderLocation(url) {
		dracoDecoderLocation = url, dracoLoader.setDecoderPath(url)
	}
	static getDRACODecoderLocation() {
		return dracoDecoderLocation
	}
	static setKTX2TranscoderLocation(url) {
		ktx2TranscoderLocation = url, ktx2Loader.setTranscoderPath(url)
	}
	static getKTX2TranscoderLocation() {
		return ktx2TranscoderLocation
	}
	static setMeshoptDecoderLocation(url) {
		meshoptDecoderLocation !== url && (meshoptDecoderLocation = url, meshoptDecoder = fetchScript(url).then(() => MeshoptDecoder.ready).then(() => MeshoptDecoder))
	}
	static getMeshoptDecoderLocation() {
		return meshoptDecoderLocation
	}
	static initializeKTX2Loader(renderer) {
		ktx2Loader.detectSupport(renderer)
	}
	static get cache() {
		return cache
	}
	static clearCache() {
		cache.forEach((_value, url) => {
			this.delete(url)
		}), this[$evictionPolicy].reset()
	}
	static has(url) {
		return cache.has(url)
	}
	static async delete(url) {
		if (!this.has(url)) return;
		let gltfLoads = cache.get(url);
		preloaded.delete(url), cache.delete(url), (await gltfLoads).dispose()
	}
	static hasFinishedLoading(url) {
		return !!preloaded.get(url)
	}
	get[(_a$8 = $evictionPolicy, _b$8 = $loader, $evictionPolicy)]() {
		return this.constructor[$evictionPolicy]
	}
	async preload(url, element, progressCallback = () => {}) {
		if (this[$loader].setWithCredentials(CachingGLTFLoader.withCredentials), this.dispatchEvent({
				type: "preload",
				element: element,
				src: url
			}), !cache.has(url)) {
			null != meshoptDecoder && this[$loader].setMeshoptDecoder(await meshoptDecoder);
			let rawGLTFLoads = loadWithLoader(url, this[$loader], progress => {
					progressCallback(.8 * progress)
				}),
				GLTFInstance = this[$GLTFInstance],
				gltfInstanceLoads = rawGLTFLoads.then(rawGLTF => GLTFInstance.prepare(rawGLTF)).then(preparedGLTF => (progressCallback(.9), new GLTFInstance(preparedGLTF))).catch(reason => (console.error(reason), new GLTFInstance));
			cache.set(url, gltfInstanceLoads)
		}
		await cache.get(url), preloaded.set(url, !0), progressCallback && progressCallback(1)
	}
	async load(url, element, progressCallback = () => {}) {
		await this.preload(url, element, progressCallback);
		let gltf = await cache.get(url),
			clone = await gltf.clone();
		return this[$evictionPolicy].retain(url), clone.dispose = () => {
			this[$evictionPolicy].release(url)
		}, clone
	}
}
CachingGLTFLoader[_a$8] = new CacheEvictionPolicy(CachingGLTFLoader);
class CSS2DObject extends Object3D {
	constructor(element = document.createElement("div")) {
		super(), this.isCSS2DObject = !0, this.element = element, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.center = new Vector2(.5, .5), this.addEventListener("removed", function() {
			this.traverse(function(object) {
				object.element instanceof Element && null !== object.element.parentNode && object.element.parentNode.removeChild(object.element)
			})
		})
	}
	copy(source, recursive) {
		return super.copy(source, recursive), this.element = source.element.cloneNode(!0), this.center = source.center, this
	}
}
let _vector = new Vector3,
	_viewMatrix = new Matrix4,
	_viewProjectionMatrix = new Matrix4,
	_a$7 = new Vector3,
	_b$7 = new Vector3;
class CSS2DRenderer {
	constructor(parameters = {}) {
		let _width, _height, _widthHalf, _heightHalf;
		let _this = this,
			cache = {
				objects: new WeakMap
			},
			domElement = void 0 !== parameters.element ? parameters.element : document.createElement("div");
		domElement.style.overflow = "hidden", this.domElement = domElement, this.getSize = function() {
			return {
				width: _width,
				height: _height
			}
		}, this.render = function(scene, camera) {
			!0 === scene.matrixWorldAutoUpdate && scene.updateMatrixWorld(), null === camera.parent && !0 === camera.matrixWorldAutoUpdate && camera.updateMatrixWorld(), _viewMatrix.copy(camera.matrixWorldInverse), _viewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, _viewMatrix),
				function renderObject(object, scene, camera) {
					if (object.isCSS2DObject) {
						_vector.setFromMatrixPosition(object.matrixWorld), _vector.applyMatrix4(_viewProjectionMatrix);
						let visible = !0 === object.visible && _vector.z >= -1 && _vector.z <= 1 && !0 === object.layers.test(camera.layers);
						if (object.element.style.display = !0 === visible ? "" : "none", !0 === visible) {
							object.onBeforeRender(_this, scene, camera);
							let element = object.element;
							element.style.transform = "translate(" + -100 * object.center.x + "%," + -100 * object.center.y + "%)translate(" + (_vector.x * _widthHalf + _widthHalf) + "px," + (-_vector.y * _heightHalf + _heightHalf) + "px)", element.parentNode !== domElement && domElement.appendChild(element), object.onAfterRender(_this, scene, camera)
						}
						let objectData = {
							distanceToCameraSquared: (_a$7.setFromMatrixPosition(camera.matrixWorld), _b$7.setFromMatrixPosition(object.matrixWorld), _a$7.distanceToSquared(_b$7))
						};
						cache.objects.set(object, objectData)
					}
					for (let i = 0, l = object.children.length; i < l; i++) renderObject(object.children[i], scene, camera)
				}(scene, scene, camera),
				function(scene) {
					let sorted = (function(scene) {
							let result = [];
							return scene.traverse(function(object) {
								object.isCSS2DObject && result.push(object)
							}), result
						})(scene).sort(function(a, b) {
							return a.renderOrder !== b.renderOrder ? b.renderOrder - a.renderOrder : cache.objects.get(a).distanceToCameraSquared - cache.objects.get(b).distanceToCameraSquared
						}),
						zMax = sorted.length;
					for (let i = 0, l = sorted.length; i < l; i++) sorted[i].element.style.zIndex = zMax - i
				}(scene)
		}, this.setSize = function(width, height) {
			_width = width, _height = height, _widthHalf = _width / 2, _heightHalf = _height / 2, domElement.style.width = width + "px", domElement.style.height = height + "px"
		}
	}
}

function reduceVertices(object, func, initialValue) {
	let value = initialValue,
		vertex = new Vector3;
	return object.updateWorldMatrix(!0, !0), object.traverseVisible(child => {
		let {
			geometry
		} = child;
		if (void 0 !== geometry) {
			let {
				position
			} = geometry.attributes;
			if (void 0 !== position)
				for (let i = 0, l = position.count; i < l; i++) child.isMesh ? child.getVertexPosition(i, vertex) : vertex.fromBufferAttribute(position, i), child.isSkinnedMesh || vertex.applyMatrix4(child.matrixWorld), value = func(value, vertex)
		}
	}), value
}

function decompress(texture, maxTextureSize = 1 / 0, renderer = null) {
	fullscreenQuadGeometry || (fullscreenQuadGeometry = new PlaneGeometry(2, 2, 1, 1)), fullscreenQuadMaterial || (fullscreenQuadMaterial = new ShaderMaterial({
		uniforms: {
			blitTexture: new Uniform(texture)
		},
		vertexShader: `
			varying vec2 vUv;
			void main(){
				vUv = uv;
				gl_Position = vec4(position.xy * 1.0,0.,.999999);
			}`,
		fragmentShader: `
			uniform sampler2D blitTexture; 
			varying vec2 vUv;

			void main(){ 
				gl_FragColor = vec4(vUv.xy, 0, 1);
				
				#ifdef IS_SRGB
				gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
				#else
				gl_FragColor = texture2D( blitTexture, vUv);
				#endif
			}`
	})), fullscreenQuadMaterial.uniforms.blitTexture.value = texture, fullscreenQuadMaterial.defines.IS_SRGB = texture.colorSpace == SRGBColorSpace, fullscreenQuadMaterial.needsUpdate = !0, fullscreenQuad || ((fullscreenQuad = new Mesh(fullscreenQuadGeometry, fullscreenQuadMaterial)).frustrumCulled = !1);
	let _camera = new PerspectiveCamera,
		_scene = new Scene;
	_scene.add(fullscreenQuad), null === renderer && (renderer = _renderer = new WebGLRenderer({
		antialias: !1
	}));
	let width = Math.min(texture.image.width, maxTextureSize),
		height = Math.min(texture.image.height, maxTextureSize);
	renderer.setSize(width, height), renderer.clear(), renderer.render(_scene, _camera);
	let canvas = document.createElement("canvas"),
		context = canvas.getContext("2d");
	canvas.width = width, canvas.height = height, context.drawImage(renderer.domElement, 0, 0, width, height);
	let readableTexture = new CanvasTexture(canvas);
	return readableTexture.minFilter = texture.minFilter, readableTexture.magFilter = texture.magFilter, readableTexture.wrapS = texture.wrapS, readableTexture.wrapT = texture.wrapT, readableTexture.name = texture.name, _renderer && (_renderer.forceContextLoss(), _renderer.dispose(), _renderer = null), readableTexture
}
let KHR_mesh_quantization_ExtraAttrTypes = {
	POSITION: ["byte", "byte normalized", "unsigned byte", "unsigned byte normalized", "short", "short normalized", "unsigned short", "unsigned short normalized"],
	NORMAL: ["byte normalized", "short normalized"],
	TANGENT: ["byte normalized", "short normalized"],
	TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
class GLTFExporter {
	constructor() {
		this.pluginCallbacks = [], this.register(function(writer) {
			return new GLTFLightExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsUnlitExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsTransmissionExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsVolumeExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsIorExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsSpecularExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsClearcoatExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsIridescenceExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsSheenExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsAnisotropyExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsEmissiveStrengthExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMaterialsBumpExtension(writer)
		}), this.register(function(writer) {
			return new GLTFMeshGpuInstancing(writer)
		})
	}
	register(callback) {
		return -1 === this.pluginCallbacks.indexOf(callback) && this.pluginCallbacks.push(callback), this
	}
	unregister(callback) {
		return -1 !== this.pluginCallbacks.indexOf(callback) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1), this
	}
	parse(input, onDone, onError, options) {
		let writer = new GLTFWriter,
			plugins = [];
		for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) plugins.push(this.pluginCallbacks[i](writer));
		writer.setPlugins(plugins), writer.write(input, onDone, options).catch(onError)
	}
	parseAsync(input, options) {
		let scope = this;
		return new Promise(function(resolve, reject) {
			scope.parse(input, resolve, reject, options)
		})
	}
}
let WEBGL_CONSTANTS = {
		POINTS: 0,
		LINES: 1,
		LINE_LOOP: 2,
		LINE_STRIP: 3,
		TRIANGLES: 4,
		BYTE: 5120,
		UNSIGNED_BYTE: 5121,
		SHORT: 5122,
		UNSIGNED_SHORT: 5123,
		INT: 5124,
		UNSIGNED_INT: 5125,
		FLOAT: 5126,
		ARRAY_BUFFER: 34962,
		ELEMENT_ARRAY_BUFFER: 34963,
		NEAREST: 9728,
		LINEAR: 9729,
		NEAREST_MIPMAP_NEAREST: 9984,
		LINEAR_MIPMAP_NEAREST: 9985,
		NEAREST_MIPMAP_LINEAR: 9986,
		LINEAR_MIPMAP_LINEAR: 9987,
		CLAMP_TO_EDGE: 33071,
		MIRRORED_REPEAT: 33648,
		REPEAT: 10497
	},
	KHR_MESH_QUANTIZATION = "KHR_mesh_quantization",
	THREE_TO_WEBGL = {};
THREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST, THREE_TO_WEBGL[1004] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST, THREE_TO_WEBGL[1005] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR, THREE_TO_WEBGL[1006] = WEBGL_CONSTANTS.LINEAR, THREE_TO_WEBGL[1007] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST, THREE_TO_WEBGL[1008] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR, THREE_TO_WEBGL[1001] = WEBGL_CONSTANTS.CLAMP_TO_EDGE, THREE_TO_WEBGL[1e3] = WEBGL_CONSTANTS.REPEAT, THREE_TO_WEBGL[1002] = WEBGL_CONSTANTS.MIRRORED_REPEAT;
let PATH_PROPERTIES = {
		scale: "scale",
		position: "translation",
		quaternion: "rotation",
		morphTargetInfluences: "weights"
	},
	DEFAULT_SPECULAR_COLOR = new Color;

function equalArray(array1, array2) {
	return array1.length === array2.length && array1.every(function(element, index) {
		return element === array2[index]
	})
}

function getPaddedBufferSize(bufferSize) {
	return 4 * Math.ceil(bufferSize / 4)
}

function getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
	let paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);
	if (paddedLength !== arrayBuffer.byteLength) {
		let array = new Uint8Array(paddedLength);
		if (array.set(new Uint8Array(arrayBuffer)), 0 !== paddingByte)
			for (let i = arrayBuffer.byteLength; i < paddedLength; i++) array[i] = paddingByte;
		return array.buffer
	}
	return arrayBuffer
}

function getCanvas() {
	return "undefined" == typeof document && "undefined" != typeof OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement("canvas")
}

function getToBlobPromise(canvas, mimeType) {
	let quality;
	return void 0 !== canvas.toBlob ? new Promise(resolve => canvas.toBlob(resolve, mimeType)) : ("image/jpeg" === mimeType ? quality = .92 : "image/webp" === mimeType && (quality = .8), canvas.convertToBlob({
		type: mimeType,
		quality: quality
	}))
}
class GLTFWriter {
	constructor() {
		this.plugins = [], this.options = {}, this.pending = [], this.buffers = [], this.byteOffset = 0, this.buffers = [], this.nodeMap = new Map, this.skins = [], this.extensionsUsed = {}, this.extensionsRequired = {}, this.uids = new Map, this.uid = 0, this.json = {
			asset: {
				version: "2.0",
				generator: "THREE.GLTFExporter"
			}
		}, this.cache = {
			meshes: new Map,
			attributes: new Map,
			attributesNormalized: new Map,
			materials: new Map,
			textures: new Map,
			images: new Map
		}
	}
	setPlugins(plugins) {
		this.plugins = plugins
	}
	async write(input, onDone, options = {}) {
		this.options = Object.assign({
			binary: !1,
			trs: !1,
			onlyVisible: !0,
			maxTextureSize: 1 / 0,
			animations: [],
			includeCustomExtensions: !1
		}, options), this.options.animations.length > 0 && (this.options.trs = !0), this.processInput(input), await Promise.all(this.pending);
		let buffers = this.buffers,
			json = this.json;
		options = this.options;
		let extensionsUsed = this.extensionsUsed,
			extensionsRequired = this.extensionsRequired,
			blob = new Blob(buffers, {
				type: "application/octet-stream"
			}),
			extensionsUsedList = Object.keys(extensionsUsed),
			extensionsRequiredList = Object.keys(extensionsRequired);
		if (extensionsUsedList.length > 0 && (json.extensionsUsed = extensionsUsedList), extensionsRequiredList.length > 0 && (json.extensionsRequired = extensionsRequiredList), json.buffers && json.buffers.length > 0 && (json.buffers[0].byteLength = blob.size), !0 === options.binary) {
			let reader = new FileReader;
			reader.readAsArrayBuffer(blob), reader.onloadend = function() {
				var text;
				let binaryChunk = getPaddedArrayBuffer(reader.result),
					binaryChunkPrefix = new DataView(new ArrayBuffer(8));
				binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, !0), binaryChunkPrefix.setUint32(4, 5130562, !0);
				let jsonChunk = getPaddedArrayBuffer((text = JSON.stringify(json), new TextEncoder().encode(text).buffer), 32),
					jsonChunkPrefix = new DataView(new ArrayBuffer(8));
				jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, !0), jsonChunkPrefix.setUint32(4, 1313821514, !0);
				let header = new ArrayBuffer(12),
					headerView = new DataView(header);
				headerView.setUint32(0, 1179937895, !0), headerView.setUint32(4, 2, !0);
				let totalByteLength = 12 + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
				headerView.setUint32(8, totalByteLength, !0);
				let glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {
						type: "application/octet-stream"
					}),
					glbReader = new FileReader;
				glbReader.readAsArrayBuffer(glbBlob), glbReader.onloadend = function() {
					onDone(glbReader.result)
				}
			}
		} else if (json.buffers && json.buffers.length > 0) {
			let reader = new FileReader;
			reader.readAsDataURL(blob), reader.onloadend = function() {
				let base64data = reader.result;
				json.buffers[0].uri = base64data, onDone(json)
			}
		} else onDone(json)
	}
	serializeUserData(object, objectDef) {
		if (0 === Object.keys(object.userData).length) return;
		let options = this.options,
			extensionsUsed = this.extensionsUsed;
		try {
			let json = JSON.parse(JSON.stringify(object.userData));
			if (options.includeCustomExtensions && json.gltfExtensions) {
				for (let extensionName in void 0 === objectDef.extensions && (objectDef.extensions = {}), json.gltfExtensions) objectDef.extensions[extensionName] = json.gltfExtensions[extensionName], extensionsUsed[extensionName] = !0;
				delete json.gltfExtensions
			}
			Object.keys(json).length > 0 && (objectDef.extras = json)
		} catch (error) {
			console.warn("THREE.GLTFExporter: userData of '" + object.name + "' won't be serialized because of JSON.stringify error - " + error.message)
		}
	}
	getUID(attribute, isRelativeCopy = !1) {
		if (!1 === this.uids.has(attribute)) {
			let uids = new Map;
			uids.set(!0, this.uid++), uids.set(!1, this.uid++), this.uids.set(attribute, uids)
		}
		return this.uids.get(attribute).get(isRelativeCopy)
	}
	isNormalizedNormalAttribute(normal) {
		if (this.cache.attributesNormalized.has(normal)) return !1;
		let v = new Vector3;
		for (let i = 0, il = normal.count; i < il; i++)
			if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1) > 5e-4) return !1;
		return !0
	}
	createNormalizedNormalAttribute(normal) {
		let cache = this.cache;
		if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);
		let attribute = normal.clone(),
			v = new Vector3;
		for (let i = 0, il = attribute.count; i < il; i++) v.fromBufferAttribute(attribute, i), 0 === v.x && 0 === v.y && 0 === v.z ? v.setX(1) : v.normalize(), attribute.setXYZ(i, v.x, v.y, v.z);
		return cache.attributesNormalized.set(normal, attribute), attribute
	}
	applyTextureTransform(mapDef, texture) {
		let didTransform = !1,
			transformDef = {};
		(0 !== texture.offset.x || 0 !== texture.offset.y) && (transformDef.offset = texture.offset.toArray(), didTransform = !0), 0 !== texture.rotation && (transformDef.rotation = texture.rotation, didTransform = !0), (1 !== texture.repeat.x || 1 !== texture.repeat.y) && (transformDef.scale = texture.repeat.toArray(), didTransform = !0), didTransform && (mapDef.extensions = mapDef.extensions || {}, mapDef.extensions.KHR_texture_transform = transformDef, this.extensionsUsed.KHR_texture_transform = !0)
	}
	buildMetalRoughTexture(metalnessMap, roughnessMap) {
		if (metalnessMap === roughnessMap) return metalnessMap;

		function getEncodingConversion(map) {
			return map.colorSpace === SRGBColorSpace ? function(c) {
				return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4)
			} : function(c) {
				return c
			}
		}
		console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."), metalnessMap instanceof CompressedTexture && (metalnessMap = decompress(metalnessMap)), roughnessMap instanceof CompressedTexture && (roughnessMap = decompress(roughnessMap));
		let metalness = metalnessMap ? metalnessMap.image : null,
			roughness = roughnessMap ? roughnessMap.image : null,
			width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0),
			height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0),
			canvas = getCanvas();
		canvas.width = width, canvas.height = height;
		let context = canvas.getContext("2d");
		context.fillStyle = "#00ffff", context.fillRect(0, 0, width, height);
		let composite = context.getImageData(0, 0, width, height);
		if (metalness) {
			context.drawImage(metalness, 0, 0, width, height);
			let convert = getEncodingConversion(metalnessMap),
				data = context.getImageData(0, 0, width, height).data;
			for (let i = 2; i < data.length; i += 4) composite.data[i] = 256 * convert(data[i] / 256)
		}
		if (roughness) {
			context.drawImage(roughness, 0, 0, width, height);
			let convert = getEncodingConversion(roughnessMap),
				data = context.getImageData(0, 0, width, height).data;
			for (let i = 1; i < data.length; i += 4) composite.data[i] = 256 * convert(data[i] / 256)
		}
		context.putImageData(composite, 0, 0);
		let texture = (metalnessMap || roughnessMap).clone();
		return texture.source = new Source(canvas), texture.colorSpace = "", texture.channel = (metalnessMap || roughnessMap).channel, metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."), texture
	}
	processBuffer(buffer) {
		let json = this.json,
			buffers = this.buffers;
		return json.buffers || (json.buffers = [{
			byteLength: 0
		}]), buffers.push(buffer), 0
	}
	processBufferView(attribute, componentType, start, count, target) {
		let componentSize;
		let json = this.json;
		switch (json.bufferViews || (json.bufferViews = []), componentType) {
			case WEBGL_CONSTANTS.BYTE:
			case WEBGL_CONSTANTS.UNSIGNED_BYTE:
				componentSize = 1;
				break;
			case WEBGL_CONSTANTS.SHORT:
			case WEBGL_CONSTANTS.UNSIGNED_SHORT:
				componentSize = 2;
				break;
			default:
				componentSize = 4
		}
		let byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize),
			dataView = new DataView(new ArrayBuffer(byteLength)),
			offset = 0;
		for (let i = start; i < start + count; i++)
			for (let a = 0; a < attribute.itemSize; a++) {
				let value;
				attribute.itemSize > 4 ? value = attribute.array[i * attribute.itemSize + a] : (0 === a ? value = attribute.getX(i) : 1 === a ? value = attribute.getY(i) : 2 === a ? value = attribute.getZ(i) : 3 === a && (value = attribute.getW(i)), !0 === attribute.normalized && (value = MathUtils.normalize(value, attribute.array))), componentType === WEBGL_CONSTANTS.FLOAT ? dataView.setFloat32(offset, value, !0) : componentType === WEBGL_CONSTANTS.INT ? dataView.setInt32(offset, value, !0) : componentType === WEBGL_CONSTANTS.UNSIGNED_INT ? dataView.setUint32(offset, value, !0) : componentType === WEBGL_CONSTANTS.SHORT ? dataView.setInt16(offset, value, !0) : componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ? dataView.setUint16(offset, value, !0) : componentType === WEBGL_CONSTANTS.BYTE ? dataView.setInt8(offset, value) : componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE && dataView.setUint8(offset, value), offset += componentSize
			}
		let bufferViewDef = {
			buffer: this.processBuffer(dataView.buffer),
			byteOffset: this.byteOffset,
			byteLength: byteLength
		};
		return void 0 !== target && (bufferViewDef.target = target), target === WEBGL_CONSTANTS.ARRAY_BUFFER && (bufferViewDef.byteStride = attribute.itemSize * componentSize), this.byteOffset += byteLength, json.bufferViews.push(bufferViewDef), {
			id: json.bufferViews.length - 1,
			byteLength: 0
		}
	}
	processBufferViewImage(blob) {
		let writer = this,
			json = writer.json;
		return json.bufferViews || (json.bufferViews = []), new Promise(function(resolve) {
			let reader = new FileReader;
			reader.readAsArrayBuffer(blob), reader.onloadend = function() {
				let buffer = getPaddedArrayBuffer(reader.result),
					bufferViewDef = {
						buffer: writer.processBuffer(buffer),
						byteOffset: writer.byteOffset,
						byteLength: buffer.byteLength
					};
				writer.byteOffset += buffer.byteLength, resolve(json.bufferViews.push(bufferViewDef) - 1)
			}
		})
	}
	processAccessor(attribute, geometry, start, count) {
		let componentType, bufferViewTarget;
		let json = this.json;
		if (attribute.array.constructor === Float32Array) componentType = WEBGL_CONSTANTS.FLOAT;
		else if (attribute.array.constructor === Int32Array) componentType = WEBGL_CONSTANTS.INT;
		else if (attribute.array.constructor === Uint32Array) componentType = WEBGL_CONSTANTS.UNSIGNED_INT;
		else if (attribute.array.constructor === Int16Array) componentType = WEBGL_CONSTANTS.SHORT;
		else if (attribute.array.constructor === Uint16Array) componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;
		else if (attribute.array.constructor === Int8Array) componentType = WEBGL_CONSTANTS.BYTE;
		else if (attribute.array.constructor === Uint8Array) componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;
		else throw Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + attribute.array.constructor.name);
		if (void 0 === start && (start = 0), (void 0 === count || count === 1 / 0) && (count = attribute.count), 0 === count) return null;
		let minMax = function(attribute, start, count) {
			let output = {
				min: Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),
				max: Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)
			};
			for (let i = start; i < start + count; i++)
				for (let a = 0; a < attribute.itemSize; a++) {
					let value;
					attribute.itemSize > 4 ? value = attribute.array[i * attribute.itemSize + a] : (0 === a ? value = attribute.getX(i) : 1 === a ? value = attribute.getY(i) : 2 === a ? value = attribute.getZ(i) : 3 === a && (value = attribute.getW(i)), !0 === attribute.normalized && (value = MathUtils.normalize(value, attribute.array))), output.min[a] = Math.min(output.min[a], value), output.max[a] = Math.max(output.max[a], value)
				}
			return output
		}(attribute, start, count);
		void 0 !== geometry && (bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER);
		let bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget),
			accessorDef = {
				bufferView: bufferView.id,
				byteOffset: bufferView.byteOffset,
				componentType: componentType,
				count: count,
				max: minMax.max,
				min: minMax.min,
				type: {
					1: "SCALAR",
					2: "VEC2",
					3: "VEC3",
					4: "VEC4",
					9: "MAT3",
					16: "MAT4"
				} [attribute.itemSize]
			};
		return !0 === attribute.normalized && (accessorDef.normalized = !0), json.accessors || (json.accessors = []), json.accessors.push(accessorDef) - 1
	}
	processImage(image, format, flipY, mimeType = "image/png") {
		if (null !== image) {
			let writer = this,
				cache = writer.cache,
				json = writer.json,
				options = writer.options,
				pending = writer.pending;
			cache.images.has(image) || cache.images.set(image, {});
			let cachedImages = cache.images.get(image),
				key = mimeType + ":flipY/" + flipY.toString();
			if (void 0 !== cachedImages[key]) return cachedImages[key];
			json.images || (json.images = []);
			let imageDef = {
					mimeType: mimeType
				},
				canvas = getCanvas();
			canvas.width = Math.min(image.width, options.maxTextureSize), canvas.height = Math.min(image.height, options.maxTextureSize);
			let ctx = canvas.getContext("2d");
			if (!0 === flipY && (ctx.translate(0, canvas.height), ctx.scale(1, -1)), void 0 !== image.data) {
				1023 !== format && console.error("GLTFExporter: Only RGBAFormat is supported.", format), (image.width > options.maxTextureSize || image.height > options.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", image);
				let data = new Uint8ClampedArray(image.height * image.width * 4);
				for (let i = 0; i < data.length; i += 4) data[i + 0] = image.data[i + 0], data[i + 1] = image.data[i + 1], data[i + 2] = image.data[i + 2], data[i + 3] = image.data[i + 3];
				ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0)
			} else ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
			!0 === options.binary ? pending.push(getToBlobPromise(canvas, mimeType).then(blob => writer.processBufferViewImage(blob)).then(bufferViewIndex => {
				imageDef.bufferView = bufferViewIndex
			})) : void 0 !== canvas.toDataURL ? imageDef.uri = canvas.toDataURL(mimeType) : pending.push(getToBlobPromise(canvas, mimeType).then(blob => new FileReader().readAsDataURL(blob)).then(dataURL => {
				imageDef.uri = dataURL
			}));
			let index = json.images.push(imageDef) - 1;
			return cachedImages[key] = index, index
		}
		throw Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")
	}
	processSampler(map) {
		let json = this.json;
		json.samplers || (json.samplers = []);
		let samplerDef = {
			magFilter: THREE_TO_WEBGL[map.magFilter],
			minFilter: THREE_TO_WEBGL[map.minFilter],
			wrapS: THREE_TO_WEBGL[map.wrapS],
			wrapT: THREE_TO_WEBGL[map.wrapT]
		};
		return json.samplers.push(samplerDef) - 1
	}
	processTexture(map) {
		let options = this.options,
			cache = this.cache,
			json = this.json;
		if (cache.textures.has(map)) return cache.textures.get(map);
		json.textures || (json.textures = []), map instanceof CompressedTexture && (map = decompress(map, options.maxTextureSize));
		let mimeType = map.userData.mimeType;
		"image/webp" === mimeType && (mimeType = "image/png");
		let textureDef = {
			sampler: this.processSampler(map),
			source: this.processImage(map.image, map.format, map.flipY, mimeType)
		};
		map.name && (textureDef.name = map.name), this._invokeAll(function(ext) {
			ext.writeTexture && ext.writeTexture(map, textureDef)
		});
		let index = json.textures.push(textureDef) - 1;
		return cache.textures.set(map, index), index
	}
	processMaterial(material) {
		let cache = this.cache,
			json = this.json;
		if (cache.materials.has(material)) return cache.materials.get(material);
		if (material.isShaderMaterial) return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."), null;
		json.materials || (json.materials = []);
		let materialDef = {
			pbrMetallicRoughness: {}
		};
		!0 !== material.isMeshStandardMaterial && !0 !== material.isMeshBasicMaterial && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
		let color = material.color.toArray().concat([material.opacity]);
		if (equalArray(color, [1, 1, 1, 1]) || (materialDef.pbrMetallicRoughness.baseColorFactor = color), material.isMeshStandardMaterial ? (materialDef.pbrMetallicRoughness.metallicFactor = material.metalness, materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness) : (materialDef.pbrMetallicRoughness.metallicFactor = .5, materialDef.pbrMetallicRoughness.roughnessFactor = .5), material.metalnessMap || material.roughnessMap) {
			let metalRoughTexture = this.buildMetalRoughTexture(material.metalnessMap, material.roughnessMap),
				metalRoughMapDef = {
					index: this.processTexture(metalRoughTexture),
					channel: metalRoughTexture.channel
				};
			this.applyTextureTransform(metalRoughMapDef, metalRoughTexture), materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef
		}
		if (material.map) {
			let baseColorMapDef = {
				index: this.processTexture(material.map),
				texCoord: material.map.channel
			};
			this.applyTextureTransform(baseColorMapDef, material.map), materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef
		}
		if (material.emissive) {
			let emissive = material.emissive;
			if (Math.max(emissive.r, emissive.g, emissive.b) > 0 && (materialDef.emissiveFactor = material.emissive.toArray()), material.emissiveMap) {
				let emissiveMapDef = {
					index: this.processTexture(material.emissiveMap),
					texCoord: material.emissiveMap.channel
				};
				this.applyTextureTransform(emissiveMapDef, material.emissiveMap), materialDef.emissiveTexture = emissiveMapDef
			}
		}
		if (material.normalMap) {
			let normalMapDef = {
				index: this.processTexture(material.normalMap),
				texCoord: material.normalMap.channel
			};
			material.normalScale && 1 !== material.normalScale.x && (normalMapDef.scale = material.normalScale.x), this.applyTextureTransform(normalMapDef, material.normalMap), materialDef.normalTexture = normalMapDef
		}
		if (material.aoMap) {
			let occlusionMapDef = {
				index: this.processTexture(material.aoMap),
				texCoord: material.aoMap.channel
			};
			1 !== material.aoMapIntensity && (occlusionMapDef.strength = material.aoMapIntensity), this.applyTextureTransform(occlusionMapDef, material.aoMap), materialDef.occlusionTexture = occlusionMapDef
		}
		material.transparent ? materialDef.alphaMode = "BLEND" : material.alphaTest > 0 && (materialDef.alphaMode = "MASK", materialDef.alphaCutoff = material.alphaTest), 2 === material.side && (materialDef.doubleSided = !0), "" !== material.name && (materialDef.name = material.name), this.serializeUserData(material, materialDef), this._invokeAll(function(ext) {
			ext.writeMaterial && ext.writeMaterial(material, materialDef)
		});
		let index = json.materials.push(materialDef) - 1;
		return cache.materials.set(material, index), index
	}
	processMesh(mesh) {
		let mode;
		let cache = this.cache,
			json = this.json,
			meshCacheKeyParts = [mesh.geometry.uuid];
		if (Array.isArray(mesh.material))
			for (let i = 0, l = mesh.material.length; i < l; i++) meshCacheKeyParts.push(mesh.material[i].uuid);
		else meshCacheKeyParts.push(mesh.material.uuid);
		let meshCacheKey = meshCacheKeyParts.join(":");
		if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);
		let geometry = mesh.geometry;
		mode = mesh.isLineSegments ? WEBGL_CONSTANTS.LINES : mesh.isLineLoop ? WEBGL_CONSTANTS.LINE_LOOP : mesh.isLine ? WEBGL_CONSTANTS.LINE_STRIP : mesh.isPoints ? WEBGL_CONSTANTS.POINTS : mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;
		let meshDef = {},
			attributes = {},
			primitives = [],
			targets = [],
			nameConversion = {
				uv: "TEXCOORD_0",
				uv1: "TEXCOORD_1",
				uv2: "TEXCOORD_2",
				uv3: "TEXCOORD_3",
				color: "COLOR_0",
				skinWeight: "WEIGHTS_0",
				skinIndex: "JOINTS_0"
			},
			originalNormal = geometry.getAttribute("normal");
		void 0 === originalNormal || this.isNormalizedNormalAttribute(originalNormal) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."), geometry.setAttribute("normal", this.createNormalizedNormalAttribute(originalNormal)));
		let modifiedAttribute = null;
		for (let attributeName in geometry.attributes) {
			if ("morph" === attributeName.slice(0, 5)) continue;
			let attribute = geometry.attributes[attributeName];
			if (attributeName = nameConversion[attributeName] || attributeName.toUpperCase(), /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(attributeName) || (attributeName = "_" + attributeName), cache.attributes.has(this.getUID(attribute))) {
				attributes[attributeName] = cache.attributes.get(this.getUID(attribute));
				continue
			}
			modifiedAttribute = null;
			let array = attribute.array;
			"JOINTS_0" !== attributeName || array instanceof Uint16Array || array instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'), modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized));
			let accessor = this.processAccessor(modifiedAttribute || attribute, geometry);
			null !== accessor && (attributeName.startsWith("_") || this.detectMeshQuantization(attributeName, attribute), attributes[attributeName] = accessor, cache.attributes.set(this.getUID(attribute), accessor))
		}
		if (void 0 !== originalNormal && geometry.setAttribute("normal", originalNormal), 0 === Object.keys(attributes).length) return null;
		if (void 0 !== mesh.morphTargetInfluences && mesh.morphTargetInfluences.length > 0) {
			let weights = [],
				targetNames = [],
				reverseDictionary = {};
			if (void 0 !== mesh.morphTargetDictionary)
				for (let key in mesh.morphTargetDictionary) reverseDictionary[mesh.morphTargetDictionary[key]] = key;
			for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {
				let target = {},
					warned = !1;
				for (let attributeName in geometry.morphAttributes) {
					if ("position" !== attributeName && "normal" !== attributeName) {
						warned || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."), warned = !0);
						continue
					}
					let attribute = geometry.morphAttributes[attributeName][i],
						gltfAttributeName = attributeName.toUpperCase(),
						baseAttribute = geometry.attributes[attributeName];
					if (cache.attributes.has(this.getUID(attribute, !0))) {
						target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, !0));
						continue
					}
					let relativeAttribute = attribute.clone();
					if (!geometry.morphTargetsRelative)
						for (let j = 0, jl = attribute.count; j < jl; j++)
							for (let a = 0; a < attribute.itemSize; a++) 0 === a && relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j)), 1 === a && relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j)), 2 === a && relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j)), 3 === a && relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));
					target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry), cache.attributes.set(this.getUID(baseAttribute, !0), target[gltfAttributeName])
				}
				targets.push(target), weights.push(mesh.morphTargetInfluences[i]), void 0 !== mesh.morphTargetDictionary && targetNames.push(reverseDictionary[i])
			}
			meshDef.weights = weights, targetNames.length > 0 && (meshDef.extras = {}, meshDef.extras.targetNames = targetNames)
		}
		let isMultiMaterial = Array.isArray(mesh.material);
		if (isMultiMaterial && 0 === geometry.groups.length) return null;
		let didForceIndices = !1;
		if (isMultiMaterial && null === geometry.index) {
			let indices = [];
			for (let i = 0, il = geometry.attributes.position.count; i < il; i++) indices[i] = i;
			geometry.setIndex(indices), didForceIndices = !0
		}
		let materials = isMultiMaterial ? mesh.material : [mesh.material],
			groups = isMultiMaterial ? geometry.groups : [{
				materialIndex: 0,
				start: void 0,
				count: void 0
			}];
		for (let i = 0, il = groups.length; i < il; i++) {
			let primitive = {
				mode: mode,
				attributes: attributes
			};
			if (this.serializeUserData(geometry, primitive), targets.length > 0 && (primitive.targets = targets), null !== geometry.index) {
				let cacheKey = this.getUID(geometry.index);
				(void 0 !== groups[i].start || void 0 !== groups[i].count) && (cacheKey += ":" + groups[i].start + ":" + groups[i].count), cache.attributes.has(cacheKey) ? primitive.indices = cache.attributes.get(cacheKey) : (primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count), cache.attributes.set(cacheKey, primitive.indices)), null === primitive.indices && delete primitive.indices
			}
			let material = this.processMaterial(materials[groups[i].materialIndex]);
			null !== material && (primitive.material = material), primitives.push(primitive)
		}!0 === didForceIndices && geometry.setIndex(null), meshDef.primitives = primitives, json.meshes || (json.meshes = []), this._invokeAll(function(ext) {
			ext.writeMesh && ext.writeMesh(mesh, meshDef)
		});
		let index = json.meshes.push(meshDef) - 1;
		return cache.meshes.set(meshCacheKey, index), index
	}
	detectMeshQuantization(attributeName, attribute) {
		let attrType;
		if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;
		switch (attribute.array.constructor) {
			case Int8Array:
				attrType = "byte";
				break;
			case Uint8Array:
				attrType = "unsigned byte";
				break;
			case Int16Array:
				attrType = "short";
				break;
			case Uint16Array:
				attrType = "unsigned short";
				break;
			default:
				return
		}
		attribute.normalized && (attrType += " normalized");
		let attrNamePrefix = attributeName.split("_", 1)[0];
		KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType) && (this.extensionsUsed[KHR_MESH_QUANTIZATION] = !0, this.extensionsRequired[KHR_MESH_QUANTIZATION] = !0)
	}
	processCamera(camera) {
		let json = this.json;
		json.cameras || (json.cameras = []);
		let isOrtho = camera.isOrthographicCamera,
			cameraDef = {
				type: isOrtho ? "orthographic" : "perspective"
			};
		return isOrtho ? cameraDef.orthographic = {
			xmag: 2 * camera.right,
			ymag: 2 * camera.top,
			zfar: camera.far <= 0 ? .001 : camera.far,
			znear: camera.near < 0 ? 0 : camera.near
		} : cameraDef.perspective = {
			aspectRatio: camera.aspect,
			yfov: MathUtils.degToRad(camera.fov),
			zfar: camera.far <= 0 ? .001 : camera.far,
			znear: camera.near < 0 ? 0 : camera.near
		}, "" !== camera.name && (cameraDef.name = camera.type), json.cameras.push(cameraDef) - 1
	}
	processAnimation(clip, root) {
		let json = this.json,
			nodeMap = this.nodeMap;
		json.animations || (json.animations = []);
		let tracks = (clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root)).tracks,
			channels = [],
			samplers = [];
		for (let i = 0; i < tracks.length; ++i) {
			let interpolation;
			let track = tracks[i],
				trackBinding = PropertyBinding.parseTrackName(track.name),
				trackNode = PropertyBinding.findNode(root, trackBinding.nodeName),
				trackProperty = PATH_PROPERTIES[trackBinding.propertyName];
			if ("bones" === trackBinding.objectName && (trackNode = !0 === trackNode.isSkinnedMesh ? trackNode.skeleton.getBoneByName(trackBinding.objectIndex) : void 0), !trackNode || !trackProperty) return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', track.name), null;
			let outputItemSize = track.values.length / track.times.length;
			trackProperty === PATH_PROPERTIES.morphTargetInfluences && (outputItemSize /= trackNode.morphTargetInfluences.length), !0 === track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ? (interpolation = "CUBICSPLINE", outputItemSize /= 3) : interpolation = 2300 === track.getInterpolation() ? "STEP" : "LINEAR", samplers.push({
				input: this.processAccessor(new BufferAttribute(track.times, 1)),
				output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),
				interpolation: interpolation
			}), channels.push({
				sampler: samplers.length - 1,
				target: {
					node: nodeMap.get(trackNode),
					path: trackProperty
				}
			})
		}
		return json.animations.push({
			name: clip.name || "clip_" + json.animations.length,
			samplers: samplers,
			channels: channels
		}), json.animations.length - 1
	}
	processSkin(object) {
		let json = this.json,
			nodeMap = this.nodeMap,
			node = json.nodes[nodeMap.get(object)],
			skeleton = object.skeleton;
		if (void 0 === skeleton) return null;
		let rootJoint = object.skeleton.bones[0];
		if (void 0 === rootJoint) return null;
		let joints = [],
			inverseBindMatrices = new Float32Array(16 * skeleton.bones.length),
			temporaryBoneInverse = new Matrix4;
		for (let i = 0; i < skeleton.bones.length; ++i) joints.push(nodeMap.get(skeleton.bones[i])), temporaryBoneInverse.copy(skeleton.boneInverses[i]), temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, 16 * i);
		return void 0 === json.skins && (json.skins = []), json.skins.push({
			inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),
			joints: joints,
			skeleton: nodeMap.get(rootJoint)
		}), node.skin = json.skins.length - 1
	}
	processNode(object) {
		let json = this.json,
			options = this.options,
			nodeMap = this.nodeMap;
		json.nodes || (json.nodes = []);
		let nodeDef = {};
		if (options.trs) {
			let rotation = object.quaternion.toArray(),
				position = object.position.toArray(),
				scale = object.scale.toArray();
			equalArray(rotation, [0, 0, 0, 1]) || (nodeDef.rotation = rotation), equalArray(position, [0, 0, 0]) || (nodeDef.translation = position), equalArray(scale, [1, 1, 1]) || (nodeDef.scale = scale)
		} else object.matrixAutoUpdate && object.updateMatrix(), !1 === equalArray(object.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) && (nodeDef.matrix = object.matrix.elements);
		if ("" !== object.name && (nodeDef.name = String(object.name)), this.serializeUserData(object, nodeDef), object.isMesh || object.isLine || object.isPoints) {
			let meshIndex = this.processMesh(object);
			null !== meshIndex && (nodeDef.mesh = meshIndex)
		} else object.isCamera && (nodeDef.camera = this.processCamera(object));
		if (object.isSkinnedMesh && this.skins.push(object), object.children.length > 0) {
			let children = [];
			for (let i = 0, l = object.children.length; i < l; i++) {
				let child = object.children[i];
				if (child.visible || !1 === options.onlyVisible) {
					let nodeIndex = this.processNode(child);
					null !== nodeIndex && children.push(nodeIndex)
				}
			}
			children.length > 0 && (nodeDef.children = children)
		}
		this._invokeAll(function(ext) {
			ext.writeNode && ext.writeNode(object, nodeDef)
		});
		let nodeIndex = json.nodes.push(nodeDef) - 1;
		return nodeMap.set(object, nodeIndex), nodeIndex
	}
	processScene(scene) {
		let json = this.json,
			options = this.options;
		json.scenes || (json.scenes = [], json.scene = 0);
		let sceneDef = {};
		"" !== scene.name && (sceneDef.name = scene.name), json.scenes.push(sceneDef);
		let nodes = [];
		for (let i = 0, l = scene.children.length; i < l; i++) {
			let child = scene.children[i];
			if (child.visible || !1 === options.onlyVisible) {
				let nodeIndex = this.processNode(child);
				null !== nodeIndex && nodes.push(nodeIndex)
			}
		}
		nodes.length > 0 && (sceneDef.nodes = nodes), this.serializeUserData(scene, sceneDef)
	}
	processObjects(objects) {
		let scene = new Scene;
		scene.name = "AuxScene";
		for (let i = 0; i < objects.length; i++) scene.children.push(objects[i]);
		this.processScene(scene)
	}
	processInput(input) {
		let options = this.options;
		input = input instanceof Array ? input : [input], this._invokeAll(function(ext) {
			ext.beforeParse && ext.beforeParse(input)
		});
		let objectsWithoutScene = [];
		for (let i = 0; i < input.length; i++) input[i] instanceof Scene ? this.processScene(input[i]) : objectsWithoutScene.push(input[i]);
		objectsWithoutScene.length > 0 && this.processObjects(objectsWithoutScene);
		for (let i = 0; i < this.skins.length; ++i) this.processSkin(this.skins[i]);
		for (let i = 0; i < options.animations.length; ++i) this.processAnimation(options.animations[i], input[0]);
		this._invokeAll(function(ext) {
			ext.afterParse && ext.afterParse(input)
		})
	}
	_invokeAll(func) {
		for (let i = 0, il = this.plugins.length; i < il; i++) func(this.plugins[i])
	}
}
class GLTFLightExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_lights_punctual"
	}
	writeNode(light, nodeDef) {
		if (!light.isLight) return;
		if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {
			console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", light);
			return
		}
		let writer = this.writer,
			json = writer.json,
			extensionsUsed = writer.extensionsUsed,
			lightDef = {};
		light.name && (lightDef.name = light.name), lightDef.color = light.color.toArray(), lightDef.intensity = light.intensity, light.isDirectionalLight ? lightDef.type = "directional" : light.isPointLight ? (lightDef.type = "point", light.distance > 0 && (lightDef.range = light.distance)) : light.isSpotLight && (lightDef.type = "spot", light.distance > 0 && (lightDef.range = light.distance), lightDef.spot = {}, lightDef.spot.innerConeAngle = (1 - light.penumbra) * light.angle, lightDef.spot.outerConeAngle = light.angle), void 0 !== light.decay && 2 !== light.decay && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."), light.target && (light.target.parent !== light || 0 !== light.target.position.x || 0 !== light.target.position.y || -1 !== light.target.position.z) && console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."), extensionsUsed[this.name] || (json.extensions = json.extensions || {}, json.extensions[this.name] = {
			lights: []
		}, extensionsUsed[this.name] = !0);
		let lights = json.extensions[this.name].lights;
		lights.push(lightDef), nodeDef.extensions = nodeDef.extensions || {}, nodeDef.extensions[this.name] = {
			light: lights.length - 1
		}
	}
}
class GLTFMaterialsUnlitExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_unlit"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshBasicMaterial) return;
		let extensionsUsed = this.writer.extensionsUsed;
		materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = {}, extensionsUsed[this.name] = !0, materialDef.pbrMetallicRoughness.metallicFactor = 0, materialDef.pbrMetallicRoughness.roughnessFactor = .9
	}
}
class GLTFMaterialsClearcoatExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_clearcoat"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshPhysicalMaterial || 0 === material.clearcoat) return;
		let writer = this.writer,
			extensionsUsed = writer.extensionsUsed,
			extensionDef = {};
		if (extensionDef.clearcoatFactor = material.clearcoat, material.clearcoatMap) {
			let clearcoatMapDef = {
				index: writer.processTexture(material.clearcoatMap),
				texCoord: material.clearcoatMap.channel
			};
			writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap), extensionDef.clearcoatTexture = clearcoatMapDef
		}
		if (extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness, material.clearcoatRoughnessMap) {
			let clearcoatRoughnessMapDef = {
				index: writer.processTexture(material.clearcoatRoughnessMap),
				texCoord: material.clearcoatRoughnessMap.channel
			};
			writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap), extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef
		}
		if (material.clearcoatNormalMap) {
			let clearcoatNormalMapDef = {
				index: writer.processTexture(material.clearcoatNormalMap),
				texCoord: material.clearcoatNormalMap.channel
			};
			writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap), extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef
		}
		materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMaterialsIridescenceExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_iridescence"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshPhysicalMaterial || 0 === material.iridescence) return;
		let writer = this.writer,
			extensionsUsed = writer.extensionsUsed,
			extensionDef = {};
		if (extensionDef.iridescenceFactor = material.iridescence, material.iridescenceMap) {
			let iridescenceMapDef = {
				index: writer.processTexture(material.iridescenceMap),
				texCoord: material.iridescenceMap.channel
			};
			writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap), extensionDef.iridescenceTexture = iridescenceMapDef
		}
		if (extensionDef.iridescenceIor = material.iridescenceIOR, extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0], extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1], material.iridescenceThicknessMap) {
			let iridescenceThicknessMapDef = {
				index: writer.processTexture(material.iridescenceThicknessMap),
				texCoord: material.iridescenceThicknessMap.channel
			};
			writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap), extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef
		}
		materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMaterialsTransmissionExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_transmission"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshPhysicalMaterial || 0 === material.transmission) return;
		let writer = this.writer,
			extensionsUsed = writer.extensionsUsed,
			extensionDef = {};
		if (extensionDef.transmissionFactor = material.transmission, material.transmissionMap) {
			let transmissionMapDef = {
				index: writer.processTexture(material.transmissionMap),
				texCoord: material.transmissionMap.channel
			};
			writer.applyTextureTransform(transmissionMapDef, material.transmissionMap), extensionDef.transmissionTexture = transmissionMapDef
		}
		materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMaterialsVolumeExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_volume"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshPhysicalMaterial || 0 === material.transmission) return;
		let writer = this.writer,
			extensionsUsed = writer.extensionsUsed,
			extensionDef = {};
		if (extensionDef.thicknessFactor = material.thickness, material.thicknessMap) {
			let thicknessMapDef = {
				index: writer.processTexture(material.thicknessMap),
				texCoord: material.thicknessMap.channel
			};
			writer.applyTextureTransform(thicknessMapDef, material.thicknessMap), extensionDef.thicknessTexture = thicknessMapDef
		}
		extensionDef.attenuationDistance = material.attenuationDistance, extensionDef.attenuationColor = material.attenuationColor.toArray(), materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMaterialsIorExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_ior"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshPhysicalMaterial || 1.5 === material.ior) return;
		let extensionsUsed = this.writer.extensionsUsed,
			extensionDef = {};
		extensionDef.ior = material.ior, materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMaterialsSpecularExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_specular"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshPhysicalMaterial || 1 === material.specularIntensity && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorMap) return;
		let writer = this.writer,
			extensionsUsed = writer.extensionsUsed,
			extensionDef = {};
		if (material.specularIntensityMap) {
			let specularIntensityMapDef = {
				index: writer.processTexture(material.specularIntensityMap),
				texCoord: material.specularIntensityMap.channel
			};
			writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap), extensionDef.specularTexture = specularIntensityMapDef
		}
		if (material.specularColorMap) {
			let specularColorMapDef = {
				index: writer.processTexture(material.specularColorMap),
				texCoord: material.specularColorMap.channel
			};
			writer.applyTextureTransform(specularColorMapDef, material.specularColorMap), extensionDef.specularColorTexture = specularColorMapDef
		}
		extensionDef.specularFactor = material.specularIntensity, extensionDef.specularColorFactor = material.specularColor.toArray(), materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMaterialsSheenExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_sheen"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshPhysicalMaterial || 0 == material.sheen) return;
		let writer = this.writer,
			extensionsUsed = writer.extensionsUsed,
			extensionDef = {};
		if (material.sheenRoughnessMap) {
			let sheenRoughnessMapDef = {
				index: writer.processTexture(material.sheenRoughnessMap),
				texCoord: material.sheenRoughnessMap.channel
			};
			writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap), extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef
		}
		if (material.sheenColorMap) {
			let sheenColorMapDef = {
				index: writer.processTexture(material.sheenColorMap),
				texCoord: material.sheenColorMap.channel
			};
			writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap), extensionDef.sheenColorTexture = sheenColorMapDef
		}
		extensionDef.sheenRoughnessFactor = material.sheenRoughness, extensionDef.sheenColorFactor = material.sheenColor.toArray(), materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMaterialsAnisotropyExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_anisotropy"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshPhysicalMaterial || 0 == material.anisotropy) return;
		let writer = this.writer,
			extensionsUsed = writer.extensionsUsed,
			extensionDef = {};
		if (material.anisotropyMap) {
			let anisotropyMapDef = {
				index: writer.processTexture(material.anisotropyMap)
			};
			writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap), extensionDef.anisotropyTexture = anisotropyMapDef
		}
		extensionDef.anisotropyStrength = material.anisotropy, extensionDef.anisotropyRotation = material.anisotropyRotation, materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMaterialsEmissiveStrengthExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_emissive_strength"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshStandardMaterial || 1 === material.emissiveIntensity) return;
		let extensionsUsed = this.writer.extensionsUsed,
			extensionDef = {};
		extensionDef.emissiveStrength = material.emissiveIntensity, materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMaterialsBumpExtension {
	constructor(writer) {
		this.writer = writer, this.name = "EXT_materials_bump"
	}
	writeMaterial(material, materialDef) {
		if (!material.isMeshStandardMaterial || 1 === material.bumpScale && !material.bumpMap) return;
		let writer = this.writer,
			extensionsUsed = writer.extensionsUsed,
			extensionDef = {};
		if (material.bumpMap) {
			let bumpMapDef = {
				index: writer.processTexture(material.bumpMap),
				texCoord: material.bumpMap.channel
			};
			writer.applyTextureTransform(bumpMapDef, material.bumpMap), extensionDef.bumpTexture = bumpMapDef
		}
		extensionDef.bumpFactor = material.bumpScale, materialDef.extensions = materialDef.extensions || {}, materialDef.extensions[this.name] = extensionDef, extensionsUsed[this.name] = !0
	}
}
class GLTFMeshGpuInstancing {
	constructor(writer) {
		this.writer = writer, this.name = "EXT_mesh_gpu_instancing"
	}
	writeNode(object, nodeDef) {
		if (!object.isInstancedMesh) return;
		let writer = this.writer,
			translationAttr = new Float32Array(3 * object.count),
			rotationAttr = new Float32Array(4 * object.count),
			scaleAttr = new Float32Array(3 * object.count),
			matrix = new Matrix4,
			position = new Vector3,
			quaternion = new Quaternion,
			scale = new Vector3;
		for (let i = 0; i < object.count; i++) object.getMatrixAt(i, matrix), matrix.decompose(position, quaternion, scale), position.toArray(translationAttr, 3 * i), quaternion.toArray(rotationAttr, 4 * i), scale.toArray(scaleAttr, 3 * i);
		let attributes = {
			TRANSLATION: writer.processAccessor(new BufferAttribute(translationAttr, 3)),
			ROTATION: writer.processAccessor(new BufferAttribute(rotationAttr, 4)),
			SCALE: writer.processAccessor(new BufferAttribute(scaleAttr, 3))
		};
		object.instanceColor && (attributes._COLOR_0 = writer.processAccessor(object.instanceColor)), nodeDef.extensions = nodeDef.extensions || {}, nodeDef.extensions[this.name] = {
			attributes
		}, writer.extensionsUsed[this.name] = !0, writer.extensionsRequired[this.name] = !0
	}
}
GLTFExporter.Utils = {
	insertKeyframe: function(track, time) {
		let index;
		let valueSize = track.getValueSize(),
			times = new track.TimeBufferType(track.times.length + 1),
			values = new track.ValueBufferType(track.values.length + valueSize),
			interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));
		if (0 === track.times.length) {
			times[0] = time;
			for (let i = 0; i < valueSize; i++) values[i] = 0;
			index = 0
		} else if (time < track.times[0]) {
			if (.001 > Math.abs(track.times[0] - time)) return 0;
			times[0] = time, times.set(track.times, 1), values.set(interpolant.evaluate(time), 0), values.set(track.values, valueSize), index = 0
		} else if (time > track.times[track.times.length - 1]) {
			if (.001 > Math.abs(track.times[track.times.length - 1] - time)) return track.times.length - 1;
			times[times.length - 1] = time, times.set(track.times, 0), values.set(track.values, 0), values.set(interpolant.evaluate(time), track.values.length), index = times.length - 1
		} else
			for (let i = 0; i < track.times.length; i++) {
				if (.001 > Math.abs(track.times[i] - time)) return i;
				if (track.times[i] < time && track.times[i + 1] > time) {
					times.set(track.times.slice(0, i + 1), 0), times[i + 1] = time, times.set(track.times.slice(i + 1), i + 2), values.set(track.values.slice(0, (i + 1) * valueSize), 0), values.set(interpolant.evaluate(time), (i + 1) * valueSize), values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize), index = i + 1;
					break
				}
			}
		return track.times = times, track.values = values, index
	},
	mergeMorphTargetTracks: function(clip, root) {
		let tracks = [],
			mergedTracks = {},
			sourceTracks = clip.tracks;
		for (let i = 0; i < sourceTracks.length; ++i) {
			let mergedTrack, sourceTrack = sourceTracks[i],
				sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name),
				sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);
			if ("morphTargetInfluences" !== sourceTrackBinding.propertyName || void 0 === sourceTrackBinding.propertyIndex) {
				tracks.push(sourceTrack);
				continue
			}
			if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {
				if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) throw Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
				console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."), (sourceTrack = sourceTrack.clone()).setInterpolation(2301)
			}
			let targetCount = sourceTrackNode.morphTargetInfluences.length,
				targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];
			if (void 0 === targetIndex) throw Error("THREE.GLTFExporter: Morph target name not found: " + sourceTrackBinding.propertyIndex);
			if (void 0 === mergedTracks[sourceTrackNode.uuid]) {
				let values = new(mergedTrack = sourceTrack.clone()).ValueBufferType(targetCount * mergedTrack.times.length);
				for (let j = 0; j < mergedTrack.times.length; j++) values[j * targetCount + targetIndex] = mergedTrack.values[j];
				mergedTrack.name = (sourceTrackBinding.nodeName || "") + ".morphTargetInfluences", mergedTrack.values = values, mergedTracks[sourceTrackNode.uuid] = mergedTrack, tracks.push(mergedTrack);
				continue
			}
			let sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));
			mergedTrack = mergedTracks[sourceTrackNode.uuid];
			for (let j = 0; j < mergedTrack.times.length; j++) mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);
			for (let j = 0; j < sourceTrack.times.length; j++) {
				let keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);
				mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j]
			}
		}
		return clip.tracks = tracks, clip
	}
};
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let compatibleObject = object => void 0 !== object.material && object.userData && object.userData.variantMaterials && !!Array.from(object.userData.variantMaterials.values()).filter(m => compatibleMaterial(m.material)),
	compatibleMaterial = material => material && material.isMaterial && !Array.isArray(material);
class GLTFExporterMaterialsVariantsExtension {
	constructor(writer) {
		this.writer = writer, this.name = "KHR_materials_variants", this.variantNames = []
	}
	beforeParse(objects) {
		let variantNameSet = new Set;
		for (let object of objects) object.traverse(o => {
			if (!compatibleObject(o)) return;
			let variantMaterials = o.userData.variantMaterials;
			for (let [variantName, variantData] of o.userData.variantData) {
				let variantMaterial = variantMaterials.get(variantData.index);
				variantMaterial && compatibleMaterial(variantMaterial.material) && variantNameSet.add(variantName)
			}
		});
		variantNameSet.forEach(name => this.variantNames.push(name))
	}
	writeMesh(mesh, meshDef) {
		if (!compatibleObject(mesh)) return;
		let userData = mesh.userData,
			variantMaterials = userData.variantMaterials,
			variantDataMap = userData.variantData,
			mappingTable = new Map,
			reIndexedVariants = new Map;
		for (let [i, variantData] of Array.from(variantDataMap.values()).sort((a, b) => a.index - b.index).entries()) reIndexedVariants.set(variantData.index, i);
		for (let variantData of variantDataMap.values()) {
			let variantInstance = variantMaterials.get(variantData.index);
			if (!variantInstance || !compatibleMaterial(variantInstance.material)) continue;
			let materialIndex = this.writer.processMaterial(variantInstance.material);
			mappingTable.has(materialIndex) || mappingTable.set(materialIndex, {
				material: materialIndex,
				variants: []
			}), mappingTable.get(materialIndex).variants.push(reIndexedVariants.get(variantData.index))
		}
		let mappingsDef = Array.from(mappingTable.values()).map(m => m.variants.sort((a, b) => a - b) && m).sort((a, b) => a.material - b.material);
		if (0 === mappingsDef.length) return;
		let originalMaterialIndex = compatibleMaterial(userData.originalMaterial) ? this.writer.processMaterial(userData.originalMaterial) : -1;
		for (let primitiveDef of meshDef.primitives) originalMaterialIndex >= 0 && (primitiveDef.material = originalMaterialIndex), primitiveDef.extensions = primitiveDef.extensions || {}, primitiveDef.extensions[this.name] = {
			mappings: mappingsDef
		}
	}
	afterParse() {
		if (0 === this.variantNames.length) return;
		let root = this.writer.json;
		root.extensions = root.extensions || {};
		let variantsDef = this.variantNames.map(n => ({
			name: n
		}));
		root.extensions[this.name] = {
			variants: variantsDef
		}, this.writer.extensionsUsed[this.name] = !0
	}
}
class SessionLightProbe {
	constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {
		this.xrLight = xrLight, this.renderer = renderer, this.lightProbe = lightProbe, this.xrWebGLBinding = null, this.estimationStartCallback = estimationStartCallback, this.frameCallback = this.onXRFrame.bind(this);
		let session = renderer.xr.getSession();
		if (environmentEstimation && "XRWebGLBinding" in window) {
			let cubeRenderTarget = new WebGLCubeRenderTarget(16);
			xrLight.environment = cubeRenderTarget.texture;
			let gl = renderer.getContext();
			switch (session.preferredReflectionFormat) {
				case "srgba8":
					gl.getExtension("EXT_sRGB");
					break;
				case "rgba16f":
					gl.getExtension("OES_texture_half_float")
			}
			this.xrWebGLBinding = new XRWebGLBinding(session, gl), this.lightProbe.addEventListener("reflectionchange", () => {
				this.updateReflection()
			})
		}
		session.requestAnimationFrame(this.frameCallback)
	}
	updateReflection() {
		let textureProperties = this.renderer.properties.get(this.xrLight.environment);
		if (textureProperties) {
			let cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
			cubeMap && (textureProperties.__webglTexture = cubeMap, this.xrLight.environment.needsPMREMUpdate = !0)
		}
	}
	onXRFrame(time, xrFrame) {
		if (!this.xrLight) return;
		xrFrame.session.requestAnimationFrame(this.frameCallback);
		let lightEstimate = xrFrame.getLightEstimate(this.lightProbe);
		if (lightEstimate) {
			this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients), this.xrLight.lightProbe.intensity = 1;
			let intensityScalar = Math.max(1, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));
			this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar), this.xrLight.directionalLight.intensity = intensityScalar, this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection), this.estimationStartCallback && (this.estimationStartCallback(), this.estimationStartCallback = null)
		}
	}
	dispose() {
		this.xrLight = null, this.renderer = null, this.lightProbe = null, this.xrWebGLBinding = null
	}
}
class XREstimatedLight extends Group {
	constructor(renderer, environmentEstimation = !0) {
		super(), this.lightProbe = new LightProbe, this.lightProbe.intensity = 0, this.add(this.lightProbe), this.directionalLight = new DirectionalLight, this.directionalLight.intensity = 0, this.add(this.directionalLight), this.environment = null;
		let sessionLightProbe = null,
			estimationStarted = !1;
		renderer.xr.addEventListener("sessionstart", () => {
			let session = renderer.xr.getSession();
			"requestLightProbe" in session && session.requestLightProbe({
				reflectionFormat: session.preferredReflectionFormat
			}).then(probe => {
				sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {
					estimationStarted = !0, this.dispatchEvent({
						type: "estimationstart"
					})
				})
			})
		}), renderer.xr.addEventListener("sessionend", () => {
			sessionLightProbe && (sessionLightProbe.dispose(), sessionLightProbe = null), estimationStarted && this.dispatchEvent({
				type: "estimationend"
			})
		}), this.dispose = () => {
			sessionLightProbe && (sessionLightProbe.dispose(), sessionLightProbe = null), this.remove(this.lightProbe), this.lightProbe = null, this.remove(this.directionalLight), this.directionalLight = null, this.environment = null
		}
	}
}
class Damper {
	constructor(decayMilliseconds = 50) {
		this.velocity = 0, this.naturalFrequency = 0, this.setDecayTime(decayMilliseconds)
	}
	setDecayTime(decayMilliseconds) {
		this.naturalFrequency = 1 / Math.max(.001, decayMilliseconds)
	}
	update(x, xGoal, timeStepMilliseconds, xNormalization) {
		let nilSpeed = 2e-4 * this.naturalFrequency;
		if (null == x || 0 === xNormalization || x === xGoal && 0 === this.velocity) return xGoal;
		if (timeStepMilliseconds < 0) return x;
		let deltaX = x - xGoal,
			intermediateVelocity = this.velocity + this.naturalFrequency * deltaX,
			intermediateX = deltaX + timeStepMilliseconds * intermediateVelocity,
			decay = Math.exp(-this.naturalFrequency * timeStepMilliseconds),
			newVelocity = (intermediateVelocity - this.naturalFrequency * intermediateX) * decay,
			acceleration = -this.naturalFrequency * (newVelocity + intermediateVelocity * decay);
		return Math.abs(newVelocity) < nilSpeed * Math.abs(xNormalization) && acceleration * deltaX >= 0 ? (this.velocity = 0, xGoal) : (this.velocity = newVelocity, xGoal + intermediateX * decay)
	}
}
let DELTA_PHI = Math.PI / 24,
	vector2$1 = new Vector2,
	addCorner = (vertices, cornerX, cornerY) => {
		let phi = cornerX > 0 ? cornerY > 0 ? 0 : -Math.PI / 2 : cornerY > 0 ? Math.PI / 2 : Math.PI;
		for (let i = 0; i <= 12; ++i) vertices.push(cornerX + .17 * Math.cos(phi), cornerY + .17 * Math.sin(phi), 0, cornerX + .2 * Math.cos(phi), cornerY + .2 * Math.sin(phi), 0), phi += DELTA_PHI
	};
class PlacementBox extends Mesh {
	constructor(scene, side) {
		let geometry = new BufferGeometry,
			triangles = [],
			vertices = [],
			{
				size,
				boundingBox
			} = scene,
			x = size.x / 2,
			y = ("back" === side ? size.y : size.z) / 2;
		addCorner(vertices, x, y), addCorner(vertices, -x, y), addCorner(vertices, -x, -y), addCorner(vertices, x, -y);
		let numVertices = vertices.length / 3;
		for (let i = 0; i < numVertices - 2; i += 2) triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);
		let i = numVertices - 2;
		triangles.push(i, i + 1, 1, i, 1, 0), geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3)), geometry.setIndex(triangles), super(geometry), this.side = side;
		let material = this.material;
		switch (material.side = 2, material.transparent = !0, material.opacity = 0, this.goalOpacity = 0, this.opacityDamper = new Damper, this.hitPlane = new Mesh(new PlaneGeometry(2 * (x + .2), 2 * (y + .2))), this.hitPlane.visible = !1, this.hitPlane.material.side = 2, this.add(this.hitPlane), boundingBox.getCenter(this.position), side) {
			case "bottom":
				this.rotateX(-Math.PI / 2), this.shadowHeight = boundingBox.min.y, this.position.y = this.shadowHeight;
				break;
			case "back":
				this.shadowHeight = boundingBox.min.z, this.position.z = this.shadowHeight
		}
		scene.target.add(this), this.offsetHeight = 0
	}
	getHit(scene, screenX, screenY) {
		vector2$1.set(screenX, -screenY), this.hitPlane.visible = !0;
		let hitResult = scene.positionAndNormalFromPoint(vector2$1, this.hitPlane);
		return this.hitPlane.visible = !1, null == hitResult ? null : hitResult.position
	}
	getExpandedHit(scene, screenX, screenY) {
		this.hitPlane.scale.set(1e3, 1e3, 1e3), this.hitPlane.updateMatrixWorld();
		let hitResult = this.getHit(scene, screenX, screenY);
		return this.hitPlane.scale.set(1, 1, 1), hitResult
	}
	set offsetHeight(offset) {
		offset -= .001, "back" === this.side ? this.position.z = this.shadowHeight + offset : this.position.y = this.shadowHeight + offset
	}
	get offsetHeight() {
		return "back" === this.side ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight
	}
	set show(visible) {
		this.goalOpacity = visible ? .75 : 0
	}
	updateOpacity(delta) {
		let material = this.material;
		material.opacity = this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1), this.visible = material.opacity > 0
	}
	dispose() {
		var _a;
		let {
			geometry,
			material
		} = this.hitPlane;
		geometry.dispose(), material.dispose(), this.geometry.dispose(), this.material.dispose(), null === (_a = this.parent) || void 0 === _a || _a.remove(this)
	}
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let numberNode = (value, unit) => ({
		type: "number",
		number: value,
		unit
	}),
	parseExpressions = (() => {
		let cache = {};
		return inputString => {
			let cacheKey = inputString;
			if (cacheKey in cache) return cache[cacheKey];
			let expressions = [],
				parseIterations = 0;
			for (; inputString;) {
				if (++parseIterations > 1e3) {
					inputString = "";
					break
				}
				let expressionParseResult = parseExpression(inputString),
					expression = expressionParseResult.nodes[0];
				if (null == expression || 0 === expression.terms.length) break;
				expressions.push(expression), inputString = expressionParseResult.remainingInput
			}
			return cache[cacheKey] = expressions
		}
	})(),
	parseExpression = (() => {
		let IS_IDENT_RE = /^(\-\-|[a-z\u0240-\uffff])/i,
			IS_OPERATOR_RE = /^([\*\+\/]|[\-]\s)/i,
			IS_EXPRESSION_END_RE = /^[\),]/;
		return inputString => {
			let terms = [];
			for (; inputString.length && (inputString = inputString.trim(), !IS_EXPRESSION_END_RE.test(inputString));)
				if ("(" === inputString[0]) {
					let {
						nodes,
						remainingInput
					} = parseFunctionArguments(inputString);
					inputString = remainingInput, terms.push({
						type: "function",
						name: {
							type: "ident",
							value: "calc"
						},
						arguments: nodes
					})
				} else if (IS_IDENT_RE.test(inputString)) {
				let identParseResult = parseIdent(inputString),
					identNode = identParseResult.nodes[0];
				if ("(" === (inputString = identParseResult.remainingInput)[0]) {
					let {
						nodes,
						remainingInput
					} = parseFunctionArguments(inputString);
					terms.push({
						type: "function",
						name: identNode,
						arguments: nodes
					}), inputString = remainingInput
				} else terms.push(identNode)
			} else if (IS_OPERATOR_RE.test(inputString)) terms.push({
				type: "operator",
				value: inputString[0]
			}), inputString = inputString.slice(1);
			else {
				let {
					nodes,
					remainingInput
				} = "#" === inputString[0] ? parseHex(inputString) : parseNumber(inputString);
				if (0 === nodes.length) break;
				terms.push(nodes[0]), inputString = remainingInput
			}
			return {
				nodes: [{
					type: "expression",
					terms
				}],
				remainingInput: inputString
			}
		}
	})(),
	parseIdent = (() => {
		let NOT_IDENT_RE = /[^a-z0-9_\-\u0240-\uffff]/i;
		return inputString => {
			let match = inputString.match(NOT_IDENT_RE);
			return {
				nodes: [{
					type: "ident",
					value: null == match ? inputString : inputString.substr(0, match.index)
				}],
				remainingInput: null == match ? "" : inputString.substr(match.index)
			}
		}
	})(),
	parseNumber = (() => {
		let VALUE_RE = /[\+\-]?(\d+[\.]\d+|\d+|[\.]\d+)([eE][\+\-]?\d+)?/,
			UNIT_RE = /^[a-z%]+/i,
			ALLOWED_UNITS = /^(m|mm|cm|rad|deg|[%])$/;
		return inputString => {
			let valueMatch = inputString.match(VALUE_RE),
				value = null == valueMatch ? "0" : valueMatch[0],
				unitMatch = (inputString = null == value ? inputString : inputString.slice(value.length)).match(UNIT_RE),
				unit = null != unitMatch && "" !== unitMatch[0] ? unitMatch[0] : null,
				remainingInput = null == unitMatch ? inputString : inputString.slice(unit.length);
			return null == unit || ALLOWED_UNITS.test(unit) || (unit = null), {
				nodes: [{
					type: "number",
					number: parseFloat(value) || 0,
					unit: unit
				}],
				remainingInput
			}
		}
	})(),
	parseHex = (() => {
		let HEX_RE = /^[a-f0-9]*/i;
		return inputString => {
			let hexMatch = (inputString = inputString.slice(1).trim()).match(HEX_RE);
			return {
				nodes: null == hexMatch ? [] : [{
					type: "hex",
					value: hexMatch[0]
				}],
				remainingInput: null == hexMatch ? inputString : inputString.slice(hexMatch[0].length)
			}
		}
	})(),
	parseFunctionArguments = inputString => {
		let expressionNodes = [];
		for (inputString = inputString.slice(1).trim(); inputString.length;) {
			let expressionParseResult = parseExpression(inputString);
			if (expressionNodes.push(expressionParseResult.nodes[0]), "," === (inputString = expressionParseResult.remainingInput.trim())[0]) inputString = inputString.slice(1).trim();
			else if (")" === inputString[0]) {
				inputString = inputString.slice(1);
				break
			}
		}
		return {
			nodes: expressionNodes,
			remainingInput: inputString
		}
	},
	$visitedTypes = Symbol("visitedTypes");
class ASTWalker {
	constructor(visitedTypes) {
		this[$visitedTypes] = visitedTypes
	}
	walk(ast, callback) {
		let remaining = ast.slice();
		for (; remaining.length;) {
			let next = remaining.shift();
			switch (this[$visitedTypes].indexOf(next.type) > -1 && callback(next), next.type) {
				case "expression":
					remaining.unshift(...next.terms);
					break;
				case "function":
					remaining.unshift(next.name, ...next.arguments)
			}
		}
	}
}
let ZERO = Object.freeze({
		type: "number",
		number: 0,
		unit: null
	}),
	degreesToRadians = (numberNode, fallbackRadianValue = 0) => {
		let {
			number,
			unit
		} = numberNode;
		if (isFinite(number)) {
			if ("rad" === numberNode.unit || null == numberNode.unit) return numberNode
		} else number = fallbackRadianValue, unit = "rad";
		return {
			type: "number",
			number: ("deg" === unit && null != number ? number : 0) * Math.PI / 180,
			unit: "rad"
		}
	},
	lengthToBaseMeters = (numberNode, fallbackMeterValue = 0) => {
		let scale, {
			number,
			unit
		} = numberNode;
		if (isFinite(number)) {
			if ("m" === numberNode.unit) return numberNode
		} else number = fallbackMeterValue, unit = "m";
		switch (unit) {
			default:
				scale = 1;
				break;
			case "cm":
				scale = .01;
				break;
			case "mm":
				scale = .001
		}
		return {
			type: "number",
			number: scale * number,
			unit: "m"
		}
	},
	normalizeUnit = (() => {
		let identity = node => node,
			unitNormalizers = {
				rad: identity,
				deg: degreesToRadians,
				m: identity,
				mm: lengthToBaseMeters,
				cm: lengthToBaseMeters
			};
		return (node, fallback = ZERO) => {
			isFinite(node.number) || (node.number = fallback.number, node.unit = fallback.unit);
			let {
				unit
			} = node;
			if (null == unit) return node;
			let normalize = unitNormalizers[unit];
			return null == normalize ? fallback : normalize(node)
		}
	})(),
	$evaluate = Symbol("evaluate"),
	$lastValue = Symbol("lastValue");
class Evaluator {
	constructor() {
		this[_a$6] = null
	}
	static evaluatableFor(node, basis = ZERO) {
		if (node instanceof Evaluator) return node;
		if ("number" === node.type) return "%" === node.unit ? new PercentageEvaluator(node, basis) : node;
		switch (node.name.value) {
			case "calc":
				return new CalcEvaluator(node, basis);
			case "env":
				return new EnvEvaluator(node)
		}
		return ZERO
	}
	static evaluate(evaluatable) {
		return evaluatable instanceof Evaluator ? evaluatable.evaluate() : evaluatable
	}
	static isConstant(evaluatable) {
		return !(evaluatable instanceof Evaluator) || evaluatable.isConstant
	}
	static applyIntrinsics(evaluated, intrinsics) {
		let {
			basis,
			keywords
		} = intrinsics, {
			auto
		} = keywords;
		return basis.map((basisNode, index) => {
			let autoSubstituteNode = null == auto[index] ? basisNode : auto[index],
				evaluatedNode = evaluated[index] ? evaluated[index] : autoSubstituteNode;
			if ("ident" === evaluatedNode.type) {
				let keyword = evaluatedNode.value;
				keyword in keywords && (evaluatedNode = keywords[keyword][index])
			}
			return ((null == evaluatedNode || "ident" === evaluatedNode.type) && (evaluatedNode = autoSubstituteNode), "%" === evaluatedNode.unit) ? numberNode(evaluatedNode.number / 100 * basisNode.number, basisNode.unit) : (evaluatedNode = normalizeUnit(evaluatedNode, basisNode)).unit !== basisNode.unit ? basisNode : evaluatedNode
		})
	}
	get isConstant() {
		return !1
	}
	evaluate() {
		return this.isConstant && null != this[$lastValue] || (this[$lastValue] = this[$evaluate]()), this[$lastValue]
	}
}
_a$6 = $lastValue;
let $percentage = Symbol("percentage"),
	$basis = Symbol("basis");
class PercentageEvaluator extends Evaluator {
	constructor(percentage, basis) {
		super(), this[$percentage] = percentage, this[$basis] = basis
	}
	get isConstant() {
		return !0
	} [$evaluate]() {
		return numberNode(this[$percentage].number / 100 * this[$basis].number, this[$basis].unit)
	}
}
let $identNode = Symbol("identNode");
class EnvEvaluator extends Evaluator {
	constructor(envFunction) {
		super(), this[_b$6] = null;
		let identNode = envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;
		null != identNode && "ident" === identNode.type && (this[$identNode] = identNode)
	}
	get isConstant() {
		return !1
	} [(_b$6 = $identNode, $evaluate)]() {
		return null != this[$identNode] && "window-scroll-y" === this[$identNode].value ? {
			type: "number",
			number: window.pageYOffset / (Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) - window.innerHeight) || 0,
			unit: null
		} : ZERO
	}
}
let IS_MULTIPLICATION_RE = /[\*\/]/,
	$evaluator = Symbol("evaluator");
class CalcEvaluator extends Evaluator {
	constructor(calcFunction, basis = ZERO) {
		if (super(), this[_c$4] = null, 1 !== calcFunction.arguments.length) return;
		let terms = calcFunction.arguments[0].terms.slice(),
			secondOrderTerms = [];
		for (; terms.length;) {
			let term = terms.shift();
			if (secondOrderTerms.length > 0) {
				let previousTerm = secondOrderTerms[secondOrderTerms.length - 1];
				if ("operator" === previousTerm.type && IS_MULTIPLICATION_RE.test(previousTerm.value)) {
					let operator = secondOrderTerms.pop(),
						leftValue = secondOrderTerms.pop();
					if (null == leftValue) return;
					secondOrderTerms.push(new OperatorEvaluator(operator, Evaluator.evaluatableFor(leftValue, basis), Evaluator.evaluatableFor(term, basis)));
					continue
				}
			}
			secondOrderTerms.push("operator" === term.type ? term : Evaluator.evaluatableFor(term, basis))
		}
		for (; secondOrderTerms.length > 2;) {
			let [left, operator, right] = secondOrderTerms.splice(0, 3);
			if ("operator" !== operator.type) return;
			secondOrderTerms.unshift(new OperatorEvaluator(operator, Evaluator.evaluatableFor(left, basis), Evaluator.evaluatableFor(right, basis)))
		}
		1 === secondOrderTerms.length && (this[$evaluator] = secondOrderTerms[0])
	}
	get isConstant() {
		return null == this[$evaluator] || Evaluator.isConstant(this[$evaluator])
	} [(_c$4 = $evaluator, $evaluate)]() {
		return null != this[$evaluator] ? Evaluator.evaluate(this[$evaluator]) : ZERO
	}
}
let $operator = Symbol("operator"),
	$left = Symbol("left"),
	$right = Symbol("right");
class OperatorEvaluator extends Evaluator {
	constructor(operator, left, right) {
		super(), this[$operator] = operator, this[$left] = left, this[$right] = right
	}
	get isConstant() {
		return Evaluator.isConstant(this[$left]) && Evaluator.isConstant(this[$right])
	} [$evaluate]() {
		let value;
		let leftNode = normalizeUnit(Evaluator.evaluate(this[$left])),
			rightNode = normalizeUnit(Evaluator.evaluate(this[$right])),
			{
				number: leftValue,
				unit: leftUnit
			} = leftNode,
			{
				number: rightValue,
				unit: rightUnit
			} = rightNode;
		if (null != rightUnit && null != leftUnit && rightUnit != leftUnit) return ZERO;
		switch (this[$operator].value) {
			case "+":
				value = leftValue + rightValue;
				break;
			case "-":
				value = leftValue - rightValue;
				break;
			case "/":
				value = leftValue / rightValue;
				break;
			case "*":
				value = leftValue * rightValue;
				break;
			default:
				return ZERO
		}
		return {
			type: "number",
			number: value,
			unit: leftUnit || rightUnit
		}
	}
}
let $evaluatables = Symbol("evaluatables"),
	$intrinsics = Symbol("intrinsics");
class StyleEvaluator extends Evaluator {
	constructor(expressions, intrinsics) {
		super(), this[$intrinsics] = intrinsics;
		let firstExpression = expressions[0],
			terms = null != firstExpression ? firstExpression.terms : [];
		this[$evaluatables] = intrinsics.basis.map((basisNode, index) => {
			let term = terms[index];
			return null == term ? {
				type: "ident",
				value: "auto"
			} : "ident" === term.type ? term : Evaluator.evaluatableFor(term, basisNode)
		})
	}
	get isConstant() {
		for (let evaluatable of this[$evaluatables])
			if (!Evaluator.isConstant(evaluatable)) return !1;
		return !0
	} [$evaluate]() {
		let evaluated = this[$evaluatables].map(evaluatable => Evaluator.evaluate(evaluatable));
		return Evaluator.applyIntrinsics(evaluated, this[$intrinsics]).map(numberNode => numberNode.number)
	}
}
let $instances = Symbol("instances"),
	$activateListener = Symbol("activateListener"),
	$deactivateListener = Symbol("deactivateListener"),
	$notifyInstances = Symbol("notifyInstances"),
	$notify = Symbol("notify"),
	$scrollCallback = Symbol("callback");
class ScrollObserver {
	constructor(callback) {
		this[$scrollCallback] = callback
	}
	static[$notifyInstances]() {
		for (let instance of ScrollObserver[$instances]) instance[$notify]()
	}
	static[(_a$5 = $instances, $activateListener)]() {
		window.addEventListener("scroll", this[$notifyInstances], {
			passive: !0
		})
	}
	static[$deactivateListener]() {
		window.removeEventListener("scroll", this[$notifyInstances])
	}
	observe() {
		0 === ScrollObserver[$instances].size && ScrollObserver[$activateListener](), ScrollObserver[$instances].add(this)
	}
	disconnect() {
		ScrollObserver[$instances].delete(this), 0 === ScrollObserver[$instances].size && ScrollObserver[$deactivateListener]()
	} [$notify]() {
		this[$scrollCallback]()
	}
}
ScrollObserver[_a$5] = new Set;
let $computeStyleCallback = Symbol("computeStyleCallback"),
	$astWalker = Symbol("astWalker"),
	$dependencies = Symbol("dependencies"),
	$onScroll = Symbol("onScroll");
class StyleEffector {
	constructor(callback) {
		this[_b$5] = {}, this[_c$3] = new ASTWalker(["function"]), this[_d$2] = () => {
			this[$computeStyleCallback]({
				relatedState: "window-scroll"
			})
		}, this[$computeStyleCallback] = callback
	}
	observeEffectsFor(ast) {
		let newDependencies = {},
			oldDependencies = this[$dependencies];
		for (let environmentState in this[$astWalker].walk(ast, functionNode => {
				let {
					name
				} = functionNode, firstTerm = functionNode.arguments[0].terms[0];
				if ("env" === name.value && null != firstTerm && "ident" === firstTerm.type && "window-scroll-y" === firstTerm.value && null == newDependencies["window-scroll"]) {
					let observer = "window-scroll" in oldDependencies ? oldDependencies["window-scroll"] : new ScrollObserver(this[$onScroll]);
					observer.observe(), delete oldDependencies["window-scroll"], newDependencies["window-scroll"] = observer
				}
			}), oldDependencies) oldDependencies[environmentState].disconnect();
		this[$dependencies] = newDependencies
	}
	dispose() {
		for (let environmentState in this[$dependencies]) this[$dependencies][environmentState].disconnect()
	}
}
_b$5 = $dependencies, _c$3 = $astWalker, _d$2 = $onScroll;
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let style = config => {
		let observeEffects = config.observeEffects || !1,
			getIntrinsics = config.intrinsics instanceof Function ? config.intrinsics : () => config.intrinsics;
		return (proto, propertyName) => {
			let originalUpdated = proto.updated,
				originalConnectedCallback = proto.connectedCallback,
				originalDisconnectedCallback = proto.disconnectedCallback,
				$styleEffector = Symbol(`${propertyName}StyleEffector`),
				$styleEvaluator = Symbol(`${propertyName}StyleEvaluator`),
				$updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`),
				$evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);
			Object.defineProperties(proto, {
				[$styleEffector]: {
					value: null,
					writable: !0
				},
				[$styleEvaluator]: {
					value: null,
					writable: !0
				},
				[$updateEvaluator]: {
					value: function() {
						let ast = parseExpressions(this[propertyName]);
						this[$styleEvaluator] = new StyleEvaluator(ast, getIntrinsics(this)), null == this[$styleEffector] && observeEffects && (this[$styleEffector] = new StyleEffector(() => this[$evaluateAndSync]())), null != this[$styleEffector] && this[$styleEffector].observeEffectsFor(ast)
					}
				},
				[$evaluateAndSync]: {
					value: function() {
						if (null == this[$styleEvaluator]) return;
						let result = this[$styleEvaluator].evaluate();
						this[config.updateHandler](result)
					}
				},
				updated: {
					value: function(changedProperties) {
						changedProperties.has(propertyName) && (this[$updateEvaluator](), this[$evaluateAndSync]()), originalUpdated.call(this, changedProperties)
					}
				},
				connectedCallback: {
					value: function() {
						originalConnectedCallback.call(this), this.requestUpdate(propertyName, this[propertyName])
					}
				},
				disconnectedCallback: {
					value: function() {
						originalDisconnectedCallback.call(this), null != this[$styleEffector] && (this[$styleEffector].dispose(), this[$styleEffector] = null)
					}
				}
			})
		}
	},
	easeInOutQuad = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
	interpolate = (start, end, ease = easeInOutQuad) => time => start + (end - start) * ease(time),
	sequence = (tracks, weights) => {
		let sum;
		let times = weights.map((sum = 0, value => sum += value));
		return time => {
			time = clamp(time, 0, 1) * times[times.length - 1];
			let i = times.findIndex(val => val >= time),
				start = i < 1 ? 0 : times[i - 1],
				end = times[i];
			return tracks[i]((time - start) / (end - start))
		}
	},
	timeline = path => {
		let tracks = [],
			weights = [],
			lastValue = path.initialValue;
		for (let i = 0; i < path.keyframes.length; ++i) {
			let keyframe = path.keyframes[i],
				{
					value,
					frames
				} = keyframe,
				track = interpolate(lastValue, value, keyframe.ease || easeInOutQuad);
			tracks.push(track), weights.push(frames), lastValue = value
		}
		return sequence(tracks, weights)
	};
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$6 = function(decorators, target, key, desc) {
	for (var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, i = decorators.length - 1; i >= 0; i--)(d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	return c > 3 && r && Object.defineProperty(target, key, r), r
};
let wiggle = timeline({
		initialValue: 0,
		keyframes: [{
			frames: 5,
			value: -1
		}, {
			frames: 1,
			value: -1
		}, {
			frames: 8,
			value: 1
		}, {
			frames: 1,
			value: 1
		}, {
			frames: 5,
			value: 0
		}, {
			frames: 18,
			value: 0
		}]
	}),
	fade = timeline({
		initialValue: 0,
		keyframes: [{
			frames: 1,
			value: 1
		}, {
			frames: 5,
			value: 1
		}, {
			frames: 1,
			value: 0
		}, {
			frames: 6,
			value: 0
		}]
	}),
	DEFAULT_CAMERA_ORBIT = "0deg 75deg 105%",
	AZIMUTHAL_QUADRANT_LABELS = ["front", "right", "back", "left"],
	POLAR_TRIENT_LABELS = ["upper-", "", "lower-"],
	InteractionPromptStrategy = {
		AUTO: "auto"
	},
	InteractionPromptStyle = {
		BASIC: "basic",
		WIGGLE: "wiggle"
	},
	fieldOfViewIntrinsics = () => ({
		basis: [degreesToRadians(numberNode(30, "deg"))],
		keywords: {
			auto: [null]
		}
	}),
	minFieldOfViewIntrinsics = () => ({
		basis: [degreesToRadians(numberNode(12, "deg"))],
		keywords: {
			auto: [null]
		}
	}),
	cameraOrbitIntrinsics = (() => {
		let defaultTerms = parseExpressions(DEFAULT_CAMERA_ORBIT)[0].terms,
			theta = normalizeUnit(defaultTerms[0]),
			phi = normalizeUnit(defaultTerms[1]);
		return element => ({
			basis: [theta, phi, numberNode(element[$scene].idealCameraDistance(), "m")],
			keywords: {
				auto: [null, null, numberNode(105, "%")]
			}
		})
	})(),
	minCameraOrbitIntrinsics = element => {
		let radius = 2.2 * element[$scene].boundingSphere.radius;
		return {
			basis: [numberNode(-1 / 0, "rad"), numberNode(Math.PI / 8, "rad"), numberNode(radius, "m")],
			keywords: {
				auto: [null, null, null]
			}
		}
	},
	maxCameraOrbitIntrinsics = element => {
		let defaultRadius = new StyleEvaluator([], cameraOrbitIntrinsics(element)).evaluate()[2];
		return {
			basis: [numberNode(1 / 0, "rad"), numberNode(Math.PI - Math.PI / 8, "rad"), numberNode(defaultRadius, "m")],
			keywords: {
				auto: [null, null, null]
			}
		}
	},
	cameraTargetIntrinsics = element => {
		let center = element[$scene].boundingBox.getCenter(new Vector3);
		return {
			basis: [numberNode(center.x, "m"), numberNode(center.y, "m"), numberNode(center.z, "m")],
			keywords: {
				auto: [null, null, null]
			}
		}
	},
	HALF_PI = Math.PI / 2,
	THIRD_PI = Math.PI / 3,
	QUARTER_PI = HALF_PI / 2,
	TAU = 2 * Math.PI,
	$controls = Symbol("controls"),
	$panElement = Symbol("panElement"),
	$promptElement = Symbol("promptElement"),
	$promptAnimatedContainer = Symbol("promptAnimatedContainer"),
	$fingerAnimatedContainers = Symbol("fingerAnimatedContainers"),
	$deferInteractionPrompt = Symbol("deferInteractionPrompt"),
	$updateAria = Symbol("updateAria"),
	$updateCameraForRadius = Symbol("updateCameraForRadius"),
	$cancelPrompts = Symbol("cancelPrompts"),
	$onChange = Symbol("onChange"),
	$onPointerChange = Symbol("onPointerChange"),
	$waitingToPromptUser = Symbol("waitingToPromptUser"),
	$userHasInteracted = Symbol("userHasInteracted"),
	$promptElementVisibleTime = Symbol("promptElementVisibleTime"),
	$lastPromptOffset = Symbol("lastPromptOffset"),
	$cancellationSource = Symbol("cancellationSource"),
	$lastSpherical = Symbol("lastSpherical"),
	$jumpCamera = Symbol("jumpCamera"),
	$initialized = Symbol("initialized"),
	$maintainThetaPhi = Symbol("maintainThetaPhi"),
	$syncCameraOrbit = Symbol("syncCameraOrbit"),
	$syncFieldOfView = Symbol("syncFieldOfView"),
	$syncCameraTarget = Symbol("syncCameraTarget"),
	$syncMinCameraOrbit = Symbol("syncMinCameraOrbit"),
	$syncMaxCameraOrbit = Symbol("syncMaxCameraOrbit"),
	$syncMinFieldOfView = Symbol("syncMinFieldOfView"),
	$syncMaxFieldOfView = Symbol("syncMaxFieldOfView"),
	vector2 = new Vector2,
	vector3$2 = new Vector3,
	DEFAULT_OPTIONS = Object.freeze({
		minimumRadius: 0,
		maximumRadius: 1 / 0,
		minimumPolarAngle: Math.PI / 8,
		maximumPolarAngle: Math.PI - Math.PI / 8,
		minimumAzimuthalAngle: -1 / 0,
		maximumAzimuthalAngle: 1 / 0,
		minimumFieldOfView: 10,
		maximumFieldOfView: 45,
		touchAction: "none"
	}),
	KEYBOARD_ORBIT_INCREMENT = Math.PI / 8,
	ChangeSource = {
		USER_INTERACTION: "user-interaction",
		NONE: "none",
		AUTOMATIC: "automatic"
	};
class SmoothControls extends EventDispatcher {
	constructor(camera, element, scene) {
		super(), this.camera = camera, this.element = element, this.scene = scene, this.orbitSensitivity = 1, this.zoomSensitivity = 1, this.panSensitivity = 1, this.inputSensitivity = 1, this.changeSource = ChangeSource.NONE, this._interactionEnabled = !1, this._disableZoom = !1, this.isUserPointing = !1, this.enablePan = !0, this.enableTap = !0, this.panProjection = new Matrix3, this.panPerPixel = 0, this.spherical = new Spherical, this.goalSpherical = new Spherical, this.thetaDamper = new Damper, this.phiDamper = new Damper, this.radiusDamper = new Damper, this.logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView), this.goalLogFov = this.logFov, this.fovDamper = new Damper, this.touchMode = null, this.pointers = [], this.startTime = 0, this.startPointerPosition = {
			clientX: 0,
			clientY: 0
		}, this.lastSeparation = 0, this.touchDecided = !1, this.onContext = event => {
			if (this.enablePan) event.preventDefault();
			else
				for (let pointer of this.pointers) this.onPointerUp(new PointerEvent("pointercancel", Object.assign(Object.assign({}, this.startPointerPosition), {
					pointerId: pointer.id
				})))
		}, this.touchModeZoom = (dx, dy) => {
			if (!this._disableZoom) {
				let touchDistance = this.twoTouchDistance(this.pointers[0], this.pointers[1]),
					deltaZoom = .04 * this.zoomSensitivity * (this.lastSeparation - touchDistance) * 50 / this.scene.height;
				this.lastSeparation = touchDistance, this.userAdjustOrbit(0, 0, deltaZoom)
			}
			this.panPerPixel > 0 && this.movePan(dx, dy)
		}, this.disableScroll = event => {
			event.preventDefault()
		}, this.touchModeRotate = (dx, dy) => {
			let {
				touchAction
			} = this._options;
			if (!this.touchDecided && "none" !== touchAction) {
				this.touchDecided = !0;
				let dxMag = Math.abs(dx),
					dyMag = Math.abs(dy);
				if (this.changeSource === ChangeSource.USER_INTERACTION && ("pan-y" === touchAction && dyMag > dxMag || "pan-x" === touchAction && dxMag > dyMag)) {
					this.touchMode = null;
					return
				}
				this.element.addEventListener("touchmove", this.disableScroll, {
					passive: !1
				})
			}
			this.handleSinglePointerMove(dx, dy)
		}, this.onPointerDown = event => {
			if (this.pointers.length > 2) return;
			let {
				element
			} = this;
			0 === this.pointers.length && (element.addEventListener("pointermove", this.onPointerMove), element.addEventListener("pointerup", this.onPointerUp), this.touchMode = null, this.touchDecided = !1, this.startPointerPosition.clientX = event.clientX, this.startPointerPosition.clientY = event.clientY, this.startTime = performance.now());
			try {
				element.setPointerCapture(event.pointerId)
			} catch (_a) {}
			this.pointers.push({
				clientX: event.clientX,
				clientY: event.clientY,
				id: event.pointerId
			}), this.isUserPointing = !1, "touch" === event.pointerType ? (this.changeSource = event.altKey ? ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION, this.onTouchChange(event)) : (this.changeSource = ChangeSource.USER_INTERACTION, this.onMouseDown(event)), this.changeSource === ChangeSource.USER_INTERACTION && this.dispatchEvent({
				type: "user-interaction"
			})
		}, this.onPointerMove = event => {
			let pointer = this.pointers.find(pointer => pointer.id === event.pointerId);
			if (null == pointer) return;
			if ("mouse" === event.pointerType && 0 === event.buttons) {
				this.onPointerUp(event);
				return
			}
			let numTouches = this.pointers.length,
				dx = (event.clientX - pointer.clientX) / numTouches,
				dy = (event.clientY - pointer.clientY) / numTouches;
			(0 !== dx || 0 !== dy) && (pointer.clientX = event.clientX, pointer.clientY = event.clientY, "touch" === event.pointerType ? (this.changeSource = event.altKey ? ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION, null !== this.touchMode && this.touchMode(dx, dy)) : (this.changeSource = ChangeSource.USER_INTERACTION, this.panPerPixel > 0 ? this.movePan(dx, dy) : this.handleSinglePointerMove(dx, dy)))
		}, this.onPointerUp = event => {
			let {
				element
			} = this, index = this.pointers.findIndex(pointer => pointer.id === event.pointerId); - 1 !== index && this.pointers.splice(index, 1), this.panPerPixel > 0 && !event.altKey && this.resetRadius(), 0 === this.pointers.length ? (element.removeEventListener("pointermove", this.onPointerMove), element.removeEventListener("pointerup", this.onPointerUp), element.removeEventListener("touchmove", this.disableScroll), this.enablePan && this.enableTap && this.recenter(event)) : null !== this.touchMode && this.onTouchChange(event), this.scene.element[$panElement].style.opacity = 0, element.style.cursor = "grab", this.panPerPixel = 0, this.isUserPointing && this.dispatchEvent({
				type: "pointer-change-end"
			})
		}, this.onWheel = event => {
			this.changeSource = ChangeSource.USER_INTERACTION;
			let deltaZoom = event.deltaY * (1 == event.deltaMode ? 18 : 1) * .04 * this.zoomSensitivity / 30;
			this.userAdjustOrbit(0, 0, deltaZoom), event.preventDefault(), this.dispatchEvent({
				type: "user-interaction"
			})
		}, this.onKeyDown = event => {
			let {
				changeSource
			} = this;
			this.changeSource = ChangeSource.USER_INTERACTION, (event.shiftKey && this.enablePan ? this.panKeyCodeHandler(event) : this.orbitZoomKeyCodeHandler(event)) ? (event.preventDefault(), this.dispatchEvent({
				type: "user-interaction"
			})) : this.changeSource = changeSource
		}, this._options = Object.assign({}, DEFAULT_OPTIONS), this.setOrbit(0, Math.PI / 2, 1), this.setFieldOfView(100), this.jumpToGoal()
	}
	get interactionEnabled() {
		return this._interactionEnabled
	}
	enableInteraction() {
		if (!1 === this._interactionEnabled) {
			let {
				element
			} = this;
			element.addEventListener("pointerdown", this.onPointerDown), element.addEventListener("pointercancel", this.onPointerUp), this._disableZoom || element.addEventListener("wheel", this.onWheel), element.addEventListener("keydown", this.onKeyDown), element.addEventListener("touchmove", () => {}, {
				passive: !1
			}), element.addEventListener("contextmenu", this.onContext), this.element.style.cursor = "grab", this._interactionEnabled = !0, this.updateTouchActionStyle()
		}
	}
	disableInteraction() {
		if (!0 === this._interactionEnabled) {
			let {
				element
			} = this;
			element.removeEventListener("pointerdown", this.onPointerDown), element.removeEventListener("pointermove", this.onPointerMove), element.removeEventListener("pointerup", this.onPointerUp), element.removeEventListener("pointercancel", this.onPointerUp), element.removeEventListener("wheel", this.onWheel), element.removeEventListener("keydown", this.onKeyDown), element.removeEventListener("contextmenu", this.onContext), element.style.cursor = "", this.touchMode = null, this._interactionEnabled = !1, this.updateTouchActionStyle()
		}
	}
	get options() {
		return this._options
	}
	set disableZoom(disable) {
		this._disableZoom != disable && (this._disableZoom = disable, !0 === disable ? this.element.removeEventListener("wheel", this.onWheel) : this.element.addEventListener("wheel", this.onWheel), this.updateTouchActionStyle())
	}
	getCameraSpherical(target = new Spherical) {
		return target.copy(this.spherical)
	}
	getFieldOfView() {
		return this.camera.fov
	}
	applyOptions(_options) {
		Object.assign(this._options, _options), this.setOrbit(), this.setFieldOfView(Math.exp(this.goalLogFov))
	}
	updateNearFar(nearPlane, farPlane) {
		this.camera.far = 0 === farPlane ? 2 : farPlane, this.camera.near = Math.max(nearPlane, this.camera.far / 1e3), this.camera.updateProjectionMatrix()
	}
	updateAspect(aspect) {
		this.camera.aspect = aspect, this.camera.updateProjectionMatrix()
	}
	setOrbit(goalTheta = this.goalSpherical.theta, goalPhi = this.goalSpherical.phi, goalRadius = this.goalSpherical.radius) {
		let {
			minimumAzimuthalAngle,
			maximumAzimuthalAngle,
			minimumPolarAngle,
			maximumPolarAngle,
			minimumRadius,
			maximumRadius
		} = this._options, {
			theta,
			phi,
			radius
		} = this.goalSpherical, nextTheta = clamp(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);
		isFinite(minimumAzimuthalAngle) || isFinite(maximumAzimuthalAngle) || (this.spherical.theta = this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta);
		let nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle),
			nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);
		return !!((nextTheta !== theta || nextPhi !== phi || nextRadius !== radius) && isFinite(nextTheta) && isFinite(nextPhi) && isFinite(nextRadius)) && (this.goalSpherical.theta = nextTheta, this.goalSpherical.phi = nextPhi, this.goalSpherical.radius = nextRadius, this.goalSpherical.makeSafe(), !0)
	}
	setRadius(radius) {
		this.goalSpherical.radius = radius, this.setOrbit()
	}
	setFieldOfView(fov) {
		let {
			minimumFieldOfView,
			maximumFieldOfView
		} = this._options;
		fov = clamp(fov, minimumFieldOfView, maximumFieldOfView), this.goalLogFov = Math.log(fov)
	}
	setDamperDecayTime(decayMilliseconds) {
		this.thetaDamper.setDecayTime(decayMilliseconds), this.phiDamper.setDecayTime(decayMilliseconds), this.radiusDamper.setDecayTime(decayMilliseconds), this.fovDamper.setDecayTime(decayMilliseconds)
	}
	adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {
		let {
			theta,
			phi,
			radius
		} = this.goalSpherical, {
			minimumRadius,
			maximumRadius,
			minimumFieldOfView,
			maximumFieldOfView
		} = this._options, dTheta = this.spherical.theta - theta, dThetaLimit = Math.PI - .001, goalTheta = theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta), deltaRatio = 0 === deltaZoom ? 0 : ((deltaZoom > 0 ? maximumRadius : minimumRadius) - radius) / (Math.log(deltaZoom > 0 ? maximumFieldOfView : minimumFieldOfView) - this.goalLogFov), goalRadius = radius + deltaZoom * (isFinite(deltaRatio) ? deltaRatio : (maximumRadius - minimumRadius) * 2);
		if (this.setOrbit(goalTheta, phi - deltaPhi, goalRadius), 0 !== deltaZoom) {
			let goalLogFov = this.goalLogFov + deltaZoom;
			this.setFieldOfView(Math.exp(goalLogFov))
		}
	}
	jumpToGoal() {
		this.update(0, 1e4)
	}
	update(_time, delta) {
		if (this.isStationary()) return !1;
		let {
			maximumPolarAngle,
			maximumRadius
		} = this._options, dTheta = this.spherical.theta - this.goalSpherical.theta;
		return !(Math.abs(dTheta) > Math.PI) || isFinite(this._options.minimumAzimuthalAngle) || isFinite(this._options.maximumAzimuthalAngle) || (this.spherical.theta -= 2 * Math.sign(dTheta) * Math.PI), this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, delta, Math.PI), this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, delta, maximumPolarAngle), this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, delta, maximumRadius), this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1), this.moveCamera(), !0
	}
	updateTouchActionStyle() {
		let {
			style
		} = this.element;
		if (this._interactionEnabled) {
			let {
				touchAction
			} = this._options;
			this._disableZoom && "none" !== touchAction ? style.touchAction = "manipulation" : style.touchAction = touchAction
		} else style.touchAction = ""
	}
	isStationary() {
		return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov
	}
	moveCamera() {
		this.spherical.makeSafe(), this.camera.position.setFromSpherical(this.spherical), this.camera.setRotationFromEuler(new Euler(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, "YXZ")), this.camera.fov !== Math.exp(this.logFov) && (this.camera.fov = Math.exp(this.logFov), this.camera.updateProjectionMatrix())
	}
	userAdjustOrbit(deltaTheta, deltaPhi, deltaZoom) {
		this.adjustOrbit(deltaTheta * this.orbitSensitivity * this.inputSensitivity, deltaPhi * this.orbitSensitivity * this.inputSensitivity, deltaZoom * this.inputSensitivity)
	}
	wrapAngle(radians) {
		let normalized = (radians + Math.PI) / (2 * Math.PI);
		return 2 * (normalized - Math.floor(normalized)) * Math.PI - Math.PI
	}
	pixelLengthToSphericalAngle(pixelLength) {
		return 2 * Math.PI * pixelLength / this.scene.height
	}
	twoTouchDistance(touchOne, touchTwo) {
		let {
			clientX: xOne,
			clientY: yOne
		} = touchOne, {
			clientX: xTwo,
			clientY: yTwo
		} = touchTwo, xDelta = xTwo - xOne, yDelta = yTwo - yOne;
		return Math.sqrt(xDelta * xDelta + yDelta * yDelta)
	}
	handleSinglePointerMove(dx, dy) {
		let deltaTheta = this.pixelLengthToSphericalAngle(dx),
			deltaPhi = this.pixelLengthToSphericalAngle(dy);
		!1 === this.isUserPointing && (this.isUserPointing = !0, this.dispatchEvent({
			type: "pointer-change-start"
		})), this.userAdjustOrbit(deltaTheta, deltaPhi, 0)
	}
	initializePan() {
		let {
			theta,
			phi
		} = this.spherical, psi = theta - this.scene.yaw;
		this.panPerPixel = .018 * this.panSensitivity / this.scene.height, this.panProjection.set(-Math.cos(psi), -Math.cos(phi) * Math.sin(psi), 0, 0, Math.sin(phi), 0, Math.sin(psi), -Math.cos(phi) * Math.cos(psi), 0)
	}
	movePan(dx, dy) {
		let {
			scene
		} = this, dxy = vector3$2.set(dx, dy, 0).multiplyScalar(this.inputSensitivity), metersPerPixel = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;
		dxy.multiplyScalar(metersPerPixel);
		let target = scene.getTarget();
		target.add(dxy.applyMatrix3(this.panProjection)), scene.boundingSphere.clampPoint(target, target), scene.setTarget(target.x, target.y, target.z)
	}
	recenter(pointer) {
		if (performance.now() > this.startTime + 300 || Math.abs(pointer.clientX - this.startPointerPosition.clientX) > 2 || Math.abs(pointer.clientY - this.startPointerPosition.clientY) > 2) return;
		let {
			scene
		} = this, hit = scene.positionAndNormalFromPoint(scene.getNDC(pointer.clientX, pointer.clientY));
		if (null == hit) {
			let {
				cameraTarget
			} = scene.element;
			scene.element.cameraTarget = "", scene.element.cameraTarget = cameraTarget, this.userAdjustOrbit(0, 0, 1)
		} else scene.target.worldToLocal(hit.position), scene.setTarget(hit.position.x, hit.position.y, hit.position.z)
	}
	resetRadius() {
		let {
			scene
		} = this, hit = scene.positionAndNormalFromPoint(vector2.set(0, 0));
		if (null == hit) return;
		scene.target.worldToLocal(hit.position);
		let goalTarget = scene.getTarget(),
			{
				theta,
				phi
			} = this.spherical,
			psi = theta - scene.yaw,
			n = vector3$2.set(Math.sin(phi) * Math.sin(psi), Math.cos(phi), Math.sin(phi) * Math.cos(psi)),
			dr = n.dot(hit.position.sub(goalTarget));
		goalTarget.add(n.multiplyScalar(dr)), scene.setTarget(goalTarget.x, goalTarget.y, goalTarget.z), this.setOrbit(void 0, void 0, this.goalSpherical.radius - dr)
	}
	onTouchChange(event) {
		if (1 === this.pointers.length) this.touchMode = this.touchModeRotate;
		else {
			if (this._disableZoom) {
				this.touchMode = null, this.element.removeEventListener("touchmove", this.disableScroll);
				return
			}
			this.touchMode = this.touchDecided && null === this.touchMode ? null : this.touchModeZoom, this.touchDecided = !0, this.element.addEventListener("touchmove", this.disableScroll, {
				passive: !1
			}), this.lastSeparation = this.twoTouchDistance(this.pointers[0], this.pointers[1]), this.enablePan && null != this.touchMode && (this.initializePan(), event.altKey || (this.scene.element[$panElement].style.opacity = 1))
		}
	}
	onMouseDown(event) {
		this.panPerPixel = 0, this.enablePan && (2 === event.button || event.ctrlKey || event.metaKey || event.shiftKey) && (this.initializePan(), this.scene.element[$panElement].style.opacity = 1), this.element.style.cursor = "grabbing"
	}
	orbitZoomKeyCodeHandler(event) {
		let relevantKey = !0;
		switch (event.key) {
			case "PageUp":
				this.userAdjustOrbit(0, 0, .04 * this.zoomSensitivity);
				break;
			case "PageDown":
				this.userAdjustOrbit(0, 0, -.04 * this.zoomSensitivity);
				break;
			case "ArrowUp":
				this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);
				break;
			case "ArrowDown":
				this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);
				break;
			case "ArrowLeft":
				this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);
				break;
			case "ArrowRight":
				this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);
				break;
			default:
				relevantKey = !1
		}
		return relevantKey
	}
	panKeyCodeHandler(event) {
		this.initializePan();
		let relevantKey = !0;
		switch (event.key) {
			case "ArrowUp":
				this.movePan(0, -10);
				break;
			case "ArrowDown":
				this.movePan(0, 10);
				break;
			case "ArrowLeft":
				this.movePan(-10, 0);
				break;
			case "ArrowRight":
				this.movePan(10, 0);
				break;
			default:
				relevantKey = !1
		}
		return relevantKey
	}
}
let ARStatus = {
		NOT_PRESENTING: "not-presenting",
		SESSION_STARTED: "session-started",
		OBJECT_PLACED: "object-placed",
		FAILED: "failed"
	},
	ARTracking = {
		TRACKING: "tracking",
		NOT_TRACKING: "not-tracking"
	},
	vector3$1 = new Vector3,
	matrix4 = new Matrix4,
	hitPosition = new Vector3,
	camera = new PerspectiveCamera(45, 1, .1, 100);
class ARRenderer extends EventDispatcher {
	constructor(renderer) {
		super(), this.renderer = renderer, this.currentSession = null, this.placeOnWall = !1, this.placementBox = null, this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.frame = null, this.initialHitSource = null, this.transientHitTestSource = null, this.inputSource = null, this._presentedScene = null, this.resolveCleanup = null, this.exitWebXRButtonContainer = null, this.overlay = null, this.xrLight = null, this.tracking = !0, this.frames = 0, this.initialized = !1, this.oldTarget = new Vector3, this.placementComplete = !1, this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.lastDragPosition = new Vector3, this.firstRatio = 0, this.lastAngle = 0, this.goalPosition = new Vector3, this.goalYaw = 0, this.goalScale = 1, this.xDamper = new Damper, this.yDamper = new Damper, this.zDamper = new Damper, this.yawDamper = new Damper, this.scaleDamper = new Damper, this.onExitWebXRButtonContainerClick = () => this.stopPresenting(), this.onUpdateScene = () => {
			null != this.placementBox && this.isPresenting && (this.placementBox.dispose(), this.placementBox = new PlacementBox(this.presentedScene, this.placeOnWall ? "back" : "bottom"))
		}, this.onSelectStart = event => {
			let hitSource = this.transientHitTestSource;
			if (null == hitSource) return;
			let fingers = this.frame.getHitTestResultsForTransientInput(hitSource),
				scene = this.presentedScene,
				box = this.placementBox;
			if (1 === fingers.length) {
				this.inputSource = event.inputSource;
				let {
					axes
				} = this.inputSource.gamepad, hitPosition = box.getHit(this.presentedScene, axes[0], axes[1]);
				box.show = !0, null != hitPosition ? (this.isTranslating = !0, this.lastDragPosition.copy(hitPosition)) : !1 === this.placeOnWall && (this.isRotating = !0, this.lastAngle = 1.5 * axes[0])
			} else if (2 === fingers.length) {
				box.show = !0, this.isTwoFingering = !0;
				let {
					separation
				} = this.fingerPolar(fingers);
				this.firstRatio = separation / scene.scale.x
			}
		}, this.onSelectEnd = () => {
			this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !1, this.inputSource = null, this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x, this.placementBox.show = !1
		}, this.threeRenderer = renderer.threeRenderer, this.threeRenderer.xr.enabled = !0
	}
	async resolveARSession() {
		assertIsArCandidate();
		let session = await navigator.xr.requestSession("immersive-ar", {
			requiredFeatures: ["hit-test"],
			optionalFeatures: ["dom-overlay", "light-estimation"],
			domOverlay: this.overlay ? {
				root: this.overlay
			} : void 0
		});
		return this.threeRenderer.xr.setReferenceSpaceType("local"), await this.threeRenderer.xr.setSession(session), this.threeRenderer.xr.cameraAutoUpdate = !1, session
	}
	get presentedScene() {
		return this._presentedScene
	}
	async supportsPresentation() {
		try {
			return assertIsArCandidate(), await navigator.xr.isSessionSupported("immersive-ar")
		} catch (error) {
			return console.warn("Request to present in WebXR denied:"), console.warn(error), console.warn("Falling back to next ar-mode"), !1
		}
	}
	async present(scene, environmentEstimation = !1) {
		this.isPresenting && console.warn("Cannot present while a model is already presenting");
		let waitForAnimationFrame = new Promise((resolve, _reject) => {
			requestAnimationFrame(() => resolve())
		});
		scene.setHotspotsVisibility(!1), scene.queueRender(), await waitForAnimationFrame, this._presentedScene = scene, this.overlay = scene.element.shadowRoot.querySelector("div.default"), !0 === environmentEstimation && (this.xrLight = new XREstimatedLight(this.threeRenderer), this.xrLight.addEventListener("estimationstart", () => {
			if (!this.isPresenting || null == this.xrLight) return;
			let scene = this.presentedScene;
			scene.add(this.xrLight), scene.environment = this.xrLight.environment
		}));
		let currentSession = await this.resolveARSession();
		currentSession.addEventListener("end", () => {
			this.postSessionCleanup()
		}, {
			once: !0
		});
		let exitButton = scene.element.shadowRoot.querySelector(".slot.exit-webxr-ar-button");
		exitButton.classList.add("enabled"), exitButton.addEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = exitButton;
		let viewerRefSpace = await currentSession.requestReferenceSpace("viewer");
		this.tracking = !0, this.frames = 0, this.initialized = !1, this.turntableRotation = scene.yaw, this.goalYaw = scene.yaw, this.goalScale = 1, scene.setBackground(null), this.oldShadowIntensity = scene.shadowIntensity, scene.setShadowIntensity(.01), this.oldTarget.copy(scene.getTarget()), scene.element.addEventListener("load", this.onUpdateScene);
		let radians = 20 * Math.PI / 180,
			ray = !0 === this.placeOnWall ? void 0 : new XRRay(new DOMPoint(0, 0, 0), {
				x: 0,
				y: -Math.sin(radians),
				z: -Math.cos(radians)
			});
		currentSession.requestHitTestSource({
			space: viewerRefSpace,
			offsetRay: ray
		}).then(hitTestSource => {
			this.initialHitSource = hitTestSource
		}), this.currentSession = currentSession, this.placementBox = new PlacementBox(scene, this.placeOnWall ? "back" : "bottom"), this.placementComplete = !1, this.lastTick = performance.now(), this.dispatchEvent({
			type: "status",
			status: ARStatus.SESSION_STARTED
		})
	}
	async stopPresenting() {
		if (!this.isPresenting) return;
		let cleanupPromise = new Promise(resolve => {
			this.resolveCleanup = resolve
		});
		try {
			await this.currentSession.end(), await cleanupPromise
		} catch (error) {
			console.warn("Error while trying to end WebXR AR session"), console.warn(error), this.postSessionCleanup()
		}
	}
	get isPresenting() {
		return null != this.presentedScene
	}
	get target() {
		return this.oldTarget
	}
	updateTarget() {
		let scene = this.presentedScene;
		if (null != scene) {
			let target = scene.getTarget();
			this.oldTarget.copy(target), this.placeOnWall ? target.z = scene.boundingBox.min.z : target.y = scene.boundingBox.min.y, scene.setTarget(target.x, target.y, target.z)
		}
	}
	postSessionCleanup() {
		let session = this.currentSession;
		null != session && (session.removeEventListener("selectstart", this.onSelectStart), session.removeEventListener("selectend", this.onSelectEnd), this.currentSession = null);
		let scene = this.presentedScene;
		if (this._presentedScene = null, null != scene) {
			let {
				element
			} = scene;
			null != this.xrLight && (scene.remove(this.xrLight), this.xrLight.dispose(), this.xrLight = null), scene.position.set(0, 0, 0), scene.scale.set(1, 1, 1), scene.setShadowOffset(0);
			let yaw = this.turntableRotation;
			null != yaw && (scene.yaw = yaw);
			let intensity = this.oldShadowIntensity;
			null != intensity && scene.setShadowIntensity(intensity), scene.setEnvironmentAndSkybox(element[$currentEnvironmentMap], element[$currentBackground]);
			let point = this.oldTarget;
			scene.setTarget(point.x, point.y, point.z), scene.xrCamera = null, scene.element.removeEventListener("load", this.onUpdateScene), scene.orientHotspots(0), element.requestUpdate("cameraTarget"), element.requestUpdate("maxCameraOrbit"), element[$onResize](element.getBoundingClientRect()), requestAnimationFrame(() => {
				scene.element.dispatchEvent(new CustomEvent("camera-change", {
					detail: {
						source: ChangeSource.NONE
					}
				}))
			})
		}
		this.renderer.height = 0;
		let exitButton = this.exitWebXRButtonContainer;
		null != exitButton && (exitButton.classList.remove("enabled"), exitButton.removeEventListener("click", this.onExitWebXRButtonContainerClick), this.exitWebXRButtonContainer = null);
		let hitSource = this.transientHitTestSource;
		null != hitSource && (hitSource.cancel(), this.transientHitTestSource = null);
		let hitSourceInitial = this.initialHitSource;
		null != hitSourceInitial && (hitSourceInitial.cancel(), this.initialHitSource = null), null != this.placementBox && (this.placementBox.dispose(), this.placementBox = null), this.lastTick = null, this.turntableRotation = null, this.oldShadowIntensity = null, this.frame = null, this.inputSource = null, this.overlay = null, null != this.resolveCleanup && this.resolveCleanup(), this.dispatchEvent({
			type: "status",
			status: ARStatus.NOT_PRESENTING
		})
	}
	updateView(view) {
		let scene = this.presentedScene,
			xr = this.threeRenderer.xr;
		xr.updateCamera(camera), scene.xrCamera = xr.getCamera();
		let {
			elements
		} = scene.getCamera().matrixWorld;
		if (scene.orientHotspots(Math.atan2(elements[1], elements[5])), this.initialized || (this.placeInitially(), this.initialized = !0), view.requestViewportScale && view.recommendedViewportScale) {
			let scale = view.recommendedViewportScale;
			view.requestViewportScale(Math.max(scale, .25))
		}
		let layer = xr.getBaseLayer();
		if (null != layer) {
			let viewport = layer instanceof XRWebGLLayer ? layer.getViewport(view) : xr.getBinding().getViewSubImage(layer, view).viewport;
			this.threeRenderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height)
		}
	}
	placeInitially() {
		let scene = this.presentedScene,
			{
				position,
				element
			} = scene,
			xrCamera = scene.getCamera(),
			{
				width,
				height
			} = this.overlay.getBoundingClientRect();
		scene.setSize(width, height), xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();
		let {
			theta,
			radius
		} = element.getCameraOrbit(), cameraDirection = xrCamera.getWorldDirection(vector3$1);
		scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta, this.goalYaw = scene.yaw, position.copy(xrCamera.position).add(cameraDirection.multiplyScalar(radius)), this.updateTarget();
		let target = scene.getTarget();
		position.add(target).sub(this.oldTarget), this.goalPosition.copy(position), scene.setHotspotsVisibility(!0);
		let {
			session
		} = this.frame;
		session.addEventListener("selectstart", this.onSelectStart), session.addEventListener("selectend", this.onSelectEnd), session.requestHitTestSourceForTransientInput({
			profile: "generic-touchscreen"
		}).then(hitTestSource => {
			this.transientHitTestSource = hitTestSource
		})
	}
	getTouchLocation() {
		let {
			axes
		} = this.inputSource.gamepad, location = this.placementBox.getExpandedHit(this.presentedScene, axes[0], axes[1]);
		return null != location && (vector3$1.copy(location).sub(this.presentedScene.getCamera().position), vector3$1.length() > 10) ? null : location
	}
	getHitPoint(hitResult) {
		let refSpace = this.threeRenderer.xr.getReferenceSpace(),
			pose = hitResult.getPose(refSpace);
		if (null == pose) return null;
		let hitMatrix = matrix4.fromArray(pose.transform.matrix);
		return !0 === this.placeOnWall && (this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6])), hitMatrix.elements[5] > .75 !== this.placeOnWall ? hitPosition.setFromMatrixPosition(hitMatrix) : null
	}
	moveToFloor(frame) {
		let hitSource = this.initialHitSource;
		if (null == hitSource) return;
		let hitTestResults = frame.getHitTestResults(hitSource);
		if (0 == hitTestResults.length) return;
		let hit = hitTestResults[0],
			hitPoint = this.getHitPoint(hit);
		null != hitPoint && (this.placementBox.show = !0, this.isTranslating || (this.placeOnWall ? this.goalPosition.copy(hitPoint) : this.goalPosition.y = hitPoint.y), hitSource.cancel(), this.initialHitSource = null, this.dispatchEvent({
			type: "status",
			status: ARStatus.OBJECT_PLACED
		}))
	}
	fingerPolar(fingers) {
		let fingerOne = fingers[0].inputSource.gamepad.axes,
			fingerTwo = fingers[1].inputSource.gamepad.axes,
			deltaX = fingerTwo[0] - fingerOne[0],
			deltaY = fingerTwo[1] - fingerOne[1],
			angle = Math.atan2(deltaY, deltaX),
			deltaYaw = this.lastAngle - angle;
		return deltaYaw > Math.PI ? deltaYaw -= 2 * Math.PI : deltaYaw < -Math.PI && (deltaYaw += 2 * Math.PI), this.lastAngle = angle, {
			separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),
			deltaYaw: deltaYaw
		}
	}
	processInput(frame) {
		let hitSource = this.transientHitTestSource;
		if (null == hitSource || !this.isTranslating && !this.isTwoFingering && !this.isRotating) return;
		let fingers = frame.getHitTestResultsForTransientInput(hitSource),
			scene = this.presentedScene,
			scale = scene.scale.x;
		if (this.isTwoFingering) {
			if (fingers.length < 2) this.isTwoFingering = !1;
			else {
				let {
					separation,
					deltaYaw
				} = this.fingerPolar(fingers);
				if (!1 === this.placeOnWall && (this.goalYaw += deltaYaw), scene.canScale) {
					let scale = separation / this.firstRatio;
					this.goalScale = scale < 1.3 && scale > .7692307692307692 ? 1 : scale
				}
			}
			return
		}
		if (2 === fingers.length) {
			this.isTranslating = !1, this.isRotating = !1, this.isTwoFingering = !0;
			let {
				separation
			} = this.fingerPolar(fingers);
			this.firstRatio = separation / scale;
			return
		}
		if (this.isRotating) {
			let angle = 1.5 * this.inputSource.gamepad.axes[0];
			this.goalYaw += angle - this.lastAngle, this.lastAngle = angle
		} else this.isTranslating && fingers.forEach(finger => {
			if (finger.inputSource !== this.inputSource) return;
			let hit = null;
			if (finger.results.length > 0 && (hit = this.getHitPoint(finger.results[0])), null == hit && (hit = this.getTouchLocation()), null != hit) {
				if (this.goalPosition.sub(this.lastDragPosition), !1 === this.placeOnWall) {
					let offset = hit.y - this.lastDragPosition.y;
					if (offset < 0) {
						this.placementBox.offsetHeight = offset / scale, this.presentedScene.setShadowOffset(offset);
						let cameraPosition = vector3$1.copy(scene.getCamera().position),
							alpha = -offset / (cameraPosition.y - hit.y);
						cameraPosition.multiplyScalar(alpha), hit.multiplyScalar(1 - alpha).add(cameraPosition)
					}
				}
				this.goalPosition.add(hit), this.lastDragPosition.copy(hit)
			}
		})
	}
	moveScene(delta) {
		let scene = this.presentedScene,
			{
				position,
				yaw
			} = scene,
			boundingRadius = scene.boundingSphere.radius,
			goal = this.goalPosition,
			oldScale = scene.scale.x,
			box = this.placementBox,
			source = ChangeSource.NONE;
		if (!goal.equals(position) || this.goalScale !== oldScale) {
			source = ChangeSource.USER_INTERACTION;
			let {
				x,
				y,
				z
			} = position;
			x = this.xDamper.update(x, goal.x, delta, boundingRadius), y = this.yDamper.update(y, goal.y, delta, boundingRadius), z = this.zDamper.update(z, goal.z, delta, boundingRadius), position.set(x, y, z);
			let newScale = this.scaleDamper.update(oldScale, this.goalScale, delta, 1);
			if (scene.scale.set(newScale, newScale, newScale), !this.isTranslating) {
				let offset = goal.y - y;
				this.placementComplete && !1 === this.placeOnWall ? (box.offsetHeight = offset / newScale, scene.setShadowOffset(offset)) : 0 === offset && (this.placementComplete = !0, box.show = !1, scene.setShadowIntensity(.8))
			}
		}
		box.updateOpacity(delta), scene.updateTarget(delta), scene.yaw = this.yawDamper.update(yaw, this.goalYaw, delta, Math.PI), scene.element.dispatchEvent(new CustomEvent("camera-change", {
			detail: {
				source
			}
		}))
	}
	onWebXRFrame(time, frame) {
		this.frame = frame, ++this.frames;
		let refSpace = this.threeRenderer.xr.getReferenceSpace(),
			pose = frame.getViewerPose(refSpace);
		null == pose && !0 === this.tracking && this.frames > 30 && (this.tracking = !1, this.dispatchEvent({
			type: "tracking",
			status: ARTracking.NOT_TRACKING
		}));
		let scene = this.presentedScene;
		if (null == pose || null == scene || !scene.element.loaded) {
			this.threeRenderer.clear();
			return
		}!1 === this.tracking && (this.tracking = !0, this.dispatchEvent({
			type: "tracking",
			status: ARTracking.TRACKING
		}));
		let isFirstView = !0;
		for (let view of pose.views) {
			if (this.updateView(view), isFirstView) {
				this.moveToFloor(frame), this.processInput(frame);
				let delta = time - this.lastTick;
				this.moveScene(delta), this.renderer.preRender(scene, time, delta), this.lastTick = time, scene.renderShadow(this.threeRenderer)
			}
			this.threeRenderer.render(scene, scene.getCamera()), isFirstView = !1
		}
	}
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let $prepared = Symbol("prepared"),
	$prepare = Symbol("prepare"),
	$preparedGLTF = Symbol("preparedGLTF"),
	$clone = Symbol("clone");
class GLTFInstance {
	constructor(preparedGLTF) {
		this[$preparedGLTF] = preparedGLTF
	}
	static prepare(source) {
		if (null == source.scene) throw Error("Model does not have a scene");
		if (source[$prepared]) return source;
		let prepared = this[$prepare](source);
		return prepared[$prepared] = !0, prepared
	}
	static[$prepare](source) {
		let {
			scene
		} = source, scenes = [scene];
		return Object.assign(Object.assign({}, source), {
			scene,
			scenes
		})
	}
	get parser() {
		return this[$preparedGLTF].parser
	}
	get animations() {
		return this[$preparedGLTF].animations
	}
	get scene() {
		return this[$preparedGLTF].scene
	}
	get scenes() {
		return this[$preparedGLTF].scenes
	}
	get cameras() {
		return this[$preparedGLTF].cameras
	}
	get asset() {
		return this[$preparedGLTF].asset
	}
	get userData() {
		return this[$preparedGLTF].userData
	}
	clone() {
		return new this.constructor(this[$clone]())
	}
	dispose() {
		this.scenes.forEach(scene => {
			scene.traverse(object => {
				object.material && ((Array.isArray(object.material) ? object.material : [object.material]).forEach(material => {
					for (let propertyName in material) {
						let texture = material[propertyName];
						if (texture instanceof Texture$1) {
							let image = texture.source.data;
							null != image.close && image.close(), texture.dispose()
						}
					}
					material.dispose()
				}), object.geometry.dispose())
			})
		})
	} [$clone]() {
		let source = this[$preparedGLTF],
			scene = function(source) {
				let sourceLookup = new Map,
					cloneLookup = new Map,
					clone = source.clone();
				return function parallelTraverse(a, b, callback) {
					callback(a, b);
					for (let i = 0; i < a.children.length; i++) parallelTraverse(a.children[i], b.children[i], callback)
				}(source, clone, function(sourceNode, clonedNode) {
					sourceLookup.set(clonedNode, sourceNode), cloneLookup.set(sourceNode, clonedNode)
				}), clone.traverse(function(node) {
					if (!node.isSkinnedMesh) return;
					let sourceMesh = sourceLookup.get(node),
						sourceBones = sourceMesh.skeleton.bones;
					node.skeleton = sourceMesh.skeleton.clone(), node.bindMatrix.copy(sourceMesh.bindMatrix), node.skeleton.bones = sourceBones.map(function(bone) {
						return cloneLookup.get(bone)
					}), node.bind(node.skeleton, node.bindMatrix)
				}), clone
			}(this.scene);
		cloneVariantMaterials(scene, this.scene);
		let scenes = [scene],
			userData = source.userData ? Object.assign({}, source.userData) : {};
		return Object.assign(Object.assign({}, source), {
			scene,
			scenes,
			userData
		})
	}
}
let cloneVariantMaterials = (dst, src) => {
		traversePair(dst, src, (dst, src) => {
			void 0 !== src.userData.variantMaterials && (dst.userData.variantMaterials = new Map(src.userData.variantMaterials)), void 0 !== src.userData.variantData && (dst.userData.variantData = src.userData.variantData), void 0 !== src.userData.originalMaterial && (dst.userData.originalMaterial = src.userData.originalMaterial)
		})
	},
	traversePair = (obj1, obj2, callback) => {
		callback(obj1, obj2);
		for (let i = 0; i < obj1.children.length; i++) traversePair(obj1.children[i], obj2.children[i], callback)
	},
	$threeGLTF = Symbol("threeGLTF"),
	$gltf = Symbol("gltf"),
	$gltfElementMap = Symbol("gltfElementMap"),
	$threeObjectMap = Symbol("threeObjectMap"),
	$parallelTraverseThreeScene = Symbol("parallelTraverseThreeScene"),
	$correlateOriginalThreeGLTF = Symbol("correlateOriginalThreeGLTF"),
	$correlateCloneThreeGLTF = Symbol("correlateCloneThreeGLTF");
class CorrelatedSceneGraph {
	constructor(threeGLTF, gltf, threeObjectMap, gltfElementMap) {
		this[$threeGLTF] = threeGLTF, this[$gltf] = gltf, this[$gltfElementMap] = gltfElementMap, this[$threeObjectMap] = threeObjectMap
	}
	static from(threeGLTF, upstreamCorrelatedSceneGraph) {
		return null != upstreamCorrelatedSceneGraph ? this[$correlateCloneThreeGLTF](threeGLTF, upstreamCorrelatedSceneGraph) : this[$correlateOriginalThreeGLTF](threeGLTF)
	}
	static[$correlateOriginalThreeGLTF](threeGLTF) {
		let gltf = threeGLTF.parser.json,
			associations = threeGLTF.parser.associations,
			gltfElementMap = new Map,
			defaultMaterial = {
				name: "Default"
			},
			defaultReference = {
				index: -1
			};
		for (let threeMaterial of associations.keys()) threeMaterial instanceof Material$1 && null == associations.get(threeMaterial) && (defaultReference.index < 0 && (null == gltf.materials && (gltf.materials = []), defaultReference.index = gltf.materials.length, gltf.materials.push(defaultMaterial)), threeMaterial.name = defaultMaterial.name, associations.set(threeMaterial, {
			materials: defaultReference.index
		}));
		for (let [threeObject, gltfMappings] of associations)
			for (let mapping in gltfMappings && (threeObject.userData = threeObject.userData || {}, threeObject.userData.associations = gltfMappings), gltfMappings)
				if (null != mapping && "primitives" !== mapping) {
					let gltfElement = (gltf[mapping] || [])[gltfMappings[mapping]];
					if (null == gltfElement) continue;
					let threeObjects = gltfElementMap.get(gltfElement);
					null == threeObjects && (threeObjects = new Set, gltfElementMap.set(gltfElement, threeObjects)), threeObjects.add(threeObject)
				} return new CorrelatedSceneGraph(threeGLTF, gltf, associations, gltfElementMap)
	}
	static[$correlateCloneThreeGLTF](cloneThreeGLTF, upstreamCorrelatedSceneGraph) {
		let originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF,
			cloneGLTF = JSON.parse(JSON.stringify(upstreamCorrelatedSceneGraph.gltf)),
			cloneThreeObjectMap = new Map,
			cloneGLTFElementMap = new Map;
		for (let i = 0; i < originalThreeGLTF.scenes.length; i++) this[$parallelTraverseThreeScene](originalThreeGLTF.scenes[i], cloneThreeGLTF.scenes[i], (object, cloneObject) => {
			let elementReference = upstreamCorrelatedSceneGraph.threeObjectMap.get(object);
			if (null != elementReference) {
				for (let mapping in elementReference)
					if (null != mapping && "primitives" !== mapping) {
						let index = elementReference[mapping],
							cloneElement = cloneGLTF[mapping][index],
							mappings = cloneThreeObjectMap.get(cloneObject) || {};
						mappings[mapping] = index, cloneThreeObjectMap.set(cloneObject, mappings);
						let cloneObjects = cloneGLTFElementMap.get(cloneElement) || new Set;
						cloneObjects.add(cloneObject), cloneGLTFElementMap.set(cloneElement, cloneObjects)
					}
			}
		});
		return new CorrelatedSceneGraph(cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFElementMap)
	}
	static[$parallelTraverseThreeScene](sceneOne, sceneTwo, callback) {
		let traverse = (a, b) => {
			if (callback(a, b), a.isObject3D) {
				if (a.material) {
					if (Array.isArray(a.material))
						for (let i = 0; i < a.material.length; ++i) callback(a.material[i], b.material[i]);
					else callback(a.material, b.material)
				}
				for (let i = 0; i < a.children.length; ++i) traverse(a.children[i], b.children[i])
			}
		};
		traverse(sceneOne, sceneTwo)
	}
	get threeGLTF() {
		return this[$threeGLTF]
	}
	get gltf() {
		return this[$gltf]
	}
	get gltfElementMap() {
		return this[$gltfElementMap]
	}
	get threeObjectMap() {
		return this[$threeObjectMap]
	}
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let $correlatedSceneGraph = Symbol("correlatedSceneGraph");
class ModelViewerGLTFInstance extends GLTFInstance {
	static[$prepare](source) {
		let prepared = super[$prepare](source);
		null == prepared[$correlatedSceneGraph] && (prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared));
		let {
			scene
		} = prepared, nullSphere = new Sphere(void 0, 1 / 0);
		return scene.traverse(node => {
			if (node.renderOrder = 1e3, node.frustumCulled = !1, node.name || (node.name = node.uuid), node.material) {
				let {
					geometry
				} = node;
				node.castShadow = !0, node.isSkinnedMesh && (geometry.boundingSphere = nullSphere, geometry.boundingBox = null);
				let material = node.material;
				if (!0 === material.isMeshBasicMaterial && (material.toneMapped = !1), material.shadowSide = 0, material.aoMap) {
					let {
						gltf,
						threeObjectMap
					} = prepared[$correlatedSceneGraph], gltfRef = threeObjectMap.get(material);
					if (null != gltf.materials && null != gltfRef && null != gltfRef.materials) {
						let gltfMaterial = gltf.materials[gltfRef.materials];
						gltfMaterial.occlusionTexture && 0 === gltfMaterial.occlusionTexture.texCoord && null != geometry.attributes.uv && geometry.setAttribute("uv2", geometry.attributes.uv)
					}
				}
			}
		}), prepared
	}
	get correlatedSceneGraph() {
		return this[$preparedGLTF][$correlatedSceneGraph]
	} [$clone]() {
		let clone = super[$clone](),
			sourceUUIDToClonedMaterial = new Map;
		return clone.scene.traverse(node => {
			if (node.material) {
				let material = node.material;
				if (null != material) {
					if (sourceUUIDToClonedMaterial.has(material.uuid)) {
						node.material = sourceUUIDToClonedMaterial.get(material.uuid);
						return
					}
					node.material = material.clone(), sourceUUIDToClonedMaterial.set(material.uuid, node.material)
				}
			}
			void 0 !== node.target && node.add(node.target)
		}), clone[$correlatedSceneGraph] = CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph), clone
	}
}
let getBufferForType = (type, width, height) => {
		let out;
		switch (type) {
			case 1009:
				out = new Uint8ClampedArray(width * height * 4);
				break;
			case 1016:
				out = new Uint16Array(width * height * 4);
				break;
			case 1014:
				out = new Uint32Array(width * height * 4);
				break;
			case 1010:
				out = new Int8Array(width * height * 4);
				break;
			case 1011:
				out = new Int16Array(width * height * 4);
				break;
			case 1013:
				out = new Int32Array(width * height * 4);
				break;
			case 1015:
				out = new Float32Array(width * height * 4);
				break;
			default:
				throw Error("Unsupported data type")
		}
		return out
	},
	canReadPixels = (type, renderer, camera, renderTargetOptions) => {
		if (void 0 !== _canReadPixelsResult) return _canReadPixelsResult;
		let testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);
		renderer.setRenderTarget(testRT);
		let mesh = new Mesh(new PlaneGeometry, new MeshBasicMaterial({
			color: 16777215
		}));
		renderer.render(mesh, camera), renderer.setRenderTarget(null);
		let out = getBufferForType(type, testRT.width, testRT.height);
		return renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out), testRT.dispose(), mesh.geometry.dispose(), mesh.material.dispose(), _canReadPixelsResult = 0 !== out[0]
	};
class QuadRenderer {
	constructor(options) {
		var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
		this._rendererIsDisposable = !1, this._supportsReadPixels = !0, this.render = () => {
			this._renderer.setRenderTarget(this._renderTarget);
			try {
				this._renderer.render(this._scene, this._camera)
			} catch (e) {
				throw this._renderer.setRenderTarget(null), e
			}
			this._renderer.setRenderTarget(null)
		}, this._width = options.width, this._height = options.height, this._type = options.type, this._colorSpace = options.colorSpace;
		let rtOptions = {
			format: 1023,
			depthBuffer: !1,
			stencilBuffer: !1,
			type: this._type,
			colorSpace: this._colorSpace,
			anisotropy: (null === (_a = options.renderTargetOptions) || void 0 === _a ? void 0 : _a.anisotropy) !== void 0 ? null === (_b = options.renderTargetOptions) || void 0 === _b ? void 0 : _b.anisotropy : 1,
			generateMipmaps: (null === (_c = options.renderTargetOptions) || void 0 === _c ? void 0 : _c.generateMipmaps) !== void 0 && (null === (_d = options.renderTargetOptions) || void 0 === _d ? void 0 : _d.generateMipmaps),
			magFilter: (null === (_e = options.renderTargetOptions) || void 0 === _e ? void 0 : _e.magFilter) !== void 0 ? null === (_f = options.renderTargetOptions) || void 0 === _f ? void 0 : _f.magFilter : 1006,
			minFilter: (null === (_g = options.renderTargetOptions) || void 0 === _g ? void 0 : _g.minFilter) !== void 0 ? null === (_h = options.renderTargetOptions) || void 0 === _h ? void 0 : _h.minFilter : 1006,
			samples: (null === (_j = options.renderTargetOptions) || void 0 === _j ? void 0 : _j.samples) !== void 0 ? null === (_k = options.renderTargetOptions) || void 0 === _k ? void 0 : _k.samples : void 0,
			wrapS: (null === (_l = options.renderTargetOptions) || void 0 === _l ? void 0 : _l.wrapS) !== void 0 ? null === (_m = options.renderTargetOptions) || void 0 === _m ? void 0 : _m.wrapS : 1001,
			wrapT: (null === (_o = options.renderTargetOptions) || void 0 === _o ? void 0 : _o.wrapT) !== void 0 ? null === (_p = options.renderTargetOptions) || void 0 === _p ? void 0 : _p.wrapT : 1001
		};
		if (this._material = options.material, options.renderer ? this._renderer = options.renderer : (this._renderer = QuadRenderer.instantiateRenderer(), this._rendererIsDisposable = !0), this._scene = new Scene, this._camera = new OrthographicCamera, this._camera.position.set(0, 0, 10), this._camera.left = -.5, this._camera.right = .5, this._camera.top = .5, this._camera.bottom = -.5, this._camera.updateProjectionMatrix(), !canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {
			let alternativeType;
			1016 === this._type && (alternativeType = this._renderer.extensions.has("EXT_color_buffer_float") ? 1015 : void 0), void 0 !== alternativeType ? (console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to 1015`), this._type = alternativeType) : (this._supportsReadPixels = !1, console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))
		}
		this._quad = new Mesh(new PlaneGeometry, this._material), this._quad.geometry.computeBoundingBox(), this._scene.add(this._quad), this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions), this._renderTarget.texture.mapping = (null === (_q = options.renderTargetOptions) || void 0 === _q ? void 0 : _q.mapping) !== void 0 ? null === (_r = options.renderTargetOptions) || void 0 === _r ? void 0 : _r.mapping : 300
	}
	static instantiateRenderer() {
		let renderer = new WebGLRenderer;
		return renderer.setSize(128, 128), renderer
	}
	toArray() {
		if (!this._supportsReadPixels) throw Error("Can't read pixels in this browser");
		let out = getBufferForType(this._type, this._width, this._height);
		return this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out), out
	}
	toDataTexture(options) {
		let returnValue = new DataTexture(this.toArray(), this.width, this.height, 1023, this._type, (null == options ? void 0 : options.mapping) || 300, (null == options ? void 0 : options.wrapS) || 1001, (null == options ? void 0 : options.wrapT) || 1001, (null == options ? void 0 : options.magFilter) || 1006, (null == options ? void 0 : options.minFilter) || 1006, (null == options ? void 0 : options.anisotropy) || 1, LinearSRGBColorSpace);
		return returnValue.generateMipmaps = (null == options ? void 0 : options.generateMipmaps) !== void 0 && (null == options ? void 0 : options.generateMipmaps), returnValue
	}
	disposeOnDemandRenderer() {
		this._renderer.setRenderTarget(null), this._rendererIsDisposable && (this._renderer.dispose(), this._renderer.forceContextLoss())
	}
	dispose(disposeRenderTarget) {
		this.disposeOnDemandRenderer(), disposeRenderTarget && this.renderTarget.dispose(), this.material instanceof ShaderMaterial && Object.values(this.material.uniforms).forEach(v => {
			v.value instanceof Texture$1 && v.value.dispose()
		}), Object.values(this.material).forEach(value => {
			value instanceof Texture$1 && value.dispose()
		}), this.material.dispose(), this._quad.geometry.dispose()
	}
	get width() {
		return this._width
	}
	set width(value) {
		this._width = value, this._renderTarget.setSize(this._width, this._height)
	}
	get height() {
		return this._height
	}
	set height(value) {
		this._height = value, this._renderTarget.setSize(this._width, this._height)
	}
	get renderer() {
		return this._renderer
	}
	get renderTarget() {
		return this._renderTarget
	}
	set renderTarget(value) {
		this._renderTarget = value, this._width = value.width, this._height = value.height
	}
	get material() {
		return this._material
	}
	get type() {
		return this._type
	}
	get colorSpace() {
		return this._colorSpace
	}
}
let vertexShader = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
	fragmentShader = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
class GainMapDecoderMaterial extends ShaderMaterial {
	constructor({
		gamma,
		offsetHdr,
		offsetSdr,
		gainMapMin,
		gainMapMax,
		maxDisplayBoost,
		hdrCapacityMin,
		hdrCapacityMax,
		sdr,
		gainMap
	}) {
		super({
			name: "GainMapDecoderMaterial",
			vertexShader,
			fragmentShader,
			uniforms: {
				sdr: {
					value: sdr
				},
				gainMap: {
					value: gainMap
				},
				gamma: {
					value: new Vector3(1 / gamma[0], 1 / gamma[1], 1 / gamma[2])
				},
				offsetHdr: {
					value: new Vector3().fromArray(offsetHdr)
				},
				offsetSdr: {
					value: new Vector3().fromArray(offsetSdr)
				},
				gainMapMin: {
					value: new Vector3().fromArray(gainMapMin)
				},
				gainMapMax: {
					value: new Vector3().fromArray(gainMapMax)
				},
				weightFactor: {
					value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)
				}
			},
			blending: 0,
			depthTest: !1,
			depthWrite: !1
		}), this._maxDisplayBoost = maxDisplayBoost, this._hdrCapacityMin = hdrCapacityMin, this._hdrCapacityMax = hdrCapacityMax, this.needsUpdate = !0, this.uniformsNeedUpdate = !0
	}
	get sdr() {
		return this.uniforms.sdr.value
	}
	set sdr(value) {
		this.uniforms.sdr.value = value
	}
	get gainMap() {
		return this.uniforms.gainMap.value
	}
	set gainMap(value) {
		this.uniforms.gainMap.value = value
	}
	get offsetHdr() {
		return this.uniforms.offsetHdr.value.toArray()
	}
	set offsetHdr(value) {
		this.uniforms.offsetHdr.value.fromArray(value)
	}
	get offsetSdr() {
		return this.uniforms.offsetSdr.value.toArray()
	}
	set offsetSdr(value) {
		this.uniforms.offsetSdr.value.fromArray(value)
	}
	get gainMapMin() {
		return this.uniforms.gainMapMin.value.toArray()
	}
	set gainMapMin(value) {
		this.uniforms.gainMapMin.value.fromArray(value)
	}
	get gainMapMax() {
		return this.uniforms.gainMapMax.value.toArray()
	}
	set gainMapMax(value) {
		this.uniforms.gainMapMax.value.fromArray(value)
	}
	get gamma() {
		let g = this.uniforms.gamma.value;
		return [1 / g.x, 1 / g.y, 1 / g.z]
	}
	set gamma(value) {
		let g = this.uniforms.gamma.value;
		g.x = 1 / value[0], g.y = 1 / value[1], g.z = 1 / value[2]
	}
	get hdrCapacityMin() {
		return this._hdrCapacityMin
	}
	set hdrCapacityMin(value) {
		this._hdrCapacityMin = value, this.calculateWeight()
	}
	get hdrCapacityMax() {
		return this._hdrCapacityMax
	}
	set hdrCapacityMax(value) {
		this._hdrCapacityMax = value, this.calculateWeight()
	}
	get maxDisplayBoost() {
		return this._maxDisplayBoost
	}
	set maxDisplayBoost(value) {
		this._maxDisplayBoost = Math.max(1, Math.min(65504, value)), this.calculateWeight()
	}
	calculateWeight() {
		let val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);
		this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val))
	}
}
class GainMapNotFoundError extends Error {}
class XMPMetadataNotFoundError extends Error {}
let getAttribute = (description, name, defaultValue) => {
		var _a;
		let returnValue;
		let parsedValue = null === (_a = description.attributes.getNamedItem(name)) || void 0 === _a ? void 0 : _a.nodeValue;
		if (parsedValue) returnValue = parsedValue;
		else {
			let node = description.getElementsByTagName(name)[0];
			if (node) {
				let values = node.getElementsByTagName("rdf:li");
				if (3 === values.length) returnValue = Array.from(values).map(v => v.innerHTML);
				else throw Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`)
			} else {
				if (defaultValue) return defaultValue;
				throw Error(`Can't find ${name} in gainmap metadata`)
			}
		}
		return returnValue
	},
	extractXMP = input => {
		var _a, _b;
		let str;
		"undefined" != typeof TextDecoder ? str = new TextDecoder().decode(input) : str = input.toString();
		let start = str.indexOf("<x:xmpmeta"),
			parser = new DOMParser;
		for (; - 1 !== start;) {
			let end = str.indexOf("x:xmpmeta>", start);
			str.slice(start, end + 10);
			let xmpBlock = str.slice(start, end + 10);
			try {
				let description = parser.parseFromString(xmpBlock, "text/xml").getElementsByTagName("rdf:Description")[0],
					gainMapMin = getAttribute(description, "hdrgm:GainMapMin", "0"),
					gainMapMax = getAttribute(description, "hdrgm:GainMapMax"),
					gamma = getAttribute(description, "hdrgm:Gamma", "1"),
					offsetSDR = getAttribute(description, "hdrgm:OffsetSDR", "0.015625"),
					offsetHDR = getAttribute(description, "hdrgm:OffsetHDR", "0.015625"),
					hdrCapacityMin = null === (_a = description.attributes.getNamedItem("hdrgm:HDRCapacityMin")) || void 0 === _a ? void 0 : _a.nodeValue;
				hdrCapacityMin || (hdrCapacityMin = "0");
				let hdrCapacityMax = null === (_b = description.attributes.getNamedItem("hdrgm:HDRCapacityMax")) || void 0 === _b ? void 0 : _b.nodeValue;
				if (!hdrCapacityMax) throw Error("Incomplete gainmap metadata");
				return {
					gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],
					gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],
					gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],
					offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],
					offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],
					hdrCapacityMin: parseFloat(hdrCapacityMin),
					hdrCapacityMax: parseFloat(hdrCapacityMax)
				}
			} catch (e) {}
			start = str.indexOf("<x:xmpmeta", end)
		}
	};
class MPFExtractor {
	constructor(options) {
		this.options = {
			debug: !!options && void 0 !== options.debug && options.debug,
			extractFII: !options || void 0 === options.extractFII || options.extractFII,
			extractNonFII: !options || void 0 === options.extractNonFII || options.extractNonFII
		}
	}
	extract(imageArrayBuffer) {
		return new Promise((resolve, reject) => {
			let marker;
			let debug = this.options.debug,
				dataView = new DataView(imageArrayBuffer.buffer);
			if (65496 !== dataView.getUint16(0)) {
				reject(Error("Not a valid jpeg"));
				return
			}
			let length = dataView.byteLength,
				offset = 2,
				loops = 0;
			for (; offset < length;) {
				if (++loops > 250) {
					reject(Error(`Found no marker after ${loops} loops `));
					return
				}
				if (255 !== dataView.getUint8(offset)) {
					reject(Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));
					return
				}
				if (marker = dataView.getUint8(offset + 1), debug && console.log(`Marker: ${marker.toString(16)}`), 226 === marker) {
					debug && console.log("Found APP2 marker (0xffe2)");
					let formatPt = offset + 4;
					if (1297106432 === dataView.getUint32(formatPt)) {
						let bigEnd;
						let tiffOffset = formatPt + 4;
						if (18761 === dataView.getUint16(tiffOffset)) bigEnd = !1;
						else if (19789 === dataView.getUint16(tiffOffset)) bigEnd = !0;
						else {
							reject(Error("No valid endianness marker found in TIFF header"));
							return
						}
						if (42 !== dataView.getUint16(tiffOffset + 2, !bigEnd)) {
							reject(Error("Not valid TIFF data! (no 0x002A marker)"));
							return
						}
						let firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);
						if (firstIFDOffset < 8) {
							reject(Error("Not valid TIFF data! (First offset less than 8)"));
							return
						}
						let dirStart = tiffOffset + firstIFDOffset,
							count = dataView.getUint16(dirStart, !bigEnd),
							entriesStart = dirStart + 2,
							numberOfImages = 0;
						for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) 45057 === dataView.getUint16(i, !bigEnd) && (numberOfImages = dataView.getUint32(i + 8, !bigEnd));
						let MPImageListValPt = dirStart + 2 + 12 * count + 4,
							images = [];
						for (let i = MPImageListValPt; i < MPImageListValPt + 16 * numberOfImages; i += 16) {
							let image = {
								MPType: dataView.getUint32(i, !bigEnd),
								size: dataView.getUint32(i + 4, !bigEnd),
								dataOffset: dataView.getUint32(i + 8, !bigEnd),
								dependantImages: dataView.getUint32(i + 12, !bigEnd),
								start: -1,
								end: -1,
								isFII: !1
							};
							image.dataOffset ? (image.start = tiffOffset + image.dataOffset, image.isFII = !1) : (image.start = 0, image.isFII = !0), image.end = image.start + image.size, images.push(image)
						}
						if (this.options.extractNonFII && images.length) {
							let bufferBlob = new Blob([dataView]),
								imgs = [];
							for (let image of images) {
								if (image.isFII && !this.options.extractFII) continue;
								let imageBlob = bufferBlob.slice(image.start, image.end + 1, "image/jpeg");
								imgs.push(imageBlob)
							}
							resolve(imgs)
						}
					}
				}
				offset += 2 + dataView.getUint16(offset + 2)
			}
		})
	}
}
let extractGainmapFromJPEG = async jpegFile => {
	let metadata = extractXMP(jpegFile);
	if (!metadata) throw new XMPMetadataNotFoundError("Gain map XMP metadata not found");
	let mpfExtractor = new MPFExtractor({
			extractFII: !0,
			extractNonFII: !0
		}),
		images = await mpfExtractor.extract(jpegFile);
	if (2 !== images.length) throw new GainMapNotFoundError("Gain map recovery image not found");
	return {
		sdr: new Uint8Array(await images[0].arrayBuffer()),
		gainMap: new Uint8Array(await images[1].arrayBuffer()),
		metadata
	}
}, getHTMLImageFromBlob = blob => new Promise((resolve, reject) => {
	let img = document.createElement("img");
	img.onload = () => {
		resolve(img)
	}, img.onerror = e => {
		reject(e)
	}, img.src = URL.createObjectURL(blob)
});
class LoaderBase extends Loader {
	constructor(renderer, manager) {
		super(manager), this._renderer = renderer, this._internalLoadingManager = new LoadingManager
	}
	setRenderTargetOptions(options) {
		return this._renderTargetOptions = options, this
	}
	prepareQuadRenderer() {
		return new QuadRenderer({
			width: 16,
			height: 16,
			type: 1016,
			colorSpace: LinearSRGBColorSpace,
			material: new GainMapDecoderMaterial({
				gainMapMax: [1, 1, 1],
				gainMapMin: [0, 0, 0],
				gamma: [1, 1, 1],
				offsetHdr: [1, 1, 1],
				offsetSdr: [1, 1, 1],
				hdrCapacityMax: 1,
				hdrCapacityMin: 0,
				maxDisplayBoost: 1,
				gainMap: new Texture$1,
				sdr: new Texture$1
			}),
			renderer: this._renderer,
			renderTargetOptions: this._renderTargetOptions
		})
	}
	async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {
		let sdrImage, gainMapImage;
		let gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], {
				type: "image/jpeg"
			}) : void 0,
			sdrBlob = new Blob([sdrBuffer], {
				type: "image/jpeg"
			}),
			needsFlip = !1;
		if ("undefined" == typeof createImageBitmap) {
			let res = await Promise.all([gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(void 0), getHTMLImageFromBlob(sdrBlob)]);
			gainMapImage = res[0], sdrImage = res[1], needsFlip = !0
		} else {
			let res = await Promise.all([gainMapBlob ? createImageBitmap(gainMapBlob, {
				imageOrientation: "flipY"
			}) : Promise.resolve(void 0), createImageBitmap(sdrBlob, {
				imageOrientation: "flipY"
			})]);
			gainMapImage = res[0], sdrImage = res[1]
		}
		let gainMap = new Texture$1(gainMapImage || new ImageData(2, 2), 300, 1001, 1001, 1006, 1008, 1023, 1009, 1, LinearSRGBColorSpace);
		gainMap.flipY = needsFlip, gainMap.needsUpdate = !0;
		let sdr = new Texture$1(sdrImage, 300, 1001, 1001, 1006, 1008, 1023, 1009, 1, SRGBColorSpace);
		sdr.flipY = needsFlip, sdr.needsUpdate = !0, quadRenderer.width = sdrImage.width, quadRenderer.height = sdrImage.height, quadRenderer.material.gainMap = gainMap, quadRenderer.material.sdr = sdr, quadRenderer.material.gainMapMin = metadata.gainMapMin, quadRenderer.material.gainMapMax = metadata.gainMapMax, quadRenderer.material.offsetHdr = metadata.offsetHdr, quadRenderer.material.offsetSdr = metadata.offsetSdr, quadRenderer.material.gamma = metadata.gamma, quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin, quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax, quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax), quadRenderer.material.needsUpdate = !0, quadRenderer.render()
	}
}
class HDRJPGLoader extends LoaderBase {
	load(url, onLoad, onProgress, onError) {
		let quadRenderer = this.prepareQuadRenderer(),
			loader = new FileLoader(this._internalLoadingManager);
		return loader.setResponseType("arraybuffer"), loader.setRequestHeader(this.requestHeader), loader.setPath(this.path), loader.setWithCredentials(this.withCredentials), this.manager.itemStart(url), loader.load(url, async jpeg => {
			let sdrJPEG, gainMapJPEG, metadata;
			if ("string" == typeof jpeg) throw Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");
			let jpegBuffer = new Uint8Array(jpeg);
			try {
				let extractionResult = await extractGainmapFromJPEG(jpegBuffer);
				sdrJPEG = extractionResult.sdr, gainMapJPEG = extractionResult.gainMap, metadata = extractionResult.metadata
			} catch (e) {
				if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`), metadata = {
					gainMapMin: [0, 0, 0],
					gainMapMax: [1, 1, 1],
					gamma: [1, 1, 1],
					hdrCapacityMin: 0,
					hdrCapacityMax: 1,
					offsetHdr: [0, 0, 0],
					offsetSdr: [0, 0, 0]
				}, sdrJPEG = jpegBuffer;
				else throw e
			}
			try {
				await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG)
			} catch (error) {
				this.manager.itemError(url), "function" == typeof onError && onError(error), quadRenderer.disposeOnDemandRenderer();
				return
			}
			"function" == typeof onLoad && onLoad(quadRenderer), this.manager.itemEnd(url), quadRenderer.disposeOnDemandRenderer()
		}, onProgress, error => {
			this.manager.itemError(url), "function" == typeof onError && onError(error)
		}), quadRenderer
	}
}
class RGBELoader extends DataTextureLoader {
	constructor(manager) {
		super(manager), this.type = 1016
	}
	parse(buffer) {
		let data, type, numElements;
		let rgbe_error = function(rgbe_error_code, msg) {
				switch (rgbe_error_code) {
					case 1:
						throw Error("THREE.RGBELoader: Read Error: " + (msg || ""));
					case 2:
						throw Error("THREE.RGBELoader: Write Error: " + (msg || ""));
					case 3:
						throw Error("THREE.RGBELoader: Bad File Format: " + (msg || ""));
					default:
						throw Error("THREE.RGBELoader: Memory Error: " + (msg || ""))
				}
			},
			fgets = function(buffer, lineLimit, consume) {
				lineLimit = lineLimit || 1024;
				let p = buffer.pos,
					i = -1,
					len = 0,
					s = "",
					chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + 128)));
				for (; 0 > (i = chunk.indexOf("\n")) && len < lineLimit && p < buffer.byteLength;) s += chunk, len += chunk.length, p += 128, chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + 128)));
				return -1 < i && (!1 !== consume && (buffer.pos += len + i + 1), s + chunk.slice(0, i))
			},
			byteArray = new Uint8Array(buffer);
		byteArray.pos = 0;
		let rgbe_header_info = function(buffer) {
				let line, match;
				let gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
					header = {
						valid: 0,
						string: "",
						comments: "",
						programtype: "RGBE",
						format: "",
						gamma: 1,
						exposure: 1,
						width: 0,
						height: 0
					};
				for (!(buffer.pos >= buffer.byteLength) && (line = fgets(buffer)) || rgbe_error(1, "no header found"), (match = line.match(/^#\?(\S+)/)) || rgbe_error(3, "bad initial token"), header.valid |= 1, header.programtype = match[1], header.string += line + "\n"; !1 !== (line = fgets(buffer));) {
					if (header.string += line + "\n", "#" === line.charAt(0)) {
						header.comments += line + "\n";
						continue
					}
					if ((match = line.match(gamma_re)) && (header.gamma = parseFloat(match[1])), (match = line.match(exposure_re)) && (header.exposure = parseFloat(match[1])), (match = line.match(format_re)) && (header.valid |= 2, header.format = match[1]), (match = line.match(dimensions_re)) && (header.valid |= 4, header.height = parseInt(match[1], 10), header.width = parseInt(match[2], 10)), 2 & header.valid && 4 & header.valid) break
				}
				return 2 & header.valid || rgbe_error(3, "missing format specifier"), 4 & header.valid || rgbe_error(3, "missing image size specifier"), header
			}(byteArray),
			w = rgbe_header_info.width,
			h = rgbe_header_info.height,
			image_rgba_data = function(buffer, w, h) {
				if (w < 8 || w > 32767 || 2 !== buffer[0] || 2 !== buffer[1] || 128 & buffer[2]) return new Uint8Array(buffer);
				w !== (buffer[2] << 8 | buffer[3]) && rgbe_error(3, "wrong scanline width");
				let data_rgba = new Uint8Array(4 * w * h);
				data_rgba.length || rgbe_error(4, "unable to allocate buffer space");
				let offset = 0,
					pos = 0,
					ptr_end = 4 * w,
					rgbeStart = new Uint8Array(4),
					scanline_buffer = new Uint8Array(ptr_end),
					num_scanlines = h;
				for (; num_scanlines > 0 && pos < buffer.byteLength;) {
					pos + 4 > buffer.byteLength && rgbe_error(1), rgbeStart[0] = buffer[pos++], rgbeStart[1] = buffer[pos++], rgbeStart[2] = buffer[pos++], rgbeStart[3] = buffer[pos++], (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != w) && rgbe_error(3, "bad rgbe scanline format");
					let ptr = 0,
						count;
					for (; ptr < ptr_end && pos < buffer.byteLength;) {
						let isEncodedRun = (count = buffer[pos++]) > 128;
						if (isEncodedRun && (count -= 128), (0 === count || ptr + count > ptr_end) && rgbe_error(3, "bad scanline data"), isEncodedRun) {
							let byteValue = buffer[pos++];
							for (let i = 0; i < count; i++) scanline_buffer[ptr++] = byteValue
						} else scanline_buffer.set(buffer.subarray(pos, pos + count), ptr), ptr += count, pos += count
					}
					for (let i = 0; i < w; i++) {
						let off = 0;
						data_rgba[offset] = scanline_buffer[i + off], off += w, data_rgba[offset + 1] = scanline_buffer[i + off], off += w, data_rgba[offset + 2] = scanline_buffer[i + off], off += w, data_rgba[offset + 3] = scanline_buffer[i + off], offset += 4
					}
					num_scanlines--
				}
				return data_rgba
			}(byteArray.subarray(byteArray.pos), w, h);
		switch (this.type) {
			case 1015:
				let floatArray = new Float32Array(4 * (numElements = image_rgba_data.length / 4));
				for (let j = 0; j < numElements; j++) ! function(sourceArray, sourceOffset, destArray, destOffset) {
					let scale = Math.pow(2, sourceArray[sourceOffset + 3] - 128) / 255;
					destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale, destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale, destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale, destArray[destOffset + 3] = 1
				}(image_rgba_data, 4 * j, floatArray, 4 * j);
				data = floatArray, type = 1015;
				break;
			case 1016:
				let halfArray = new Uint16Array(4 * (numElements = image_rgba_data.length / 4));
				for (let j = 0; j < numElements; j++) ! function(sourceArray, sourceOffset, destArray, destOffset) {
					let scale = Math.pow(2, sourceArray[sourceOffset + 3] - 128) / 255;
					destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504)), destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504)), destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504)), destArray[destOffset + 3] = DataUtils.toHalfFloat(1)
				}(image_rgba_data, 4 * j, halfArray, 4 * j);
				data = halfArray, type = 1016;
				break;
			default:
				throw Error("THREE.RGBELoader: Unsupported type: " + this.type)
		}
		return {
			width: w,
			height: h,
			data: data,
			header: rgbe_header_info.string,
			gamma: rgbe_header_info.gamma,
			exposure: rgbe_header_info.exposure,
			type: type
		}
	}
	setDataType(value) {
		return this.type = value, this
	}
	load(url, onLoad, onProgress, onError) {
		return super.load(url, function(texture, texData) {
			switch (texture.type) {
				case 1015:
				case 1016:
					texture.colorSpace = LinearSRGBColorSpace, texture.minFilter = 1006, texture.magFilter = 1006, texture.generateMipmaps = !1, texture.flipY = !0
			}
			onLoad && onLoad(texture, texData)
		}, onProgress, onError)
	}
}
/* @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let legacy = {
		topLight: {
			intensity: 500,
			position: [.418, 16.199, .3]
		},
		room: {
			position: [-.757, 13.219, .717],
			scale: [31.713, 28.305, 28.591]
		},
		boxes: [{
			position: [-10.906, 2.009, 1.846],
			rotation: -.195,
			scale: [2.328, 7.905, 4.651]
		}, {
			position: [-5.607, -.754, -.758],
			rotation: .994,
			scale: [1.97, 1.534, 3.955]
		}, {
			position: [6.167, .857, 7.803],
			rotation: .561,
			scale: [3.927, 6.285, 3.687]
		}, {
			position: [-2.017, .018, 6.124],
			rotation: .333,
			scale: [2.002, 4.566, 2.064]
		}, {
			position: [2.291, -.756, -2.621],
			rotation: -.286,
			scale: [1.546, 1.552, 1.496]
		}, {
			position: [-2.193, -.369, -5.547],
			rotation: .516,
			scale: [3.875, 3.487, 2.986]
		}],
		lights: [{
			intensity: 50,
			position: [-16.116, 14.37, 8.208],
			scale: [.1, 2.428, 2.739]
		}, {
			intensity: 50,
			position: [-16.109, 18.021, -8.207],
			scale: [.1, 2.425, 2.751]
		}, {
			intensity: 17,
			position: [14.904, 12.198, -1.832],
			scale: [.15, 4.265, 6.331]
		}, {
			intensity: 43,
			position: [-.462, 8.89, 14.52],
			scale: [4.38, 5.441, .088]
		}, {
			intensity: 20,
			position: [3.235, 11.486, -12.541],
			scale: [2.5, 2, .1]
		}, {
			intensity: 100,
			position: [0, 20, 0],
			scale: [1, .1, 1]
		}]
	},
	neutral = {
		topLight: {
			intensity: 400,
			position: [.5, 14, .5]
		},
		room: {
			position: [0, 13.2, 0],
			scale: [31.5, 28.5, 31.5]
		},
		boxes: [{
			position: [-10.906, -1, 1.846],
			rotation: -.195,
			scale: [2.328, 7.905, 4.651]
		}, {
			position: [-5.607, -.754, -.758],
			rotation: .994,
			scale: [1.97, 1.534, 3.955]
		}, {
			position: [6.167, -.16, 7.803],
			rotation: .561,
			scale: [3.927, 6.285, 3.687]
		}, {
			position: [-2.017, .018, 6.124],
			rotation: .333,
			scale: [2.002, 4.566, 2.064]
		}, {
			position: [2.291, -.756, -2.621],
			rotation: -.286,
			scale: [1.546, 1.552, 1.496]
		}, {
			position: [-2.193, -.369, -5.547],
			rotation: .516,
			scale: [3.875, 3.487, 2.986]
		}],
		lights: [{
			intensity: 80,
			position: [-14, 10, 8],
			scale: [.1, 2.5, 2.5]
		}, {
			intensity: 80,
			position: [-14, 14, -4],
			scale: [.1, 2.5, 2.5]
		}, {
			intensity: 23,
			position: [14, 12, 0],
			scale: [.1, 5, 5]
		}, {
			intensity: 16,
			position: [0, 9, 14],
			scale: [5, 5, .1]
		}, {
			intensity: 80,
			position: [7, 8, -14],
			scale: [2.5, 2.5, .1]
		}, {
			intensity: 80,
			position: [-7, 16, -14],
			scale: [2.5, 2.5, .1]
		}, {
			intensity: 1,
			position: [0, 20, 0],
			scale: [.1, .1, .1]
		}]
	};
class EnvironmentScene extends Scene {
	constructor(name) {
		super(), this.position.y = -3.5;
		let geometry = new BoxGeometry;
		geometry.deleteAttribute("uv");
		let roomMaterial = new MeshStandardMaterial({
				metalness: 0,
				side: 1
			}),
			boxMaterial = new MeshStandardMaterial({
				metalness: 0
			}),
			data = "legacy" == name ? legacy : neutral,
			mainLight = new PointLight(16777215, data.topLight.intensity, 28, 2);
		mainLight.position.set(...data.topLight.position), this.add(mainLight);
		let room = new Mesh(geometry, roomMaterial);
		for (let box of (room.position.set(...data.room.position), room.scale.set(...data.room.scale), this.add(room), data.boxes)) {
			let box1 = new Mesh(geometry, boxMaterial);
			box1.position.set(...box.position), box1.rotation.set(0, box.rotation, 0), box1.scale.set(...box.scale), this.add(box1)
		}
		for (let light of data.lights) {
			let light1 = new Mesh(geometry, this.createAreaLightMaterial(light.intensity));
			light1.position.set(...light.position), light1.scale.set(...light.scale), this.add(light1)
		}
	}
	createAreaLightMaterial(intensity) {
		let material = new MeshBasicMaterial;
		return material.color.setScalar(intensity), material
	}
}
let HDR_FILE_RE = /\.hdr(\.js)?$/;
class TextureUtils {
	constructor(threeRenderer) {
		this.threeRenderer = threeRenderer, this.lottieLoaderUrl = "", this.withCredentials = !1, this._ldrLoader = null, this._imageLoader = null, this._hdrLoader = null, this._lottieLoader = null, this.generatedEnvironmentMap = null, this.generatedEnvironmentMapAlt = null, this.skyboxCache = new Map, this.blurMaterial = null, this.blurScene = null
	}
	get ldrLoader() {
		return null == this._ldrLoader && (this._ldrLoader = new TextureLoader), this._ldrLoader.setWithCredentials(this.withCredentials), this._ldrLoader
	}
	get imageLoader() {
		return null == this._imageLoader && (this._imageLoader = new HDRJPGLoader(this.threeRenderer)), this._imageLoader.setWithCredentials(this.withCredentials), this._imageLoader
	}
	get hdrLoader() {
		return null == this._hdrLoader && (this._hdrLoader = new RGBELoader, this._hdrLoader.setDataType(1016)), this._hdrLoader.setWithCredentials(this.withCredentials), this._hdrLoader
	}
	async getLottieLoader() {
		if (null == this._lottieLoader) {
			let {
				LottieLoader
			} = await import(this.lottieLoaderUrl);
			this._lottieLoader = new LottieLoader
		}
		return this._lottieLoader.setWithCredentials(this.withCredentials), this._lottieLoader
	}
	async loadImage(url) {
		let texture = await new Promise((resolve, reject) => this.ldrLoader.load(url, resolve, () => {}, reject));
		return texture.name = url, texture.flipY = !1, texture
	}
	async loadLottie(url, quality) {
		let loader = await this.getLottieLoader();
		loader.setQuality(quality);
		let texture = await new Promise((resolve, reject) => loader.load(url, resolve, () => {}, reject));
		return texture.name = url, texture
	}
	async loadEquirect(url, progressCallback = () => {}) {
		try {
			let isHDR = HDR_FILE_RE.test(url),
				loader = isHDR ? this.hdrLoader : this.imageLoader,
				texture = await new Promise((resolve, reject) => loader.load(url, result => {
					let {
						renderTarget
					} = result;
					if (null != renderTarget) {
						let {
							texture
						} = renderTarget;
						result.dispose(!1), resolve(texture)
					} else resolve(result)
				}, event => {
					progressCallback(event.loaded / event.total * .9)
				}, reject));
			return progressCallback(1), texture.name = url, texture.mapping = 303, isHDR || (texture.colorSpace = SRGBColorSpace), texture
		} finally {
			progressCallback && progressCallback(1)
		}
	}
	async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, progressCallback = () => {}) {
		let environmentMapLoads;
		let useAltEnvironment = "legacy" !== environmentMapUrl;
		("legacy" === environmentMapUrl || "neutral" === environmentMapUrl) && (environmentMapUrl = null), environmentMapUrl = deserializeUrl(environmentMapUrl);
		let skyboxLoads = Promise.resolve(null);
		skyboxUrl && (skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, progressCallback)), environmentMapLoads = environmentMapUrl ? this.loadEquirectFromUrl(environmentMapUrl, progressCallback) : skyboxUrl ? this.loadEquirectFromUrl(skyboxUrl, progressCallback) : useAltEnvironment ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();
		let [environmentMap, skybox] = await Promise.all([environmentMapLoads, skyboxLoads]);
		if (null == environmentMap) throw Error("Failed to load environment map.");
		return {
			environmentMap,
			skybox
		}
	}
	async loadEquirectFromUrl(url, progressCallback) {
		if (!this.skyboxCache.has(url)) {
			let skyboxMapLoads = this.loadEquirect(url, progressCallback);
			this.skyboxCache.set(url, skyboxMapLoads)
		}
		return this.skyboxCache.get(url)
	}
	async GenerateEnvironmentMap(scene, name) {
		await timePasses();
		let renderer = this.threeRenderer,
			cubeTarget = new WebGLCubeRenderTarget(256, {
				generateMipmaps: !1,
				type: 1016,
				format: 1023,
				colorSpace: LinearSRGBColorSpace,
				depthBuffer: !0
			}),
			cubeCamera = new CubeCamera(.1, 100, cubeTarget),
			generatedEnvironmentMap = cubeCamera.renderTarget.texture;
		generatedEnvironmentMap.name = name;
		let outputColorSpace = renderer.outputColorSpace,
			toneMapping = renderer.toneMapping;
		return renderer.toneMapping = 0, renderer.outputColorSpace = LinearSRGBColorSpace, cubeCamera.update(renderer, scene), this.blurCubemap(cubeTarget, .04), renderer.toneMapping = toneMapping, renderer.outputColorSpace = outputColorSpace, generatedEnvironmentMap
	}
	async loadGeneratedEnvironmentMap() {
		return null == this.generatedEnvironmentMap && (this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new EnvironmentScene("legacy"), "legacy")), this.generatedEnvironmentMap
	}
	async loadGeneratedEnvironmentMapAlt() {
		return null == this.generatedEnvironmentMapAlt && (this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new EnvironmentScene("neutral"), "neutral")), this.generatedEnvironmentMapAlt
	}
	blurCubemap(cubeTarget, sigma) {
		if (null == this.blurMaterial) {
			this.blurMaterial = this.getBlurShader(20);
			let blurMesh = new Mesh(new BoxGeometry, this.blurMaterial);
			this.blurScene = new Scene, this.blurScene.add(blurMesh)
		}
		let tempTarget = cubeTarget.clone();
		this.halfblur(cubeTarget, tempTarget, sigma, "latitudinal"), this.halfblur(tempTarget, cubeTarget, sigma, "longitudinal")
	}
	halfblur(targetIn, targetOut, sigmaRadians, direction) {
		let pixels = targetIn.width,
			radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / 39,
			sigmaPixels = sigmaRadians / radiansPerPixel,
			samples = isFinite(sigmaRadians) ? 1 + Math.floor(3 * sigmaPixels) : 20;
		samples > 20 && console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to 20`);
		let weights = [],
			sum = 0;
		for (let i = 0; i < 20; ++i) {
			let x = i / sigmaPixels,
				weight = Math.exp(-x * x / 2);
			weights.push(weight), 0 == i ? sum += weight : i < samples && (sum += 2 * weight)
		}
		for (let i = 0; i < weights.length; i++) weights[i] = weights[i] / sum;
		let blurUniforms = this.blurMaterial.uniforms;
		blurUniforms.envMap.value = targetIn.texture, blurUniforms.samples.value = samples, blurUniforms.weights.value = weights, blurUniforms.latitudinal.value = "latitudinal" === direction, blurUniforms.dTheta.value = radiansPerPixel, new CubeCamera(.1, 100, targetOut).update(this.threeRenderer, this.blurScene)
	}
	getBlurShader(maxSamples) {
		let weights = new Float32Array(maxSamples);
		return new ShaderMaterial({
			name: "SphericalGaussianBlur",
			defines: {
				n: maxSamples
			},
			uniforms: {
				envMap: {
					value: null
				},
				samples: {
					value: 1
				},
				weights: {
					value: weights
				},
				latitudinal: {
					value: !1
				},
				dTheta: {
					value: 0
				},
				poleAxis: {
					value: new Vector3(0, 1, 0)
				}
			},
			vertexShader: `
      
      varying vec3 vOutputDirection;
  
      void main() {
  
        vOutputDirection = vec3( position );
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  
      }
    `,
			fragmentShader: `
        varying vec3 vOutputDirection;
  
        uniform samplerCube envMap;
        uniform int samples;
        uniform float weights[ n ];
        uniform bool latitudinal;
        uniform float dTheta;
        uniform vec3 poleAxis;
  
        vec3 getSample( float theta, vec3 axis ) {
  
          float cosTheta = cos( theta );
          // Rodrigues' axis-angle rotation
          vec3 sampleDirection = vOutputDirection * cosTheta
            + cross( axis, vOutputDirection ) * sin( theta )
            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );
  
          return vec3( textureCube( envMap, sampleDirection ) );
  
        }
  
        void main() {
  
          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );
  
          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {
  
            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );
  
          }
  
          axis = normalize( axis );
  
          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );
  
          for ( int i = 1; i < n; i++ ) {
  
            if ( i >= samples ) {
  
              break;
  
            }
  
            float theta = dTheta * float( i );
            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );
  
          }
        }
      `,
			blending: 0,
			depthTest: !1,
			depthWrite: !1,
			side: 1
		})
	}
	async dispose() {
		for (let [, promise] of this.skyboxCache)(await promise).dispose();
		null != this.generatedEnvironmentMap && ((await this.generatedEnvironmentMap).dispose(), this.generatedEnvironmentMap = null), null != this.generatedEnvironmentMapAlt && ((await this.generatedEnvironmentMapAlt).dispose(), this.generatedEnvironmentMapAlt = null), null != this.blurMaterial && this.blurMaterial.dispose()
	}
}
let SCALE_STEPS = [1, .79, .62, .5, .4, .31, .25],
	DEFAULT_POWER_PREFERENCE = "high-performance";
class Renderer extends EventDispatcher {
	constructor(options) {
		super(), this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance), this.width = 0, this.height = 0, this.dpr = 1, this.scenes = new Set, this.multipleScenesVisible = !1, this.lastTick = performance.now(), this.renderedLastFrame = !1, this.scaleStep = 0, this.lastStep = 3, this.avgFrameDuration = 50, this.onWebGLContextLost = event => {
			this.dispatchEvent({
				type: "contextlost",
				sourceEvent: event
			})
		}, this.onWebGLContextRestored = () => {
			var _a;
			for (let scene of (null === (_a = this.textureUtils) || void 0 === _a || _a.dispose(), this.textureUtils = new TextureUtils(this.threeRenderer), this.scenes)) scene.element[$updateEnvironment]()
		}, this.dpr = resolveDpr(), this.canvas3D = document.createElement("canvas"), this.canvas3D.id = "webgl-canvas", this.canvas3D.classList.add("show"), ShaderChunk.tonemapping_pars_fragment = ShaderChunk.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", `
      float startCompression = 0.8 - 0.04;
      float desaturation = 0.15;
      vec3 CustomToneMapping( vec3 color ) {
        color *= toneMappingExposure;

        float x = min(color.r, min(color.g, color.b));
        float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
        color -= offset;

        float peak = max(color.r, max(color.g, color.b));
        if (peak < startCompression) return color;

        float d = 1. - startCompression;
        float newPeak = 1. - d * d / (peak + d - startCompression);
        color *= newPeak / peak;

        float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
        return mix(color, vec3(1, 1, 1), g);
      }`);
		try {
			this.threeRenderer = new WebGLRenderer({
				canvas: this.canvas3D,
				alpha: !0,
				antialias: !0,
				powerPreference: options.powerPreference,
				preserveDrawingBuffer: !0
			}), this.threeRenderer.autoClear = !0, this.threeRenderer.setPixelRatio(1), this.threeRenderer.debug = {
				checkShaderErrors: !!options.debug,
				onShaderError: null
			}, this.threeRenderer.toneMapping = 4
		} catch (error) {
			console.warn(error)
		}
		this.arRenderer = new ARRenderer(this), this.textureUtils = this.canRender ? new TextureUtils(this.threeRenderer) : null, CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer), this.canvas3D.addEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.addEventListener("webglcontextrestored", this.onWebGLContextRestored), this.updateRendererSize()
	}
	static get singleton() {
		return this._singleton
	}
	static resetSingleton() {
		let elements = this._singleton.dispose();
		for (let element of elements) element.disconnectedCallback();
		for (let element of (this._singleton = new Renderer({
				powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,
				debug: isDebugMode()
			}), elements)) element.connectedCallback()
	}
	get canRender() {
		return null != this.threeRenderer
	}
	get scaleFactor() {
		return SCALE_STEPS[this.scaleStep]
	}
	set minScale(scale) {
		let i = 1;
		for (; i < SCALE_STEPS.length && !(SCALE_STEPS[i] < scale);) ++i;
		this.lastStep = i - 1
	}
	registerScene(scene) {
		this.scenes.add(scene), scene.forceRescale();
		let size = new Vector2;
		this.threeRenderer.getSize(size), scene.canvas.width = size.x, scene.canvas.height = size.y, this.canRender && this.scenes.size > 0 && this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame))
	}
	unregisterScene(scene) {
		this.scenes.delete(scene), this.canvas3D.parentElement === scene.canvas.parentElement && scene.canvas.parentElement.removeChild(this.canvas3D), this.canRender && 0 === this.scenes.size && this.threeRenderer.setAnimationLoop(null)
	}
	displayCanvas(scene) {
		return this.multipleScenesVisible ? scene.element[$canvas] : this.canvas3D
	}
	countVisibleScenes() {
		let {
			canvas3D
		} = this, visibleScenes = 0, canvas3DScene = null;
		for (let scene of this.scenes) {
			let {
				element
			} = scene;
			element.modelIsVisible && null == scene.externalRenderer && ++visibleScenes, canvas3D.parentElement === scene.canvas.parentElement && (canvas3DScene = scene)
		}
		let multipleScenesVisible = visibleScenes > 1;
		if (null != canvas3DScene) {
			let newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible,
				disappearing = !canvas3DScene.element.modelIsVisible;
			if (newlyMultiple || disappearing) {
				let {
					width,
					height
				} = this.sceneSize(canvas3DScene);
				this.copyPixels(canvas3DScene, width, height), canvas3D.parentElement.removeChild(canvas3D)
			}
		}
		this.multipleScenesVisible = multipleScenesVisible
	}
	updateRendererSize() {
		var _a;
		let dpr = resolveDpr();
		if (dpr !== this.dpr)
			for (let scene of this.scenes) {
				let {
					element
				} = scene;
				element[$updateSize](element.getBoundingClientRect())
			}
		let width = 0,
			height = 0;
		for (let scene of this.scenes) width = Math.max(width, scene.width), height = Math.max(height, scene.height);
		if (width !== this.width || height !== this.height || dpr !== this.dpr)
			for (let scene of (this.width = width, this.height = height, this.dpr = dpr, width = Math.ceil(width * dpr), height = Math.ceil(height * dpr), this.canRender && this.threeRenderer.setSize(width, height, !1), this.scenes)) {
				let {
					canvas
				} = scene;
				canvas.width = width, canvas.height = height, scene.forceRescale(), null === (_a = scene.effectRenderer) || void 0 === _a || _a.setSize(width, height)
			}
	}
	updateRendererScale(delta) {
		let scaleStep = this.scaleStep;
		this.avgFrameDuration += clamp(.2 * (delta - this.avgFrameDuration), -5, 5), this.avgFrameDuration > 60 ? ++this.scaleStep : this.avgFrameDuration < 40 && this.scaleStep > 0 && --this.scaleStep, this.scaleStep = Math.min(this.scaleStep, this.lastStep), scaleStep !== this.scaleStep && (this.avgFrameDuration = 50)
	}
	shouldRender(scene) {
		if (scene.shouldRender()) scene.scaleStep != this.scaleStep && (scene.scaleStep = this.scaleStep, this.rescaleCanvas(scene));
		else {
			if (0 == scene.scaleStep) return !1;
			scene.scaleStep = 0, this.rescaleCanvas(scene)
		}
		return !0
	}
	rescaleCanvas(scene) {
		let scale = SCALE_STEPS[scene.scaleStep],
			width = Math.ceil(this.width / scale),
			height = Math.ceil(this.height / scale),
			{
				style
			} = scene.canvas;
		style.width = `${width}px`, style.height = `${height}px`, this.canvas3D.style.width = `${width}px`, this.canvas3D.style.height = `${height}px`;
		let renderedDpr = this.dpr * scale,
			reason = scale < 1 ? "GPU throttling" : this.dpr !== window.devicePixelRatio ? "No meta viewport tag" : "";
		scene.element.dispatchEvent(new CustomEvent("render-scale", {
			detail: {
				reportedDpr: window.devicePixelRatio,
				renderedDpr: renderedDpr,
				minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],
				pixelWidth: Math.ceil(scene.width * renderedDpr),
				pixelHeight: Math.ceil(scene.height * renderedDpr),
				reason: reason
			}
		}))
	}
	sceneSize(scene) {
		let {
			dpr
		} = this, scaleFactor = SCALE_STEPS[scene.scaleStep];
		return {
			width: Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width),
			height: Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height)
		}
	}
	copyPixels(scene, width, height) {
		let context2D = scene.context;
		if (null == context2D) {
			console.log("could not acquire 2d context");
			return
		}
		context2D.clearRect(0, 0, width, height), context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height), scene.canvas.classList.add("show")
	}
	orderedScenes() {
		let scenes = [];
		for (let visible of [!1, !0])
			for (let scene of this.scenes) scene.element.modelIsVisible === visible && scenes.push(scene);
		return scenes
	}
	get isPresenting() {
		return this.arRenderer.isPresenting
	}
	preRender(scene, t, delta) {
		let {
			element,
			exposure,
			toneMapping
		} = scene;
		element[$tick](t, delta);
		let exposureIsNumber = "number" == typeof exposure && !Number.isNaN(exposure),
			env = element.environmentImage,
			sky = element.skyboxImage;
		this.threeRenderer.toneMappingExposure = (exposureIsNumber ? exposure : 1) * (5 !== toneMapping || "neutral" !== env && "legacy" !== env && (env || sky) ? 1 : 1.3)
	}
	render(t, frame) {
		if (null != frame) {
			this.arRenderer.onWebXRFrame(t, frame);
			return
		}
		let delta = t - this.lastTick;
		if (this.lastTick = t, !this.canRender || this.isPresenting) return;
		this.countVisibleScenes(), this.updateRendererSize(), this.renderedLastFrame && (this.updateRendererScale(delta), this.renderedLastFrame = !1);
		let {
			canvas3D
		} = this;
		for (let scene of this.orderedScenes()) {
			let {
				element
			} = scene;
			if (!element.loaded || !element.modelIsVisible && scene.renderCount > 0 || (this.preRender(scene, t, delta), !this.shouldRender(scene))) continue;
			if (null != scene.externalRenderer) {
				let camera = scene.getCamera();
				camera.updateMatrix();
				let {
					matrix,
					projectionMatrix
				} = camera, viewMatrix = matrix.elements.slice(), target = scene.getTarget();
				viewMatrix[12] += target.x, viewMatrix[13] += target.y, viewMatrix[14] += target.z, scene.externalRenderer.render({
					viewMatrix: viewMatrix,
					projectionMatrix: projectionMatrix.elements
				});
				continue
			}
			if (!element.modelIsVisible && !this.multipleScenesVisible)
				for (let visibleScene of this.scenes) visibleScene.element.modelIsVisible && visibleScene.queueRender();
			let {
				width,
				height
			} = this.sceneSize(scene);
			scene.renderShadow(this.threeRenderer), this.threeRenderer.setRenderTarget(null), this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height), null != scene.effectRenderer ? scene.effectRenderer.render(delta) : (this.threeRenderer.autoClear = !0, this.threeRenderer.toneMapping = scene.toneMapping, this.threeRenderer.render(scene, scene.camera)), this.multipleScenesVisible || !scene.element.modelIsVisible && 0 === scene.renderCount ? this.copyPixels(scene, width, height) : canvas3D.parentElement !== scene.canvas.parentElement && (scene.canvas.parentElement.appendChild(canvas3D), scene.canvas.classList.remove("show")), scene.hasRendered(), ++scene.renderCount, this.renderedLastFrame = !0
		}
	}
	dispose() {
		null != this.textureUtils && this.textureUtils.dispose(), null != this.threeRenderer && this.threeRenderer.dispose(), this.textureUtils = null, this.threeRenderer = null;
		let elements = [];
		for (let scene of this.scenes) elements.push(scene.element);
		return this.canvas3D.removeEventListener("webglcontextlost", this.onWebGLContextLost), this.canvas3D.removeEventListener("webglcontextrestored", this.onWebGLContextRestored), elements
	}
}
Renderer._singleton = new Renderer({
	powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,
	debug: isDebugMode()
});
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let $correlatedObjects = Symbol("correlatedObjects"),
	$onUpdate$1 = Symbol("onUpdate");
class ThreeDOMElement {
	constructor(onUpdate, correlatedObjects = null) {
		this[$onUpdate$1] = onUpdate, this[$correlatedObjects] = correlatedObjects
	}
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let quadMaterial = new MeshBasicMaterial,
	quad = new PlaneGeometry(2, 2),
	adhocNum = 0,
	$threeTexture$2 = Symbol("threeTexture"),
	$threeTextures$1 = Symbol("threeTextures");
class Image$1 extends ThreeDOMElement {
	get[$threeTexture$2]() {
		var _a;
		return null === (_a = this[$correlatedObjects]) || void 0 === _a ? void 0 : _a.values().next().value
	}
	get[$threeTextures$1]() {
		return this[$correlatedObjects]
	}
	constructor(onUpdate, texture) {
		super(onUpdate, new Set(texture ? [texture] : [])), this[$threeTexture$2].image.src || (this[$threeTexture$2].image.src = texture.name ? texture.name : "adhoc_image" + adhocNum++), this[$threeTexture$2].image.name || (this[$threeTexture$2].image.name = texture && texture.image && texture.image.src ? texture.image.src.split("/").pop() : "adhoc_image")
	}
	get name() {
		return this[$threeTexture$2].image.name || ""
	}
	get uri() {
		return this[$threeTexture$2].image.src
	}
	get bufferView() {
		return this[$threeTexture$2].image.bufferView
	}
	get element() {
		let texture = this[$threeTexture$2];
		if (texture && (texture.isCanvasTexture || texture.isVideoTexture)) return texture.image
	}
	get animation() {
		let texture = this[$threeTexture$2];
		if (texture && texture.isCanvasTexture && texture.animation) return texture.animation
	}
	get type() {
		return null != this.uri ? "external" : "embedded"
	}
	set name(name) {
		for (let texture of this[$threeTextures$1]) texture.image.name = name
	}
	update() {
		let texture = this[$threeTexture$2];
		texture && texture.isCanvasTexture && !texture.animation && (this[$threeTexture$2].needsUpdate = !0, this[$onUpdate$1]())
	}
	async createThumbnail(width, height) {
		let scene = new Scene;
		quadMaterial.map = this[$threeTexture$2];
		let mesh = new Mesh(quad, quadMaterial);
		scene.add(mesh);
		let camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1),
			{
				threeRenderer
			} = Renderer.singleton,
			renderTarget = new WebGLRenderTarget(width, height);
		threeRenderer.setRenderTarget(renderTarget), threeRenderer.render(scene, camera), threeRenderer.setRenderTarget(null);
		let buffer = new Uint8Array(width * height * 4);
		threeRenderer.readRenderTargetPixels(renderTarget, 0, 0, width, height, buffer), blobCanvas.width = width, blobCanvas.height = height;
		let blobContext = blobCanvas.getContext("2d"),
			imageData = blobContext.createImageData(width, height);
		return imageData.data.set(buffer), blobContext.putImageData(imageData, 0, 0), new Promise(async (resolve, reject) => {
			blobCanvas.toBlob(blob => {
				if (!blob) return reject("Failed to capture thumbnail.");
				resolve(URL.createObjectURL(blob))
			}, "image/png")
		})
	}
}(Filter1 = Filter || (Filter = {}))[Filter1.Nearest = 9728] = "Nearest", Filter1[Filter1.Linear = 9729] = "Linear", Filter1[Filter1.NearestMipmapNearest = 9984] = "NearestMipmapNearest", Filter1[Filter1.LinearMipmapNearest = 9985] = "LinearMipmapNearest", Filter1[Filter1.NearestMipmapLinear = 9986] = "NearestMipmapLinear", Filter1[Filter1.LinearMipmapLinear = 9987] = "LinearMipmapLinear", (Wrap1 = Wrap || (Wrap = {}))[Wrap1.ClampToEdge = 33071] = "ClampToEdge", Wrap1[Wrap1.MirroredRepeat = 33648] = "MirroredRepeat", Wrap1[Wrap1.Repeat = 10497] = "Repeat";
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let wrapModeToWrapping = new Map([
		[Wrap.Repeat, 1e3],
		[Wrap.ClampToEdge, 1001],
		[Wrap.MirroredRepeat, 1002]
	]),
	wrappingToWrapMode = new Map([
		[1e3, Wrap.Repeat],
		[1001, Wrap.ClampToEdge],
		[1002, Wrap.MirroredRepeat]
	]),
	minFilterToMinification = new Map([
		[Filter.Nearest, NearestFilter],
		[Filter.Linear, 1006],
		[Filter.NearestMipmapNearest, 1004],
		[Filter.LinearMipmapNearest, 1007],
		[Filter.NearestMipmapLinear, 1005],
		[Filter.LinearMipmapLinear, 1008]
	]),
	minificationToMinFilter = new Map([
		[NearestFilter, Filter.Nearest],
		[1006, Filter.Linear],
		[1004, Filter.NearestMipmapNearest],
		[1007, Filter.LinearMipmapNearest],
		[1005, Filter.NearestMipmapLinear],
		[1008, Filter.LinearMipmapLinear]
	]),
	magFilterToMagnification = new Map([
		[Filter.Nearest, NearestFilter],
		[Filter.Linear, 1006]
	]),
	magnificationToMagFilter = new Map([
		[NearestFilter, Filter.Nearest],
		[1006, Filter.Linear]
	]),
	isMinFilter = value => minificationToMinFilter.has(value),
	isMagFilter = value => magnificationToMagFilter.has(value),
	isWrapping = value => wrappingToWrapMode.has(value),
	isValidSamplerValue = (property, value) => {
		switch (property) {
			case "minFilter":
				return isMinFilter(value);
			case "magFilter":
				return isMagFilter(value);
			case "wrapS":
			case "wrapT":
				return isWrapping(value);
			case "rotation":
			case "repeat":
			case "offset":
				return !0;
			default:
				throw Error(`Cannot configure property "${property}" on Sampler`)
		}
	},
	$threeTexture$1 = Symbol("threeTexture"),
	$threeTextures = Symbol("threeTextures"),
	$setProperty = Symbol("setProperty");
class Sampler extends ThreeDOMElement {
	get[$threeTexture$1]() {
		var _a;
		return null === (_a = this[$correlatedObjects]) || void 0 === _a ? void 0 : _a.values().next().value
	}
	get[$threeTextures]() {
		return this[$correlatedObjects]
	}
	constructor(onUpdate, texture) {
		super(onUpdate, new Set(texture ? [texture] : []))
	}
	get name() {
		return this[$threeTexture$1].name || ""
	}
	get minFilter() {
		return minificationToMinFilter.get(this[$threeTexture$1].minFilter)
	}
	get magFilter() {
		return magnificationToMagFilter.get(this[$threeTexture$1].magFilter)
	}
	get wrapS() {
		return wrappingToWrapMode.get(this[$threeTexture$1].wrapS)
	}
	get wrapT() {
		return wrappingToWrapMode.get(this[$threeTexture$1].wrapT)
	}
	get rotation() {
		return this[$threeTexture$1].rotation
	}
	get scale() {
		return toVector2D(this[$threeTexture$1].repeat)
	}
	get offset() {
		return toVector2D(this[$threeTexture$1].offset)
	}
	setMinFilter(filter) {
		this[$setProperty]("minFilter", minFilterToMinification.get(filter))
	}
	setMagFilter(filter) {
		this[$setProperty]("magFilter", magFilterToMagnification.get(filter))
	}
	setWrapS(mode) {
		this[$setProperty]("wrapS", wrapModeToWrapping.get(mode))
	}
	setWrapT(mode) {
		this[$setProperty]("wrapT", wrapModeToWrapping.get(mode))
	}
	setRotation(rotation) {
		null == rotation && (rotation = 0), this[$setProperty]("rotation", rotation)
	}
	setScale(scale) {
		null == scale && (scale = {
			u: 1,
			v: 1
		}), this[$setProperty]("repeat", new Vector2(scale.u, scale.v))
	}
	setOffset(offset) {
		null == offset && (offset = {
			u: 0,
			v: 0
		}), this[$setProperty]("offset", new Vector2(offset.u, offset.v))
	} [$setProperty](property, value) {
		if (isValidSamplerValue(property, value))
			for (let texture of this[$threeTextures]) texture[property] = value, texture.needsUpdate = !0;
		this[$onUpdate$1]()
	}
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let $image = Symbol("image"),
	$sampler = Symbol("sampler"),
	$threeTexture = Symbol("threeTexture");
class Texture extends ThreeDOMElement {
	constructor(onUpdate, threeTexture) {
		super(onUpdate, new Set(threeTexture ? [threeTexture] : [])), this[$sampler] = new Sampler(onUpdate, threeTexture), this[$image] = new Image$1(onUpdate, threeTexture)
	}
	get[$threeTexture]() {
		var _a;
		return null === (_a = this[$correlatedObjects]) || void 0 === _a ? void 0 : _a.values().next().value
	}
	get name() {
		return this[$threeTexture].name || ""
	}
	set name(name) {
		for (let texture of this[$correlatedObjects]) texture.name = name
	}
	get sampler() {
		return this[$sampler]
	}
	get source() {
		return this[$image]
	}
}
let $texture = Symbol("texture"),
	$transform = Symbol("transform"),
	$materials$1 = Symbol("materials"),
	$usage = Symbol("usage"),
	$onUpdate = Symbol("onUpdate"),
	$activeVideo = Symbol("activeVideo");
(TextureUsage1 = TextureUsage || (TextureUsage = {}))[TextureUsage1.Base = 0] = "Base", TextureUsage1[TextureUsage1.MetallicRoughness = 1] = "MetallicRoughness", TextureUsage1[TextureUsage1.Normal = 2] = "Normal", TextureUsage1[TextureUsage1.Occlusion = 3] = "Occlusion", TextureUsage1[TextureUsage1.Emissive = 4] = "Emissive", TextureUsage1[TextureUsage1.Clearcoat = 5] = "Clearcoat", TextureUsage1[TextureUsage1.ClearcoatRoughness = 6] = "ClearcoatRoughness", TextureUsage1[TextureUsage1.ClearcoatNormal = 7] = "ClearcoatNormal", TextureUsage1[TextureUsage1.SheenColor = 8] = "SheenColor", TextureUsage1[TextureUsage1.SheenRoughness = 9] = "SheenRoughness", TextureUsage1[TextureUsage1.Transmission = 10] = "Transmission", TextureUsage1[TextureUsage1.Thickness = 11] = "Thickness", TextureUsage1[TextureUsage1.Specular = 12] = "Specular", TextureUsage1[TextureUsage1.SpecularColor = 13] = "SpecularColor", TextureUsage1[TextureUsage1.Iridescence = 14] = "Iridescence", TextureUsage1[TextureUsage1.IridescenceThickness = 15] = "IridescenceThickness", TextureUsage1[TextureUsage1.Anisotropy = 16] = "Anisotropy";
class TextureInfo {
	constructor(onUpdate, usage, threeTexture, material) {
		this[_a$4] = null, this[_b$4] = {
			rotation: 0,
			scale: new Vector2(1, 1),
			offset: new Vector2(0, 0)
		}, this[_c$2] = !1, threeTexture && (this[$transform].rotation = threeTexture.rotation, this[$transform].scale.copy(threeTexture.repeat), this[$transform].offset.copy(threeTexture.offset), this[$texture] = new Texture(onUpdate, threeTexture)), this[$onUpdate] = onUpdate, this[$materials$1] = material, this[$usage] = usage
	}
	get texture() {
		return this[$texture]
	}
	setTexture(texture) {
		var _d, _e;
		let threeTexture = null != texture ? texture.source[$threeTexture$2] : null,
			oldTexture = null === (_d = this[$texture]) || void 0 === _d ? void 0 : _d.source[$threeTexture$2];
		if (null != oldTexture && oldTexture.isVideoTexture ? this[$activeVideo] = !1 : (null === (_e = this[$texture]) || void 0 === _e ? void 0 : _e.source.animation) && this[$texture].source.animation.removeEventListener("enterFrame", this[$onUpdate]), this[$texture] = texture, null != threeTexture && threeTexture.isVideoTexture) {
			let element = threeTexture.image;
			if (this[$activeVideo] = !0, null != element.requestVideoFrameCallback) {
				let update = () => {
					this[$activeVideo] && (this[$onUpdate](), element.requestVideoFrameCallback(update))
				};
				element.requestVideoFrameCallback(update)
			} else {
				let update = () => {
					this[$activeVideo] && (this[$onUpdate](), requestAnimationFrame(update))
				};
				requestAnimationFrame(update)
			}
		} else(null == texture ? void 0 : texture.source.animation) != null && texture.source.animation.addEventListener("enterFrame", this[$onUpdate]);
		let colorSpace1 = SRGBColorSpace;
		if (this[$materials$1])
			for (let material of this[$materials$1]) {
				switch (this[$usage]) {
					case TextureUsage.Base:
						material.map = threeTexture;
						break;
					case TextureUsage.MetallicRoughness:
						colorSpace1 = LinearSRGBColorSpace, material.metalnessMap = threeTexture, material.roughnessMap = threeTexture;
						break;
					case TextureUsage.Normal:
						colorSpace1 = LinearSRGBColorSpace, material.normalMap = threeTexture;
						break;
					case TextureUsage.Occlusion:
						colorSpace1 = LinearSRGBColorSpace, material.aoMap = threeTexture;
						break;
					case TextureUsage.Emissive:
						material.emissiveMap = threeTexture;
						break;
					case TextureUsage.Clearcoat:
						material.clearcoatMap = threeTexture;
						break;
					case TextureUsage.ClearcoatRoughness:
						material.clearcoatRoughnessMap = threeTexture;
						break;
					case TextureUsage.ClearcoatNormal:
						material.clearcoatNormalMap = threeTexture;
						break;
					case TextureUsage.SheenColor:
						material.sheenColorMap = threeTexture;
						break;
					case TextureUsage.SheenRoughness:
						material.sheenRoughnessMap = threeTexture;
						break;
					case TextureUsage.Transmission:
						material.transmissionMap = threeTexture;
						break;
					case TextureUsage.Thickness:
						material.thicknessMap = threeTexture;
						break;
					case TextureUsage.Specular:
						material.specularIntensityMap = threeTexture;
						break;
					case TextureUsage.SpecularColor:
						material.specularColorMap = threeTexture;
						break;
					case TextureUsage.Iridescence:
						material.iridescenceMap = threeTexture;
						break;
					case TextureUsage.IridescenceThickness:
						material.iridescenceThicknessMap = threeTexture;
						break;
					case TextureUsage.Anisotropy:
						material.anisotropyMap = threeTexture
				}
				material.needsUpdate = !0
			}
		threeTexture && (threeTexture.colorSpace = colorSpace1, threeTexture.rotation = this[$transform].rotation, threeTexture.repeat = this[$transform].scale, threeTexture.offset = this[$transform].offset), this[$onUpdate]()
	}
}
_a$4 = $texture, _b$4 = $transform, _c$2 = $activeVideo;
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let $threeMaterial = Symbol("threeMaterial"),
	$threeMaterials = Symbol("threeMaterials"),
	$baseColorTexture = Symbol("baseColorTexture"),
	$metallicRoughnessTexture = Symbol("metallicRoughnessTexture");
class PBRMetallicRoughness extends ThreeDOMElement {
	constructor(onUpdate, correlatedMaterials) {
		super(onUpdate, correlatedMaterials);
		let {
			map,
			metalnessMap
		} = correlatedMaterials.values().next().value;
		this[$baseColorTexture] = new TextureInfo(onUpdate, TextureUsage.Base, map, correlatedMaterials), this[$metallicRoughnessTexture] = new TextureInfo(onUpdate, TextureUsage.MetallicRoughness, metalnessMap, correlatedMaterials)
	}
	get[$threeMaterials]() {
		return this[$correlatedObjects]
	}
	get[$threeMaterial]() {
		var _a;
		return null === (_a = this[$correlatedObjects]) || void 0 === _a ? void 0 : _a.values().next().value
	}
	get baseColorFactor() {
		let rgba = [0, 0, 0, this[$threeMaterial].opacity];
		return this[$threeMaterial].color.toArray(rgba), rgba
	}
	get metallicFactor() {
		return this[$threeMaterial].metalness
	}
	get roughnessFactor() {
		return this[$threeMaterial].roughness
	}
	get baseColorTexture() {
		return this[$baseColorTexture]
	}
	get metallicRoughnessTexture() {
		return this[$metallicRoughnessTexture]
	}
	setBaseColorFactor(rgba) {
		let color = new Color;
		for (let material of (rgba instanceof Array ? color.fromArray(rgba) : color.set(rgba), this[$threeMaterials])) material.color.set(color), rgba instanceof Array ? material.opacity = rgba[3] : (rgba = [0, 0, 0, material.opacity], color.toArray(rgba));
		this[$onUpdate$1]()
	}
	setMetallicFactor(value) {
		for (let material of this[$threeMaterials]) material.metalness = value;
		this[$onUpdate$1]()
	}
	setRoughnessFactor(value) {
		for (let material of this[$threeMaterials]) material.roughness = value;
		this[$onUpdate$1]()
	}
}
let $pbrMetallicRoughness = Symbol("pbrMetallicRoughness"),
	$normalTexture = Symbol("normalTexture"),
	$occlusionTexture = Symbol("occlusionTexture"),
	$emissiveTexture = Symbol("emissiveTexture"),
	$backingThreeMaterial = Symbol("backingThreeMaterial"),
	$applyAlphaCutoff = Symbol("applyAlphaCutoff"),
	$getAlphaMode = Symbol("getAlphaMode"),
	$lazyLoadGLTFInfo = Symbol("lazyLoadGLTFInfo"),
	$initialize = Symbol("initialize"),
	$getLoadedMaterial = Symbol("getLoadedMaterial"),
	$ensureMaterialIsLoaded = Symbol("ensureMaterialIsLoaded"),
	$gltfIndex = Symbol("gltfIndex"),
	$setActive = Symbol("setActive"),
	$variantIndices = Symbol("variantIndices"),
	$isActive = Symbol("isActive"),
	$variantSet = Symbol("variantSet"),
	$modelVariants = Symbol("modelVariants"),
	$name = Symbol("name"),
	$pbrTextures = Symbol("pbrTextures");
class Material extends ThreeDOMElement {
	constructor(onUpdate, gltfIndex, isActive, modelVariants, correlatedMaterials, name, lazyLoadInfo) {
		super(onUpdate, correlatedMaterials), this[_a$3] = new Set, this[_b$3] = new Map, this[$gltfIndex] = gltfIndex, this[$isActive] = isActive, this[$modelVariants] = modelVariants, this[$name] = name, null == lazyLoadInfo ? this[$initialize]() : this[$lazyLoadGLTFInfo] = lazyLoadInfo
	}
	get[(_a$3 = $variantSet, _b$3 = $pbrTextures, $backingThreeMaterial)]() {
		return this[$correlatedObjects].values().next().value
	} [$initialize]() {
		let onUpdate = this[$onUpdate$1],
			correlatedMaterials = this[$correlatedObjects];
		this[$pbrMetallicRoughness] = new PBRMetallicRoughness(onUpdate, correlatedMaterials);
		let {
			normalMap,
			aoMap,
			emissiveMap
		} = correlatedMaterials.values().next().value;
		this[$normalTexture] = new TextureInfo(onUpdate, TextureUsage.Normal, normalMap, correlatedMaterials), this[$occlusionTexture] = new TextureInfo(onUpdate, TextureUsage.Occlusion, aoMap, correlatedMaterials), this[$emissiveTexture] = new TextureInfo(onUpdate, TextureUsage.Emissive, emissiveMap, correlatedMaterials);
		let createTextureInfo = usage => {
			this[$pbrTextures].set(usage, new TextureInfo(onUpdate, usage, null, correlatedMaterials))
		};
		createTextureInfo(TextureUsage.Clearcoat), createTextureInfo(TextureUsage.ClearcoatRoughness), createTextureInfo(TextureUsage.ClearcoatNormal), createTextureInfo(TextureUsage.SheenColor), createTextureInfo(TextureUsage.SheenRoughness), createTextureInfo(TextureUsage.Transmission), createTextureInfo(TextureUsage.Thickness), createTextureInfo(TextureUsage.Specular), createTextureInfo(TextureUsage.SpecularColor), createTextureInfo(TextureUsage.Iridescence), createTextureInfo(TextureUsage.IridescenceThickness), createTextureInfo(TextureUsage.Anisotropy)
	}
	async [$getLoadedMaterial]() {
		if (null != this[$lazyLoadGLTFInfo]) {
			let {
				set,
				material
			} = await this[$lazyLoadGLTFInfo].doLazyLoad();
			return this[$correlatedObjects] = set, this[$initialize](), this[$lazyLoadGLTFInfo] = void 0, this.ensureLoaded = async () => {}, material
		}
		return this[$correlatedObjects].values().next().value
	}
	colorFromRgb(rgb) {
		let color = new Color;
		return rgb instanceof Array ? color.fromArray(rgb) : color.set(rgb), color
	} [$ensureMaterialIsLoaded]() {
		if (null != this[$lazyLoadGLTFInfo]) throw Error(`Material "${this.name}" has not been loaded, call 'await
    myMaterial.ensureLoaded()' before using an unloaded material.`)
	}
	async ensureLoaded() {
		await this[$getLoadedMaterial]()
	}
	get isLoaded() {
		return null == this[$lazyLoadGLTFInfo]
	}
	get isActive() {
		return this[$isActive]
	} [$setActive](isActive) {
		this[$isActive] = isActive
	}
	get name() {
		return this[$name] || ""
	}
	set name(name) {
		if (this[$name] = name, null != this[$correlatedObjects])
			for (let threeMaterial of this[$correlatedObjects]) threeMaterial.name = name
	}
	get pbrMetallicRoughness() {
		return this[$ensureMaterialIsLoaded](), this[$pbrMetallicRoughness]
	}
	get normalTexture() {
		return this[$ensureMaterialIsLoaded](), this[$normalTexture]
	}
	get occlusionTexture() {
		return this[$ensureMaterialIsLoaded](), this[$occlusionTexture]
	}
	get emissiveTexture() {
		return this[$ensureMaterialIsLoaded](), this[$emissiveTexture]
	}
	get emissiveFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].emissive.toArray()
	}
	get index() {
		return this[$gltfIndex]
	} [$variantIndices]() {
		return this[$variantSet]
	}
	hasVariant(name) {
		let variantData = this[$modelVariants].get(name);
		return null != variantData && this[$variantSet].has(variantData.index)
	}
	setEmissiveFactor(rgb) {
		this[$ensureMaterialIsLoaded]();
		let color = this.colorFromRgb(rgb);
		for (let material of this[$correlatedObjects]) material.emissive.set(color);
		this[$onUpdate$1]()
	} [$getAlphaMode]() {
		return this[$backingThreeMaterial].transparent ? "BLEND" : this[$backingThreeMaterial].alphaTest > 0 ? "MASK" : "OPAQUE"
	} [$applyAlphaCutoff]() {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) "MASK" === this[$getAlphaMode]() ? void 0 == material.alphaTest && (material.alphaTest = .5) : material.alphaTest = void 0, material.needsUpdate = !0
	}
	setAlphaCutoff(cutoff) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.alphaTest = cutoff, material.needsUpdate = !0;
		this[$applyAlphaCutoff](), this[$onUpdate$1]()
	}
	getAlphaCutoff() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].alphaTest
	}
	setDoubleSided(doubleSided) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.side = doubleSided ? 2 : 0, material.needsUpdate = !0;
		this[$onUpdate$1]()
	}
	getDoubleSided() {
		return this[$ensureMaterialIsLoaded](), 2 == this[$backingThreeMaterial].side
	}
	setAlphaMode(alphaMode) {
		this[$ensureMaterialIsLoaded]();
		let enableTransparency = (material, enabled) => {
			material.transparent = enabled, material.depthWrite = !enabled
		};
		for (let material of this[$correlatedObjects]) enableTransparency(material, "BLEND" === alphaMode), "MASK" === alphaMode ? material.alphaTest = .5 : material.alphaTest = void 0, material.needsUpdate = !0;
		this[$onUpdate$1]()
	}
	getAlphaMode() {
		return this[$ensureMaterialIsLoaded](), this[$getAlphaMode]()
	}
	get emissiveStrength() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].emissiveIntensity
	}
	setEmissiveStrength(emissiveStrength) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.emissiveIntensity = emissiveStrength;
		this[$onUpdate$1]()
	}
	get clearcoatFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].clearcoat
	}
	get clearcoatRoughnessFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].clearcoatRoughness
	}
	get clearcoatTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.Clearcoat)
	}
	get clearcoatRoughnessTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.ClearcoatRoughness)
	}
	get clearcoatNormalTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.ClearcoatNormal)
	}
	get clearcoatNormalScale() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].clearcoatNormalScale.x
	}
	setClearcoatFactor(clearcoatFactor) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.clearcoat = clearcoatFactor;
		this[$onUpdate$1]()
	}
	setClearcoatRoughnessFactor(clearcoatRoughnessFactor) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.clearcoatRoughness = clearcoatRoughnessFactor;
		this[$onUpdate$1]()
	}
	setClearcoatNormalScale(clearcoatNormalScale) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.clearcoatNormalScale = new Vector2(clearcoatNormalScale, clearcoatNormalScale);
		this[$onUpdate$1]()
	}
	get ior() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].ior
	}
	setIor(ior) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.ior = ior;
		this[$onUpdate$1]()
	}
	get sheenColorFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].sheenColor.toArray()
	}
	get sheenColorTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.SheenColor)
	}
	get sheenRoughnessFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].sheenRoughness
	}
	get sheenRoughnessTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.SheenRoughness)
	}
	setSheenColorFactor(rgb) {
		this[$ensureMaterialIsLoaded]();
		let color = this.colorFromRgb(rgb);
		for (let material of this[$correlatedObjects]) material.sheenColor.set(color), material.sheen = 1;
		this[$onUpdate$1]()
	}
	setSheenRoughnessFactor(roughness) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.sheenRoughness = roughness, material.sheen = 1;
		this[$onUpdate$1]()
	}
	get transmissionFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].transmission
	}
	get transmissionTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.Transmission)
	}
	setTransmissionFactor(transmission) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.transmission = transmission;
		this[$onUpdate$1]()
	}
	get thicknessFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].thickness
	}
	get thicknessTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.Thickness)
	}
	get attenuationDistance() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].attenuationDistance
	}
	get attenuationColor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].attenuationColor.toArray()
	}
	setThicknessFactor(thickness) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.thickness = thickness;
		this[$onUpdate$1]()
	}
	setAttenuationDistance(attenuationDistance) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.attenuationDistance = attenuationDistance;
		this[$onUpdate$1]()
	}
	setAttenuationColor(rgb) {
		this[$ensureMaterialIsLoaded]();
		let color = this.colorFromRgb(rgb);
		for (let material of this[$correlatedObjects]) material.attenuationColor.set(color);
		this[$onUpdate$1]()
	}
	get specularFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].specularIntensity
	}
	get specularTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.Specular)
	}
	get specularColorFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].specularColor.toArray()
	}
	get specularColorTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.SheenColor)
	}
	setSpecularFactor(specularFactor) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.specularIntensity = specularFactor;
		this[$onUpdate$1]()
	}
	setSpecularColorFactor(rgb) {
		this[$ensureMaterialIsLoaded]();
		let color = this.colorFromRgb(rgb);
		for (let material of this[$correlatedObjects]) material.specularColor.set(color);
		this[$onUpdate$1]()
	}
	get iridescenceFactor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].iridescence
	}
	get iridescenceTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.Iridescence)
	}
	get iridescenceIor() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].iridescenceIOR
	}
	get iridescenceThicknessMinimum() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].iridescenceThicknessRange[0]
	}
	get iridescenceThicknessMaximum() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].iridescenceThicknessRange[1]
	}
	get iridescenceThicknessTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.IridescenceThickness)
	}
	setIridescenceFactor(iridescence) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.iridescence = iridescence;
		this[$onUpdate$1]()
	}
	setIridescenceIor(ior) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.iridescenceIOR = ior;
		this[$onUpdate$1]()
	}
	setIridescenceThicknessMinimum(thicknessMin) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.iridescenceThicknessRange[0] = thicknessMin;
		this[$onUpdate$1]()
	}
	setIridescenceThicknessMaximum(thicknessMax) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.iridescenceThicknessRange[1] = thicknessMax;
		this[$onUpdate$1]()
	}
	get anisotropyStrength() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].anisotropy
	}
	get anisotropyRotation() {
		return this[$ensureMaterialIsLoaded](), this[$backingThreeMaterial].anisotropyRotation
	}
	get anisotropyTexture() {
		return this[$ensureMaterialIsLoaded](), this[$pbrTextures].get(TextureUsage.Anisotropy)
	}
	setAnisotropyStrength(strength) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.anisotropy = strength;
		this[$onUpdate$1]()
	}
	setAnisotropyRotation(rotation) {
		for (let material of (this[$ensureMaterialIsLoaded](), this[$correlatedObjects])) material.anisotropyRotation = rotation;
		this[$onUpdate$1]()
	}
}
class Node$1 {
	constructor(name) {
		this.name = "", this.children = [], this.name = name
	}
}
class PrimitiveNode extends Node$1 {
	constructor(mesh, mvMaterials, modelVariants, correlatedSceneGraph) {
		super(mesh.name), this.materials = new Map, this.variantToMaterialMap = new Map, this.initialMaterialIdx = 0, this.activeMaterialIdx = 0, this.mesh = mesh;
		let {
			gltf,
			threeGLTF,
			threeObjectMap
		} = correlatedSceneGraph;
		this.parser = threeGLTF.parser, this.modelVariants = modelVariants, this.mesh.userData.variantData = modelVariants;
		let materialMappings = threeObjectMap.get(mesh.material);
		null != materialMappings.materials ? this.initialMaterialIdx = this.activeMaterialIdx = materialMappings.materials : console.error(`Primitive (${mesh.name}) missing initial material reference.`);
		let associations = mesh.userData.associations || {};
		if (null == associations.meshes) {
			console.error("Mesh is missing primitive index association");
			return
		}
		let gltfPrimitive = ((gltf.meshes || [])[associations.meshes].primitives || [])[associations.primitives];
		if (null == gltfPrimitive) {
			console.error("Mesh primitive definition is missing.");
			return
		}
		if (null != gltfPrimitive.material) this.materials.set(gltfPrimitive.material, mvMaterials[gltfPrimitive.material]);
		else {
			let defaultIdx = mvMaterials.findIndex(mat => "Default" === mat.name);
			defaultIdx >= 0 ? this.materials.set(defaultIdx, mvMaterials[defaultIdx]) : console.warn("gltfPrimitive has no material!")
		}
		if (gltfPrimitive.extensions && gltfPrimitive.extensions.KHR_materials_variants) {
			let variantsExtension = gltfPrimitive.extensions.KHR_materials_variants,
				variantNames = threeGLTF.parser.json.extensions.KHR_materials_variants.variants;
			for (let mapping of variantsExtension.mappings) {
				let mvMaterial = mvMaterials[mapping.material];
				for (let variant of (this.materials.set(mapping.material, mvMaterial), mapping.variants)) {
					let {
						name
					} = variantNames[variant];
					this.variantToMaterialMap.set(variant, mvMaterial), mvMaterial[$variantIndices]().add(variant), modelVariants.has(name) || modelVariants.set(name, {
						name,
						index: variant
					})
				}
			}
		}
	}
	async setActiveMaterial(material) {
		let mvMaterial = this.materials.get(material);
		if (null != mvMaterial && material !== this.activeMaterialIdx) {
			this.mesh.material = await mvMaterial[$getLoadedMaterial]();
			let {
				normalScale
			} = this.mesh.material;
			null != normalScale && normalScale.y * normalScale.x < 0 != (null == this.mesh.geometry.attributes.tangent) && this.parser.assignFinalMaterial(this.mesh), this.activeMaterialIdx = material
		}
		return this.mesh.material
	}
	getActiveMaterial() {
		return this.materials.get(this.activeMaterialIdx)
	}
	getMaterial(index) {
		return this.materials.get(index)
	}
	async enableVariant(name) {
		if (null == name) return this.setActiveMaterial(this.initialMaterialIdx);
		if (null != this.variantToMaterialMap && this.modelVariants.has(name)) {
			let modelVariants = this.modelVariants.get(name);
			return this.enableVariantHelper(modelVariants.index)
		}
		return null
	}
	async enableVariantHelper(index) {
		if (null != this.variantToMaterialMap && null != index) {
			let material = this.variantToMaterialMap.get(index);
			if (null != material) return this.setActiveMaterial(material.index)
		}
		return null
	}
	async instantiateVariants() {
		if (null != this.variantToMaterialMap)
			for (let index of this.variantToMaterialMap.keys()) {
				let variantMaterial = this.mesh.userData.variantMaterials.get(index);
				if (null != variantMaterial.material) continue;
				let threeMaterial = await this.enableVariantHelper(index);
				null != threeMaterial && (variantMaterial.material = threeMaterial)
			}
	}
	get variantInfo() {
		return this.variantToMaterialMap
	}
	addVariant(materialVariant, variantName) {
		if (!this.ensureVariantIsUnused(variantName)) return !1;
		this.modelVariants.has(variantName) || this.modelVariants.set(variantName, {
			name: variantName,
			index: this.modelVariants.size
		});
		let variantIndex = this.modelVariants.get(variantName).index;
		return materialVariant[$variantIndices]().add(variantIndex), this.variantToMaterialMap.set(variantIndex, materialVariant), this.materials.set(materialVariant.index, materialVariant), this.updateVariantUserData(variantIndex, materialVariant), !0
	}
	deleteVariant(variantIndex) {
		if (this.variantInfo.has(variantIndex)) {
			this.variantInfo.delete(variantIndex);
			let userDataMap = this.mesh.userData.variantMaterials;
			null != userDataMap && userDataMap.delete(variantIndex)
		}
	}
	updateVariantUserData(variantIndex, materialVariant) {
		materialVariant[$variantIndices]().add(variantIndex), this.mesh.userData.variantData = this.modelVariants, this.mesh.userData.variantMaterials = this.mesh.userData.variantMaterials || new Map, this.mesh.userData.variantMaterials.set(variantIndex, {
			material: materialVariant[$correlatedObjects].values().next().value,
			gltfMaterialIndex: materialVariant.index
		})
	}
	ensureVariantIsUnused(variantName) {
		let modelVariants = this.modelVariants.get(variantName);
		return !(null != modelVariants && this.variantInfo.has(modelVariants.index)) || (console.warn(`Primitive cannot add variant '${variantName}' for this material, it already exists.`), !1)
	}
}
let $materials = Symbol("materials"),
	$hierarchy = Symbol("hierarchy"),
	$roots = Symbol("roots"),
	$primitivesList = Symbol("primitives"),
	$prepareVariantsForExport = Symbol("prepareVariantsForExport"),
	$switchVariant = Symbol("switchVariant"),
	$materialFromPoint = Symbol("materialFromPoint"),
	$nodeFromPoint = Symbol("nodeFromPoint"),
	$nodeFromIndex = Symbol("nodeFromIndex"),
	$variantData = Symbol("variantData"),
	$availableVariants = Symbol("availableVariants"),
	$modelOnUpdate = Symbol("modelOnUpdate"),
	$cloneMaterial = Symbol("cloneMaterial");
class LazyLoader {
	constructor(gltf, gltfElementMap, mapKey, doLazyLoad) {
		this.gltf = gltf, this.gltfElementMap = gltfElementMap, this.mapKey = mapKey, this.doLazyLoad = doLazyLoad
	}
}
class Model {
	constructor(correlatedSceneGraph, onUpdate = () => {}) {
		this[_a$2] = [], this[_b$2] = [], this[_c$1] = [], this[_d$1] = [], this[_e$1] = () => {}, this[_f$1] = new Map, this[$modelOnUpdate] = onUpdate;
		let {
			gltf,
			threeGLTF,
			gltfElementMap
		} = correlatedSceneGraph;
		for (let [i, material] of gltf.materials.entries()) {
			let correlatedMaterial = gltfElementMap.get(material);
			if (null != correlatedMaterial) this[$materials].push(new Material(onUpdate, i, !0, this[$variantData], correlatedMaterial, material.name));
			else {
				let gltfMaterialDef = (gltf.materials || [])[i],
					capturedMatIndex = i,
					materialLoadCallback = async () => {
						let threeMaterial = await threeGLTF.parser.getDependency("material", capturedMatIndex),
							threeMaterialSet = new Set;
						return gltfElementMap.set(gltfMaterialDef, threeMaterialSet), threeMaterialSet.add(threeMaterial), {
							set: threeMaterialSet,
							material: threeMaterial
						}
					};
				this[$materials].push(new Material(onUpdate, i, !1, this[$variantData], correlatedMaterial, material.name, new LazyLoader(gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)))
			}
		}
		let parentMap = new Map,
			nodeStack = [];
		for (let object of threeGLTF.scene.children) nodeStack.push(object);
		for (; nodeStack.length > 0;) {
			let object = nodeStack.pop(),
				node = null;
			object instanceof Mesh ? (node = new PrimitiveNode(object, this.materials, this[$variantData], correlatedSceneGraph), this[$primitivesList].push(node)) : node = new Node$1(object.name);
			let parent = parentMap.get(object);
			for (let child of (null != parent ? parent.children.push(node) : this[$roots].push(node), this[$hierarchy].push(node), object.children)) nodeStack.push(child), parentMap.set(object, node)
		}
	}
	get materials() {
		return this[$materials]
	} [(_a$2 = $materials, _b$2 = $hierarchy, _c$1 = $roots, _d$1 = $primitivesList, _e$1 = $modelOnUpdate, _f$1 = $variantData, $availableVariants)]() {
		let variants = Array.from(this[$variantData].values());
		return variants.sort((a, b) => a.index - b.index), variants.map(data => data.name)
	}
	getMaterialByName(name) {
		let matches = this[$materials].filter(material => material.name === name);
		return matches.length > 0 ? matches[0] : null
	} [$nodeFromIndex](mesh, primitive) {
		let found = this[$hierarchy].find(node => {
			if (node instanceof PrimitiveNode) {
				let {
					meshes,
					primitives
				} = node.mesh.userData.associations;
				if (meshes == mesh && primitives == primitive) return !0
			}
			return !1
		});
		return null == found ? null : found
	} [$nodeFromPoint](hit) {
		return this[$hierarchy].find(node => node instanceof PrimitiveNode && node.mesh === hit.object)
	} [$materialFromPoint](hit) {
		return this[$nodeFromPoint](hit).getActiveMaterial()
	}
	async [$switchVariant](variantName) {
		for (let primitive of this[$primitivesList]) await primitive.enableVariant(variantName);
		for (let material of this.materials) material[$setActive](!1);
		for (let primitive of this[$primitivesList]) this.materials[primitive.getActiveMaterial().index][$setActive](!0)
	}
	async [$prepareVariantsForExport]() {
		let promises = [];
		for (let primitive of this[$primitivesList]) promises.push(primitive.instantiateVariants());
		await Promise.all(promises)
	} [$cloneMaterial](index, newMaterialName) {
		let material = this.materials[index];
		material.isLoaded || console.error(`Cloning an unloaded material,
           call 'material.ensureLoaded() before cloning the material.`);
		let threeMaterialSet = material[$correlatedObjects],
			clonedSet = new Set;
		for (let [i, threeMaterial] of threeMaterialSet.entries()) {
			let clone = threeMaterial.clone();
			clone.name = newMaterialName + (threeMaterialSet.size > 1 ? "_inst" + i : ""), clonedSet.add(clone)
		}
		let clonedMaterial = new Material(this[$modelOnUpdate], this[$materials].length, !1, this[$variantData], clonedSet, newMaterialName);
		return this[$materials].push(clonedMaterial), clonedMaterial
	}
	createMaterialInstanceForVariant(originalMaterialIndex, newMaterialName, variantName, activateVariant = !0) {
		let variantMaterialInstance = null;
		for (let primitive of this[$primitivesList]) {
			let variantData = this[$variantData].get(variantName);
			null != variantData && primitive.variantInfo.has(variantData.index) || null == primitive.getMaterial(originalMaterialIndex) || (this.hasVariant(variantName) || this.createVariant(variantName), null == variantMaterialInstance && (variantMaterialInstance = this[$cloneMaterial](originalMaterialIndex, newMaterialName)), primitive.addVariant(variantMaterialInstance, variantName))
		}
		if (activateVariant && null != variantMaterialInstance)
			for (let primitive of (variantMaterialInstance[$setActive](!0), this.materials[originalMaterialIndex][$setActive](!1), this[$primitivesList])) primitive.enableVariant(variantName);
		return variantMaterialInstance
	}
	createVariant(variantName) {
		this[$variantData].has(variantName) ? console.warn(`Variant '${variantName}'' already exists`) : this[$variantData].set(variantName, {
			name: variantName,
			index: this[$variantData].size
		})
	}
	hasVariant(variantName) {
		return this[$variantData].has(variantName)
	}
	setMaterialToVariant(materialIndex, targetVariantName) {
		if (null == this[$availableVariants]().find(name => name === targetVariantName)) {
			console.warn(`Can't add material to '${targetVariantName}', the variant does not exist.'`);
			return
		}
		if (materialIndex < 0 || materialIndex >= this.materials.length) {
			console.error("setMaterialToVariant(): materialIndex is out of bounds.");
			return
		}
		for (let primitive of this[$primitivesList]) {
			let material = primitive.getMaterial(materialIndex);
			null != material && primitive.addVariant(material, targetVariantName)
		}
	}
	updateVariantName(currentName, newName) {
		let variantData = this[$variantData].get(currentName);
		null != variantData && (variantData.name = newName, this[$variantData].set(newName, variantData), this[$variantData].delete(currentName))
	}
	deleteVariant(variantName) {
		let variant = this[$variantData].get(variantName);
		if (null != variant) {
			for (let material of this.materials) material.hasVariant(variantName) && material[$variantSet].delete(variant.index);
			for (let primitive of this[$primitivesList]) primitive.deleteVariant(variant.index);
			this[$variantData].delete(variantName)
		}
	}
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$5 = function(decorators, target, key, desc) {
	for (var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, i = decorators.length - 1; i >= 0; i--)(d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	return c > 3 && r && Object.defineProperty(target, key, r), r
};
let $currentGLTF = Symbol("currentGLTF"),
	$originalGltfJson = Symbol("originalGltfJson"),
	$model = Symbol("model"),
	$getOnUpdateMethod = Symbol("getOnUpdateMethod"),
	$buildTexture = Symbol("buildTexture");
/* @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GroundedSkybox extends Mesh {
	constructor() {
		super(void 0, new MeshBasicMaterial({
			depthWrite: !1
		})), this.height = 0, this.radius = 0, this.resolution = 0, this.userData.noHit = !0
	}
	get map() {
		return this.material.map
	}
	set map(skybox) {
		this.material.map = skybox
	}
	isUsable() {
		return this.height > 0 && this.radius > 0 && null != this.geometry && null != this.map
	}
	updateGeometry(height = this.height, radius = this.radius, resolution = 128) {
		(height != this.height || radius != this.radius || resolution != this.resolution) && (this.height = height, this.radius = radius, this.resolution = resolution, height > 0 && radius > 0 && (this.geometry.dispose(), this.geometry = function(height, radius, resolution) {
			let geometry = new SphereGeometry(radius, 2 * resolution, resolution);
			geometry.scale(1, 1, -1);
			let pos = geometry.getAttribute("position"),
				tmp = new Vector3;
			for (let i = 0; i < pos.count; ++i)
				if (tmp.fromBufferAttribute(pos, i), tmp.y < 0) {
					let y1 = -(3 * height) / 2,
						f = tmp.y < y1 ? -height / tmp.y : 1 - tmp.y * tmp.y / (3 * y1 * y1);
					tmp.multiplyScalar(f), tmp.toArray(pos.array, 3 * i)
				} return pos.needsUpdate = !0, geometry
		}(height, radius, resolution)))
	}
}
/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let a = new Vector3,
	b = new Vector3,
	c = new Vector3,
	mat = new Matrix3,
	triangle = new Triangle,
	quat = new Quaternion;
class Hotspot extends CSS2DObject {
	constructor(config) {
		super(document.createElement("div")), this.normal = new Vector3(0, 1, 0), this.initialized = !1, this.referenceCount = 1, this.pivot = document.createElement("div"), this.slot = document.createElement("slot"), this.element.classList.add("annotation-wrapper"), this.slot.name = config.name, this.element.appendChild(this.pivot), this.pivot.appendChild(this.slot), this.updatePosition(config.position), this.updateNormal(config.normal), this.surface = config.surface
	}
	get facingCamera() {
		return !this.element.classList.contains("hide")
	}
	show() {
		this.facingCamera && this.initialized || this.updateVisibility(!0)
	}
	hide() {
		(this.facingCamera || !this.initialized) && this.updateVisibility(!1)
	}
	increment() {
		this.referenceCount++
	}
	decrement() {
		return this.referenceCount > 0 && --this.referenceCount, 0 === this.referenceCount
	}
	updatePosition(position) {
		if (null == position) return;
		let positionNodes = parseExpressions(position)[0].terms;
		for (let i = 0; i < 3; ++i) this.position.setComponent(i, normalizeUnit(positionNodes[i]).number);
		this.updateMatrixWorld()
	}
	updateNormal(normal) {
		if (null == normal) return;
		let normalNodes = parseExpressions(normal)[0].terms;
		for (let i = 0; i < 3; ++i) this.normal.setComponent(i, normalNodes[i].number)
	}
	updateSurface(forceUpdate) {
		if (!forceUpdate && this.initialized) return;
		let {
			mesh,
			tri,
			bary
		} = this;
		if (null == mesh || null == tri || null == bary) return;
		mesh.getVertexPosition(tri.x, a), mesh.getVertexPosition(tri.y, b), mesh.getVertexPosition(tri.z, c), a.toArray(mat.elements, 0), b.toArray(mat.elements, 3), c.toArray(mat.elements, 6), this.position.copy(bary).applyMatrix3(mat);
		let target = this.parent;
		target.worldToLocal(mesh.localToWorld(this.position)), triangle.set(a, b, c), triangle.getNormal(this.normal).transformDirection(mesh.matrixWorld);
		let scene = target.parent;
		quat.setFromAxisAngle(a.set(0, 1, 0), -scene.yaw), this.normal.applyQuaternion(quat)
	}
	orient(radians) {
		this.pivot.style.transform = `rotate(${radians}rad)`
	}
	updateVisibility(show) {
		this.element.classList.toggle("hide", !show), this.slot.assignedNodes().forEach(node => {
			if (node.nodeType !== Node.ELEMENT_NODE) return;
			let visibilityAttribute = node.dataset.visibilityAttribute;
			if (null != visibilityAttribute) {
				let attributeName = `data-${visibilityAttribute}`;
				node.toggleAttribute(attributeName, show)
			}
			node.dispatchEvent(new CustomEvent("hotspot-visibility", {
				detail: {
					visible: show
				}
			}))
		}), this.initialized = !0
	}
}
let HorizontalBlurShader = {
		name: "HorizontalBlurShader",
		uniforms: {
			tDiffuse: {
				value: null
			},
			h: {
				value: 1 / 512
			}
		},
		vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
		fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
	},
	VerticalBlurShader = {
		name: "VerticalBlurShader",
		uniforms: {
			tDiffuse: {
				value: null
			},
			v: {
				value: 1 / 512
			}
		},
		vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
		fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
	};
class Shadow extends Object3D {
	constructor(scene, softness, side) {
		super(), this.camera = new OrthographicCamera, this.renderTarget = null, this.renderTargetBlur = null, this.depthMaterial = new MeshDepthMaterial, this.horizontalBlurMaterial = new ShaderMaterial(HorizontalBlurShader), this.verticalBlurMaterial = new ShaderMaterial(VerticalBlurShader), this.intensity = 0, this.softness = 1, this.boundingBox = new Box3, this.size = new Vector3, this.maxDimension = 0, this.isAnimated = !1, this.needsUpdate = !1;
		let {
			camera
		} = this;
		camera.rotation.x = Math.PI / 2, camera.left = -.5, camera.right = .5, camera.bottom = -.5, camera.top = .5, this.add(camera);
		let plane = new PlaneGeometry,
			shadowMaterial = new MeshBasicMaterial({
				opacity: 1,
				transparent: !0,
				side: 1
			});
		this.floor = new Mesh(plane, shadowMaterial), this.floor.userData.noHit = !0, camera.add(this.floor), this.blurPlane = new Mesh(plane), this.blurPlane.visible = !1, camera.add(this.blurPlane), scene.target.add(this), this.depthMaterial.onBeforeCompile = function(shader) {
			shader.fragmentShader = shader.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * opacity );")
		}, this.horizontalBlurMaterial.depthTest = !1, this.verticalBlurMaterial.depthTest = !1, this.setScene(scene, softness, side)
	}
	setScene(scene, softness, side) {
		let {
			boundingBox,
			size,
			rotation,
			position
		} = this;
		if (this.isAnimated = scene.animationNames.length > 0, this.boundingBox.copy(scene.boundingBox), this.size.copy(scene.size), this.maxDimension = Math.max(size.x, size.y, size.z) * (this.isAnimated ? 2 : 1), this.boundingBox.getCenter(position), "back" === side) {
			let {
				min,
				max
			} = boundingBox;
			[min.y, min.z] = [min.z, min.y], [max.y, max.z] = [max.z, max.y], [size.y, size.z] = [size.z, size.y], rotation.x = Math.PI / 2, rotation.y = Math.PI
		} else rotation.x = 0, rotation.y = 0;
		if (this.isAnimated) {
			let minY = boundingBox.min.y,
				maxY = boundingBox.max.y;
			size.y = this.maxDimension, boundingBox.expandByVector(size.subScalar(this.maxDimension).multiplyScalar(-.5)), boundingBox.min.y = minY, boundingBox.max.y = maxY, size.set(this.maxDimension, maxY - minY, this.maxDimension)
		}
		"bottom" === side ? position.y = boundingBox.min.y : position.z = boundingBox.min.y, this.setSoftness(softness)
	}
	setSoftness(softness) {
		this.softness = softness;
		let {
			size,
			camera
		} = this, scaleY = this.isAnimated ? 2 : 1;
		this.setMapSize(scaleY * Math.pow(2, 9 - 3 * softness));
		let softFar = size.y / 2,
			hardFar = size.y * scaleY;
		camera.near = 0, camera.far = (1 - softness) * hardFar + softness * softFar, this.depthMaterial.opacity = 1 / softness, camera.updateProjectionMatrix(), this.setIntensity(this.intensity), this.setOffset(0)
	}
	setMapSize(maxMapSize) {
		let {
			size
		} = this;
		this.isAnimated && (maxMapSize *= 2);
		let baseWidth = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z),
			baseHeight = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize),
			width = 10 + baseWidth,
			height = 10 + baseHeight;
		if (null != this.renderTarget && (this.renderTarget.width !== width || this.renderTarget.height !== height) && (this.renderTarget.dispose(), this.renderTarget = null, this.renderTargetBlur.dispose(), this.renderTargetBlur = null), null == this.renderTarget) {
			let params = {
				format: 1023
			};
			this.renderTarget = new WebGLRenderTarget(width, height, params), this.renderTargetBlur = new WebGLRenderTarget(width, height, params), this.floor.material.map = this.renderTarget.texture
		}
		this.camera.scale.set(size.x * (1 + 10 / baseWidth), size.z * (1 + 10 / baseHeight), 1), this.needsUpdate = !0
	}
	setIntensity(intensity) {
		if (this.intensity = intensity, intensity > 0) {
			var t;
			this.visible = !0, this.floor.visible = !0, this.floor.material.opacity = intensity * ((1 - (t = this.softness * this.softness)) * .3 + 1 * t)
		} else this.visible = !1, this.floor.visible = !1
	}
	getIntensity() {
		return this.intensity
	}
	setOffset(offset) {
		this.floor.position.z = -offset + this.gap()
	}
	gap() {
		return .001 * this.maxDimension
	}
	render(renderer, scene) {
		scene.overrideMaterial = this.depthMaterial;
		let initialClearAlpha = renderer.getClearAlpha();
		renderer.setClearAlpha(0), this.floor.visible = !1;
		let xrEnabled = renderer.xr.enabled;
		renderer.xr.enabled = !1;
		let oldRenderTarget = renderer.getRenderTarget();
		renderer.setRenderTarget(this.renderTarget), renderer.render(scene, this.camera), scene.overrideMaterial = null, this.floor.visible = !0, this.blurShadow(renderer), renderer.xr.enabled = xrEnabled, renderer.setRenderTarget(oldRenderTarget), renderer.setClearAlpha(initialClearAlpha)
	}
	blurShadow(renderer) {
		let {
			camera,
			horizontalBlurMaterial,
			verticalBlurMaterial,
			renderTarget,
			renderTargetBlur,
			blurPlane
		} = this;
		blurPlane.visible = !0, blurPlane.material = horizontalBlurMaterial, horizontalBlurMaterial.uniforms.h.value = 1 / this.renderTarget.width, horizontalBlurMaterial.uniforms.tDiffuse.value = this.renderTarget.texture, renderer.setRenderTarget(renderTargetBlur), renderer.render(blurPlane, camera), blurPlane.material = verticalBlurMaterial, verticalBlurMaterial.uniforms.v.value = 1 / this.renderTarget.height, verticalBlurMaterial.uniforms.tDiffuse.value = this.renderTargetBlur.texture, renderer.setRenderTarget(renderTarget), renderer.render(blurPlane, camera), blurPlane.visible = !1
	}
	dispose() {
		null != this.renderTarget && this.renderTarget.dispose(), null != this.renderTargetBlur && this.renderTargetBlur.dispose(), this.depthMaterial.dispose(), this.horizontalBlurMaterial.dispose(), this.verticalBlurMaterial.dispose(), this.floor.material.dispose(), this.floor.geometry.dispose(), this.blurPlane.geometry.dispose(), this.removeFromParent()
	}
}
let view = new Vector3,
	target = new Vector3,
	normalWorld = new Vector3,
	raycaster = new class {
		constructor(origin, direction, near = 0, far = 1 / 0) {
			this.ray = new Ray(origin, direction), this.near = near, this.far = far, this.camera = null, this.layers = new Layers, this.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			}
		}
		set(origin, direction) {
			this.ray.set(origin, direction)
		}
		setFromCamera(coords, camera) {
			camera.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(camera.matrixWorld), this.ray.direction.set(coords.x, coords.y, .5).unproject(camera).sub(this.ray.origin).normalize(), this.camera = camera) : camera.isOrthographicCamera ? (this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera), this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld), this.camera = camera) : console.error("THREE.Raycaster: Unsupported camera type: " + camera.type)
		}
		intersectObject(object, recursive = !0, intersects = []) {
			return intersectObject(object, this, intersects, recursive), intersects.sort(ascSort), intersects
		}
		intersectObjects(objects, recursive = !0, intersects = []) {
			for (let i = 0, l = objects.length; i < l; i++) intersectObject(objects[i], this, intersects, recursive);
			return intersects.sort(ascSort), intersects
		}
	},
	vector3 = new Vector3,
	ndc = new Vector2;
class ModelScene extends Scene {
	constructor({
		canvas,
		element,
		width,
		height
	}) {
		super(), this.annotationRenderer = new CSS2DRenderer, this.effectRenderer = null, this.schemaElement = document.createElement("script"), this.width = 1, this.height = 1, this.aspect = 1, this.scaleStep = 0, this.renderCount = 0, this.externalRenderer = null, this.camera = new PerspectiveCamera(45, 1, .1, 100), this.xrCamera = null, this.url = null, this.target = new Object3D, this.animationNames = [], this.boundingBox = new Box3, this.boundingSphere = new Sphere, this.size = new Vector3, this.idealAspect = 0, this.framedFoVDeg = 0, this.shadow = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.bakedShadows = new Set, this.exposure = 1, this.toneMapping = 4, this.canScale = !0, this.isDirty = !1, this.goalTarget = new Vector3, this.targetDamperX = new Damper, this.targetDamperY = new Damper, this.targetDamperZ = new Damper, this._currentGLTF = null, this._model = null, this.cancelPendingSourceChange = null, this.animationsByName = new Map, this.currentAnimationAction = null, this.groundedSkybox = new GroundedSkybox, this.name = "ModelScene", this.element = element, this.canvas = canvas, this.camera = new PerspectiveCamera(45, 1, .1, 100), this.camera.name = "MainCamera", this.add(this.target), this.setSize(width, height), this.target.name = "Target", this.mixer = new AnimationMixer(this.target);
		let {
			domElement
		} = this.annotationRenderer, {
			style
		} = domElement;
		style.display = "none", style.pointerEvents = "none", style.position = "absolute", style.top = "0", this.element.shadowRoot.querySelector(".default").appendChild(domElement), this.schemaElement.setAttribute("type", "application/ld+json")
	}
	get context() {
		return this.canvas.getContext("2d")
	}
	getCamera() {
		return null != this.xrCamera ? this.xrCamera : this.camera
	}
	queueRender() {
		this.isDirty = !0
	}
	shouldRender() {
		return this.isDirty
	}
	hasRendered() {
		this.isDirty = !1
	}
	forceRescale() {
		this.scaleStep = -1, this.queueRender()
	}
	async setObject(model) {
		this.reset(), this._model = model, this.target.add(model), await this.setupScene()
	}
	async setSource(url, progressCallback = () => {}) {
		let gltf;
		if (!url || url === this.url) {
			progressCallback(1);
			return
		}
		if (this.reset(), this.url = url, null != this.externalRenderer) {
			let framingInfo = await this.externalRenderer.load(progressCallback);
			this.boundingSphere.radius = framingInfo.framedRadius, this.idealAspect = framingInfo.fieldOfViewAspect;
			return
		}
		null != this.cancelPendingSourceChange && (this.cancelPendingSourceChange(), this.cancelPendingSourceChange = null);
		try {
			gltf = await new Promise(async (resolve, reject) => {
				this.cancelPendingSourceChange = () => reject();
				try {
					let result = await this.element[$renderer].loader.load(url, this.element, progressCallback);
					resolve(result)
				} catch (error) {
					reject(error)
				}
			})
		} catch (error) {
			if (null == error) return;
			throw error
		}
		this.cancelPendingSourceChange = null, this.reset(), this.url = url, this._currentGLTF = gltf, null != gltf && (this._model = gltf.scene, this.target.add(gltf.scene));
		let {
			animations
		} = gltf, animationsByName = new Map, animationNames = [];
		for (let animation of animations) animationsByName.set(animation.name, animation), animationNames.push(animation.name);
		this.animations = animations, this.animationsByName = animationsByName, this.animationNames = animationNames, await this.setupScene()
	}
	async setupScene() {
		this.applyTransform(), this.updateBoundingBox(), await this.updateFraming(), this.updateShadow(), this.setShadowIntensity(this.shadowIntensity), this.setGroundedSkybox()
	}
	reset() {
		this.url = null, this.renderCount = 0, this.queueRender(), null != this.shadow && this.shadow.setIntensity(0), this.bakedShadows.clear();
		let {
			_model
		} = this;
		null != _model && (_model.removeFromParent(), this._model = null);
		let gltf = this._currentGLTF;
		null != gltf && (gltf.dispose(), this._currentGLTF = null), null != this.currentAnimationAction && (this.currentAnimationAction.stop(), this.currentAnimationAction = null), this.mixer.stopAllAction(), this.mixer.uncacheRoot(this)
	}
	dispose() {
		this.reset(), null != this.shadow && (this.shadow.dispose(), this.shadow = null), this.element[$currentGLTF] = null, this.element[$originalGltfJson] = null, this.element[$model] = null
	}
	get currentGLTF() {
		return this._currentGLTF
	}
	setSize(width, height) {
		if (this.width !== width || this.height !== height) {
			if (this.width = Math.max(width, 1), this.height = Math.max(height, 1), this.annotationRenderer.setSize(width, height), this.aspect = this.width / this.height, null != this.externalRenderer) {
				let dpr = resolveDpr();
				this.externalRenderer.resize(width * dpr, height * dpr)
			}
			this.queueRender()
		}
	}
	markBakedShadow(mesh) {
		mesh.userData.noHit = !0, this.bakedShadows.add(mesh)
	}
	unmarkBakedShadow(mesh) {
		mesh.userData.noHit = !1, mesh.visible = !0, this.bakedShadows.delete(mesh), this.boundingBox.expandByObject(mesh)
	}
	findBakedShadows(group) {
		let boundingBox = new Box3;
		group.traverse(object => {
			if (!object.material || !object.material.transparent) return;
			boundingBox.setFromObject(object);
			let size = boundingBox.getSize(vector3),
				minDim = Math.min(size.x, size.y, size.z);
			Math.max(size.x, size.y, size.z) < 100 * minDim || this.markBakedShadow(object)
		})
	}
	checkBakedShadows() {
		let {
			min,
			max
		} = this.boundingBox, shadowBox = new Box3;
		for (let mesh of (this.boundingBox.getSize(this.size), this.bakedShadows)) shadowBox.setFromObject(mesh), shadowBox.min.y < min.y + this.size.y / 100 && shadowBox.min.x <= min.x && shadowBox.max.x >= max.x && shadowBox.min.z <= min.z && shadowBox.max.z >= max.z || shadowBox.min.z < min.z + this.size.z / 100 && shadowBox.min.x <= min.x && shadowBox.max.x >= max.x && shadowBox.min.y <= min.y && shadowBox.max.y >= max.y || this.unmarkBakedShadow(mesh)
	}
	applyTransform() {
		let {
			model
		} = this;
		if (null == model) return;
		let orientation = parseExpressions(this.element.orientation)[0].terms,
			roll = normalizeUnit(orientation[0]).number,
			pitch = normalizeUnit(orientation[1]).number,
			yaw = normalizeUnit(orientation[2]).number;
		model.quaternion.setFromEuler(new Euler(pitch, yaw, roll, "YXZ"));
		let scale = parseExpressions(this.element.scale)[0].terms;
		model.scale.set(scale[0].number, scale[1].number, scale[2].number)
	}
	updateBoundingBox() {
		let {
			model
		} = this;
		if (null == model) return;
		this.target.remove(model), this.findBakedShadows(model);
		let bound = (box, vertex) => box.expandByPoint(vertex);
		this.setBakedShadowVisibility(!1), this.boundingBox = reduceVertices(model, bound, new Box3), this.boundingBox.isEmpty() && (this.setBakedShadowVisibility(!0), this.bakedShadows.forEach(mesh => this.unmarkBakedShadow(mesh)), this.boundingBox = reduceVertices(model, bound, new Box3)), this.checkBakedShadows(), this.setBakedShadowVisibility(), this.boundingBox.getSize(this.size), this.target.add(model)
	}
	async updateFraming() {
		let {
			model
		} = this;
		if (null == model) return;
		this.target.remove(model), this.setBakedShadowVisibility(!1);
		let {
			center
		} = this.boundingSphere;
		this.element.requestUpdate("cameraTarget"), await this.element.updateComplete, center.copy(this.getTarget()), this.boundingSphere.radius = Math.sqrt(reduceVertices(model, (value, vertex) => Math.max(value, center.distanceToSquared(vertex)), 0)), this.idealAspect = reduceVertices(model, (value, vertex) => (vertex.sub(center), Math.max(value, Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z) / (this.idealCameraDistance() - Math.abs(vertex.y)))), 0) / Math.tan(this.framedFoVDeg / 2 * Math.PI / 180), this.setBakedShadowVisibility(), this.target.add(model)
	}
	setBakedShadowVisibility(visible = this.shadowIntensity <= 0) {
		for (let shadow of this.bakedShadows) shadow.visible = visible
	}
	idealCameraDistance() {
		let halfFovRad = this.framedFoVDeg / 2 * Math.PI / 180;
		return this.boundingSphere.radius / Math.sin(halfFovRad)
	}
	adjustedFoV(fovDeg) {
		return 2 * Math.atan(Math.tan(fovDeg / 2 * Math.PI / 180) * Math.max(1, this.idealAspect / this.aspect)) * 180 / Math.PI
	}
	getNDC(clientX, clientY) {
		if (null != this.xrCamera) ndc.set(clientX / window.screen.width, clientY / window.screen.height);
		else {
			let rect = this.element.getBoundingClientRect();
			ndc.set((clientX - rect.x) / this.width, (clientY - rect.y) / this.height)
		}
		return ndc.multiplyScalar(2).subScalar(1), ndc.y *= -1, ndc
	}
	getSize() {
		return {
			width: this.width,
			height: this.height
		}
	}
	setEnvironmentAndSkybox(environment, skybox) {
		this.element[$renderer].arRenderer.presentedScene !== this && (this.environment = environment, this.setBackground(skybox), this.queueRender())
	}
	setBackground(skybox) {
		this.groundedSkybox.map = skybox, this.groundedSkybox.isUsable() ? (this.target.add(this.groundedSkybox), this.background = null) : (this.target.remove(this.groundedSkybox), this.background = skybox)
	}
	farRadius() {
		return this.boundingSphere.radius * (null != this.groundedSkybox.parent ? 10 : 1)
	}
	setGroundedSkybox() {
		let height = normalizeUnit(parseExpressions(this.element.skyboxHeight)[0].terms[0]).number,
			radius = 10 * this.boundingSphere.radius;
		this.groundedSkybox.updateGeometry(height, radius), this.groundedSkybox.position.y = height - (this.shadow ? 2 * this.shadow.gap() : 0), this.setBackground(this.groundedSkybox.map)
	}
	setTarget(modelX, modelY, modelZ) {
		this.goalTarget.set(-modelX, -modelY, -modelZ)
	}
	setTargetDamperDecayTime(decayMilliseconds) {
		this.targetDamperX.setDecayTime(decayMilliseconds), this.targetDamperY.setDecayTime(decayMilliseconds), this.targetDamperZ.setDecayTime(decayMilliseconds)
	}
	getTarget() {
		return this.goalTarget.clone().multiplyScalar(-1)
	}
	jumpToGoal() {
		this.updateTarget(1e4)
	}
	updateTarget(delta) {
		let goal = this.goalTarget,
			target = this.target.position;
		if (goal.equals(target)) return !1;
		{
			let normalization = this.boundingSphere.radius / 10,
				{
					x,
					y,
					z
				} = target;
			return x = this.targetDamperX.update(x, goal.x, delta, normalization), y = this.targetDamperY.update(y, goal.y, delta, normalization), z = this.targetDamperZ.update(z, goal.z, delta, normalization), this.target.position.set(x, y, z), this.target.updateMatrixWorld(), this.queueRender(), !0
		}
	}
	pointTowards(worldX, worldZ) {
		let {
			x,
			z
		} = this.position;
		this.yaw = Math.atan2(worldX - x, worldZ - z)
	}
	get model() {
		return this._model
	}
	set yaw(radiansY) {
		this.rotation.y = radiansY, this.queueRender()
	}
	get yaw() {
		return this.rotation.y
	}
	set animationTime(value) {
		this.mixer.setTime(value), this.queueShadowRender()
	}
	get animationTime() {
		if (null != this.currentAnimationAction) {
			let loopCount = Math.max(this.currentAnimationAction._loopCount, 0);
			return 2202 === this.currentAnimationAction.loop && (1 & loopCount) == 1 ? this.duration - this.currentAnimationAction.time : this.currentAnimationAction.time
		}
		return 0
	}
	set animationTimeScale(value) {
		this.mixer.timeScale = value
	}
	get animationTimeScale() {
		return this.mixer.timeScale
	}
	get duration() {
		return null != this.currentAnimationAction && this.currentAnimationAction.getClip() ? this.currentAnimationAction.getClip().duration : 0
	}
	get hasActiveAnimation() {
		return null != this.currentAnimationAction
	}
	playAnimation(name = null, crossfadeTime = 0, loopMode = 2201, repetitionCount = 1 / 0) {
		if (null == this._currentGLTF) return;
		let {
			animations
		} = this;
		if (null == animations || 0 === animations.length) return;
		let animationClip = null;
		if (null != name && null == (animationClip = this.animationsByName.get(name))) {
			let parsedAnimationIndex = parseInt(name);
			!isNaN(parsedAnimationIndex) && parsedAnimationIndex >= 0 && parsedAnimationIndex < animations.length && (animationClip = animations[parsedAnimationIndex])
		}
		null == animationClip && (animationClip = animations[0]);
		try {
			let {
				currentAnimationAction: lastAnimationAction
			} = this, action = this.mixer.clipAction(animationClip, this);
			this.currentAnimationAction = action, this.element.paused ? this.mixer.stopAllAction() : (action.paused = !1, null != lastAnimationAction && action !== lastAnimationAction ? action.crossFadeFrom(lastAnimationAction, crossfadeTime, !1) : this.animationTimeScale > 0 && this.animationTime == this.duration && (this.animationTime = 0)), action.setLoop(loopMode, repetitionCount), action.enabled = !0, action.clampWhenFinished = !0, action.play()
		} catch (error) {
			console.error(error)
		}
	}
	stopAnimation() {
		this.currentAnimationAction = null, this.mixer.stopAllAction()
	}
	updateAnimation(step) {
		this.mixer.update(step), this.queueShadowRender()
	}
	subscribeMixerEvent(event, callback) {
		this.mixer.addEventListener(event, callback)
	}
	updateShadow() {
		let shadow = this.shadow;
		if (null != shadow) {
			let side = "wall" === this.element.arPlacement ? "back" : "bottom";
			shadow.setScene(this, this.shadowSoftness, side), shadow.needsUpdate = !0
		}
	}
	renderShadow(renderer) {
		let shadow = this.shadow;
		null != shadow && !0 == shadow.needsUpdate && (shadow.render(renderer, this), shadow.needsUpdate = !1)
	}
	queueShadowRender() {
		null != this.shadow && (this.shadow.needsUpdate = !0)
	}
	setShadowIntensity(shadowIntensity) {
		if (this.shadowIntensity = shadowIntensity, null != this._currentGLTF && (this.setBakedShadowVisibility(), !(shadowIntensity <= 0) || null != this.shadow)) {
			if (null == this.shadow) {
				let side = "wall" === this.element.arPlacement ? "back" : "bottom";
				this.shadow = new Shadow(this, this.shadowSoftness, side)
			}
			this.shadow.setIntensity(shadowIntensity)
		}
	}
	setShadowSoftness(softness) {
		this.shadowSoftness = softness;
		let shadow = this.shadow;
		null != shadow && shadow.setSoftness(softness)
	}
	setShadowOffset(offset) {
		let shadow = this.shadow;
		null != shadow && shadow.setOffset(offset)
	}
	hitFromPoint(ndcPosition, object = this) {
		return raycaster.setFromCamera(ndcPosition, this.getCamera()), raycaster.intersectObject(object, !0).find(hit => hit.object.visible && !hit.object.userData.noHit)
	}
	positionAndNormalFromPoint(ndcPosition, object = this) {
		var _a;
		let hit = this.hitFromPoint(ndcPosition, object);
		return null == hit ? null : {
			position: hit.point,
			normal: null != hit.face ? hit.face.normal.clone().applyNormalMatrix(new Matrix3().getNormalMatrix(hit.object.matrixWorld)) : raycaster.ray.direction.clone().multiplyScalar(-1),
			uv: null !== (_a = hit.uv) && void 0 !== _a ? _a : null
		}
	}
	surfaceFromPoint(ndcPosition, object = this) {
		let model = this.element.model;
		if (null == model) return null;
		let hit = this.hitFromPoint(ndcPosition, object);
		if (null == hit || null == hit.face) return null;
		let {
			meshes,
			primitives
		} = model[$nodeFromPoint](hit).mesh.userData.associations, va = new Vector3, vb = new Vector3, vc = new Vector3, {
			a,
			b,
			c
		} = hit.face, mesh = hit.object;
		mesh.getVertexPosition(a, va), mesh.getVertexPosition(b, vb), mesh.getVertexPosition(c, vc);
		let tri = new Triangle(va, vb, vc),
			uvw = new Vector3;
		return tri.getBarycoord(mesh.worldToLocal(hit.point), uvw), `${meshes} ${primitives} ${a} ${b} ${c} ${uvw.x.toFixed(3)} ${uvw.y.toFixed(3)} ${uvw.z.toFixed(3)}`
	}
	addHotspot(hotspot) {
		this.target.add(hotspot), this.annotationRenderer.domElement.appendChild(hotspot.element)
	}
	removeHotspot(hotspot) {
		this.target.remove(hotspot)
	}
	forHotspots(func) {
		let {
			children
		} = this.target;
		for (let i = 0, l = children.length; i < l; i++) {
			let hotspot = children[i];
			hotspot instanceof Hotspot && func(hotspot)
		}
	}
	initializeSurface(hotspot) {
		if (null != hotspot.surface && null == hotspot.mesh) {
			let nodes = parseExpressions(hotspot.surface)[0].terms;
			if (8 != nodes.length) {
				console.warn(hotspot.surface + " does not have exactly 8 numbers.");
				return
			}
			let primitiveNode = this.element.model[$nodeFromIndex](nodes[0].number, nodes[1].number),
				tri = new Vector3(nodes[2].number, nodes[3].number, nodes[4].number);
			if (null == primitiveNode) {
				console.warn(hotspot.surface + " does not match a node/primitive in this glTF! Skipping this hotspot.");
				return
			}
			let numVert = primitiveNode.mesh.geometry.attributes.position.count;
			if (tri.x >= numVert || tri.y >= numVert || tri.z >= numVert) {
				console.warn(hotspot.surface + " vertex indices out of range in this glTF! Skipping this hotspot.");
				return
			}
			let bary = new Vector3(nodes[5].number, nodes[6].number, nodes[7].number);
			hotspot.mesh = primitiveNode.mesh, hotspot.tri = tri, hotspot.bary = bary
		}
	}
	updateSurfaceHotspots() {
		let forceUpdate = !this.element.paused;
		this.forHotspots(hotspot => {
			this.initializeSurface(hotspot), hotspot.updateSurface(forceUpdate)
		})
	}
	updateHotspotsVisibility(viewerPosition) {
		this.forHotspots(hotspot => {
			view.copy(viewerPosition), target.setFromMatrixPosition(hotspot.matrixWorld), view.sub(target), normalWorld.copy(hotspot.normal).transformDirection(this.target.matrixWorld), 0 > view.dot(normalWorld) ? hotspot.hide() : hotspot.show()
		})
	}
	orientHotspots(radians) {
		this.forHotspots(hotspot => {
			hotspot.orient(radians)
		})
	}
	setHotspotsVisibility(visible) {
		this.forHotspots(hotspot => {
			hotspot.visible = visible
		})
	}
	updateSchema(src) {
		var _a;
		let {
			schemaElement,
			element
		} = this, {
			alt,
			poster,
			iosSrc
		} = element;
		if (null != src) {
			let encoding = [{
				"@type": "MediaObject",
				contentUrl: src,
				encodingFormat: (null === (_a = src.split(".").pop()) || void 0 === _a ? void 0 : _a.toLowerCase()) === "gltf" ? "model/gltf+json" : "model/gltf-binary"
			}];
			iosSrc && encoding.push({
				"@type": "MediaObject",
				contentUrl: iosSrc,
				encodingFormat: "model/vnd.usdz+zip"
			}), schemaElement.textContent = JSON.stringify({
				"@context": "http://schema.org/",
				"@type": "3DModel",
				image: null != poster ? poster : void 0,
				name: null != alt ? alt : void 0,
				encoding
			}), document.head.appendChild(schemaElement)
		} else null != schemaElement.parentElement && schemaElement.parentElement.removeChild(schemaElement)
	}
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProgressTracker extends EventTarget {
	constructor() {
		super(...arguments), this.ongoingActivities = new Set, this.totalProgress = 0
	}
	get ongoingActivityCount() {
		return this.ongoingActivities.size
	}
	beginActivity(reason) {
		let activity = {
			progress: 0,
			completed: !1
		};
		return this.ongoingActivities.add(activity), 1 === this.ongoingActivityCount && this.announceTotalProgress(activity, 0, reason), progress => {
			let nextProgress;
			return (nextProgress = Math.max(clamp(progress, 0, 1), activity.progress)) !== activity.progress && this.announceTotalProgress(activity, nextProgress, reason), activity.progress
		}
	}
	announceTotalProgress(updatedActivity, nextProgress, reason) {
		let progressLeft = 0,
			completedActivities = 0;
		for (let activity of (1 == nextProgress && (updatedActivity.completed = !0), this.ongoingActivities)) {
			let {
				progress
			} = activity;
			progressLeft += 1 - progress, activity.completed && completedActivities++
		}
		let lastProgress = updatedActivity.progress;
		updatedActivity.progress = nextProgress, this.totalProgress += (nextProgress - lastProgress) * (1 - this.totalProgress) / progressLeft;
		let totalProgress = completedActivities === this.ongoingActivityCount ? 1 : this.totalProgress;
		this.dispatchEvent(new CustomEvent("progress", {
			detail: {
				totalProgress,
				reason
			}
		})), completedActivities === this.ongoingActivityCount && (this.totalProgress = 0, this.ongoingActivities.clear())
	}
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$4 = function(decorators, target, key, desc) {
	for (var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, i = decorators.length - 1; i >= 0; i--)(d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	return c > 3 && r && Object.defineProperty(target, key, r), r
};
let blobCanvas = document.createElement("canvas"),
	$fallbackResizeHandler = Symbol("fallbackResizeHandler"),
	$defaultAriaLabel = Symbol("defaultAriaLabel"),
	$resizeObserver = Symbol("resizeObserver"),
	$clearModelTimeout = Symbol("clearModelTimeout"),
	$onContextLost = Symbol("onContextLost"),
	$loaded = Symbol("loaded"),
	$status = Symbol("status"),
	$onFocus = Symbol("onFocus"),
	$onBlur = Symbol("onBlur"),
	$updateSize = Symbol("updateSize"),
	$intersectionObserver = Symbol("intersectionObserver"),
	$isElementInViewport = Symbol("isElementInViewport"),
	$announceModelVisibility = Symbol("announceModelVisibility"),
	$ariaLabel = Symbol("ariaLabel"),
	$altDefaulted = Symbol("altDefaulted"),
	$statusElement = Symbol("statusElement"),
	$updateStatus = Symbol("updateStatus"),
	$loadedTime = Symbol("loadedTime"),
	$updateSource = Symbol("updateSource"),
	$markLoaded = Symbol("markLoaded"),
	$container = Symbol("container"),
	$userInputElement = Symbol("input"),
	$canvas = Symbol("canvas"),
	$scene = Symbol("scene"),
	$needsRender = Symbol("needsRender"),
	$tick = Symbol("tick"),
	$onModelLoad = Symbol("onModelLoad"),
	$onResize = Symbol("onResize"),
	$renderer = Symbol("renderer"),
	$progressTracker = Symbol("progressTracker"),
	$getLoaded = Symbol("getLoaded"),
	$getModelIsVisible = Symbol("getModelIsVisible"),
	$shouldAttemptPreload = Symbol("shouldAttemptPreload"),
	toVector3D = v => ({
		x: v.x,
		y: v.y,
		z: v.z,
		toString() {
			return `${this.x}m ${this.y}m ${this.z}m`
		}
	}),
	toVector2D = v => ({
		u: v.x,
		v: v.y,
		toString() {
			return `${this.u} ${this.v}`
		}
	});
class ModelViewerElementBase extends u {
	constructor() {
		let width, height;
		super(), this.alt = null, this.src = null, this.withCredentials = !1, this.generateSchema = !1, this[_a$1] = !1, this[_b$1] = !1, this[_c] = 0, this[_d] = "", this[_e] = null, this[_f] = debounce(() => {
			let boundingRect = this.getBoundingClientRect();
			this[$updateSize](boundingRect)
		}, 50), this[_g] = debounce(oldVisibility => {
			let newVisibility = this.modelIsVisible;
			newVisibility !== oldVisibility && this.dispatchEvent(new CustomEvent("model-visibility", {
				detail: {
					visible: newVisibility
				}
			}))
		}, 0), this[_h] = null, this[_j] = null, this[_k] = new ProgressTracker, this[_l] = () => {
			this[$statusElement].textContent = this[$status]
		}, this[_m] = () => {
			this[$statusElement].textContent = ""
		}, this[_o] = event => {
			this.dispatchEvent(new CustomEvent("error", {
				detail: {
					type: "webglcontextlost",
					sourceError: event.sourceEvent
				}
			}))
		}, this.attachShadow({
			mode: "open"
		});
		let shadowRoot = this.shadowRoot;
		if (makeTemplate(shadowRoot), this[$container] = shadowRoot.querySelector(".container"), this[$userInputElement] = shadowRoot.querySelector(".userInput"), this[$canvas] = shadowRoot.querySelector("canvas"), this[$statusElement] = shadowRoot.querySelector("#status"), this[$defaultAriaLabel] = this[$userInputElement].getAttribute("aria-label"), this.isConnected) {
			let rect = this.getBoundingClientRect();
			width = rect.width, height = rect.height
		} else width = 300, height = 150;
		this[$scene] = new ModelScene({
			canvas: this[$canvas],
			element: this,
			width,
			height
		}), Promise.resolve().then(() => {
			this[$updateSize](this.getBoundingClientRect())
		}), HAS_RESIZE_OBSERVER && (this[$resizeObserver] = new ResizeObserver(entries => {
			if (!this[$renderer].isPresenting)
				for (let entry of entries) entry.target === this && this[$updateSize](entry.contentRect)
		})), HAS_INTERSECTION_OBSERVER ? this[$intersectionObserver] = new IntersectionObserver(entries => {
			for (let entry of entries)
				if (entry.target === this) {
					let oldVisibility = this.modelIsVisible;
					this[$isElementInViewport] = entry.isIntersecting, this[$announceModelVisibility](oldVisibility), this[$isElementInViewport] && !this.loaded && this[$updateSource]()
				}
		}, {
			root: null,
			rootMargin: "0px",
			threshold: 1e-5
		}) : this[$isElementInViewport] = !0
	}
	static get is() {
		return "model-viewer"
	}
	static set modelCacheSize(value) {
		CachingGLTFLoader[$evictionPolicy].evictionThreshold = value
	}
	static get modelCacheSize() {
		return CachingGLTFLoader[$evictionPolicy].evictionThreshold
	}
	static set minimumRenderScale(value) {
		value > 1 && console.warn("<model-viewer> minimumRenderScale has been clamped to a maximum value of 1."), value <= 0 && console.warn("<model-viewer> minimumRenderScale has been clamped to a minimum value of 0.25."), Renderer.singleton.minScale = value
	}
	static get minimumRenderScale() {
		return Renderer.singleton.minScale
	}
	get loaded() {
		return this[$getLoaded]()
	}
	get[(_a$1 = $isElementInViewport, _b$1 = $loaded, _c = $loadedTime, _d = $status, _e = $clearModelTimeout, _f = $fallbackResizeHandler, _g = $announceModelVisibility, _h = $resizeObserver, _j = $intersectionObserver, _k = $progressTracker, $renderer)]() {
		return Renderer.singleton
	}
	get modelIsVisible() {
		return this[$getModelIsVisible]()
	}
	connectedCallback() {
		super.connectedCallback && super.connectedCallback(), HAS_RESIZE_OBSERVER ? this[$resizeObserver].observe(this) : self.addEventListener("resize", this[$fallbackResizeHandler]), HAS_INTERSECTION_OBSERVER && this[$intersectionObserver].observe(this), this.addEventListener("focus", this[$onFocus]), this.addEventListener("blur", this[$onBlur]);
		let renderer = this[$renderer];
		renderer.addEventListener("contextlost", this[$onContextLost]), renderer.registerScene(this[$scene]), null != this[$clearModelTimeout] && (self.clearTimeout(this[$clearModelTimeout]), this[$clearModelTimeout] = null, this.requestUpdate("src", null))
	}
	disconnectedCallback() {
		super.disconnectedCallback && super.disconnectedCallback(), HAS_RESIZE_OBSERVER ? this[$resizeObserver].unobserve(this) : self.removeEventListener("resize", this[$fallbackResizeHandler]), HAS_INTERSECTION_OBSERVER && this[$intersectionObserver].unobserve(this), this.removeEventListener("focus", this[$onFocus]), this.removeEventListener("blur", this[$onBlur]);
		let renderer = this[$renderer];
		renderer.removeEventListener("contextlost", this[$onContextLost]), renderer.unregisterScene(this[$scene]), this[$clearModelTimeout] = self.setTimeout(() => {
			this[$scene].dispose(), this[$clearModelTimeout] = null
		}, 10)
	}
	updated(changedProperties) {
		super.updated(changedProperties), changedProperties.has("src") && (null == this.src ? (this[$loaded] = !1, this[$loadedTime] = 0, this[$scene].reset()) : this.src !== this[$scene].url && (this[$loaded] = !1, this[$loadedTime] = 0, this[$updateSource]())), changedProperties.has("alt") && this[$userInputElement].setAttribute("aria-label", this[$ariaLabel]), changedProperties.has("withCredentials") && (CachingGLTFLoader.withCredentials = this.withCredentials, this[$renderer].textureUtils.withCredentials = this.withCredentials), changedProperties.has("generateSchema") && (this.generateSchema ? this[$scene].updateSchema(this.src) : this[$scene].updateSchema(null))
	}
	toDataURL(type, encoderOptions) {
		return this[$renderer].displayCanvas(this[$scene]).toDataURL(type, encoderOptions)
	}
	async toBlob(options) {
		let mimeType = options ? options.mimeType : void 0,
			qualityArgument = options ? options.qualityArgument : void 0,
			useIdealAspect = options ? options.idealAspect : void 0,
			{
				width,
				height,
				idealAspect,
				aspect
			} = this[$scene],
			{
				dpr,
				scaleFactor
			} = this[$renderer],
			outputWidth = width * scaleFactor * dpr,
			outputHeight = height * scaleFactor * dpr,
			offsetX = 0,
			offsetY = 0;
		!0 === useIdealAspect && (idealAspect > aspect ? offsetY = (outputHeight - (outputHeight = Math.round(outputWidth / idealAspect))) / 2 : offsetX = (outputWidth - (outputWidth = Math.round(outputHeight * idealAspect))) / 2), blobCanvas.width = outputWidth, blobCanvas.height = outputHeight;
		try {
			return new Promise(async (resolve, reject) => {
				blobCanvas.getContext("2d").drawImage(this[$renderer].displayCanvas(this[$scene]), offsetX, offsetY, outputWidth, outputHeight, 0, 0, outputWidth, outputHeight), blobCanvas.toBlob(blob => {
					if (!blob) return reject(Error("Unable to retrieve canvas blob"));
					resolve(blob)
				}, mimeType, qualityArgument)
			})
		} finally {
			this[$updateSize]({
				width,
				height
			})
		}
	}
	registerEffectComposer(effectComposer) {
		effectComposer.setRenderer(this[$renderer].threeRenderer), effectComposer.setMainCamera(this[$scene].getCamera()), effectComposer.setMainScene(this[$scene]), this[$scene].effectRenderer = effectComposer
	}
	unregisterEffectComposer() {
		this[$scene].effectRenderer = null
	}
	registerRenderer(renderer) {
		this[$scene].externalRenderer = renderer
	}
	unregisterRenderer() {
		this[$scene].externalRenderer = null
	}
	get[$ariaLabel]() {
		return this[$altDefaulted]
	}
	get[$altDefaulted]() {
		return null == this.alt || "null" === this.alt ? this[$defaultAriaLabel] : this.alt
	} [$getLoaded]() {
		return this[$loaded]
	} [$getModelIsVisible]() {
		return this.loaded && this[$isElementInViewport]
	} [$shouldAttemptPreload]() {
		return !!this.src && this[$isElementInViewport]
	} [$updateSize]({
		width,
		height
	}) {
		0 !== width && 0 !== height && (this[$container].style.width = `${width}px`, this[$container].style.height = `${height}px`, this[$onResize]({
			width,
			height
		}))
	} [$tick](time, delta) {
		var _p;
		null === (_p = this[$scene].effectRenderer) || void 0 === _p || _p.beforeRender(time, delta)
	} [$markLoaded]() {
		this[$loaded] || (this[$loaded] = !0, this[$loadedTime] = performance.now())
	} [$needsRender]() {
		this[$scene].queueRender()
	} [$onModelLoad]() {} [$updateStatus](status) {
		this[$status] = status;
		let rootNode = this.getRootNode();
		null != rootNode && rootNode.activeElement === this && this[$statusElement].textContent != status && (this[$statusElement].textContent = status)
	} [(_l = $onFocus, _m = $onBlur, $onResize)](e) {
		this[$scene].setSize(e.width, e.height)
	}
	async [(_o = $onContextLost, $updateSource)]() {
		let scene = this[$scene];
		if (this.loaded || !this[$shouldAttemptPreload]() || this.src === scene.url) return;
		this.generateSchema && scene.updateSchema(this.src), this[$updateStatus]("Loading"), scene.stopAnimation();
		let updateSourceProgress = this[$progressTracker].beginActivity("model-load"),
			source = this.src;
		try {
			let srcUpdated = scene.setSource(source, progress => updateSourceProgress(.95 * clamp(progress, 0, 1))),
				envUpdated = this[$updateEnvironment]();
			await Promise.all([srcUpdated, envUpdated]), this[$markLoaded](), this[$onModelLoad](), this.updateComplete.then(() => {
				this.dispatchEvent(new CustomEvent("before-render"))
			}), await new Promise(resolve => {
				requestAnimationFrame(() => {
					requestAnimationFrame(() => {
						this.dispatchEvent(new CustomEvent("load", {
							detail: {
								url: source
							}
						})), resolve()
					})
				})
			})
		} catch (error) {
			this.dispatchEvent(new CustomEvent("error", {
				detail: {
					type: "loadfailure",
					sourceError: error
				}
			}))
		} finally {
			updateSourceProgress(1)
		}
	}
}
__decorate$4([n$8({
	type: String
})], ModelViewerElementBase.prototype, "alt", void 0), __decorate$4([n$8({
	type: String
})], ModelViewerElementBase.prototype, "src", void 0), __decorate$4([n$8({
	type: Boolean,
	attribute: "with-credentials"
})], ModelViewerElementBase.prototype, "withCredentials", void 0), __decorate$4([n$8({
	type: Boolean,
	attribute: "generate-schema"
})], ModelViewerElementBase.prototype, "generateSchema", void 0);
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$3 = function(decorators, target, key, desc) {
	for (var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, i = decorators.length - 1; i >= 0; i--)(d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	return c > 3 && r && Object.defineProperty(target, key, r), r
};
let $changeAnimation = Symbol("changeAnimation"),
	$paused = Symbol("paused"),
	DEFAULT_PLAY_OPTIONS = {
		repetitions: 1 / 0,
		pingpong: !1
	},
	$hotspotMap = Symbol("hotspotMap"),
	$mutationCallback = Symbol("mutationCallback"),
	$observer = Symbol("observer"),
	$addHotspot = Symbol("addHotspot"),
	$removeHotspot = Symbol("removeHotspot"),
	worldToModel = new Matrix4;
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
var durl = function(c) {
	return URL.createObjectURL(new Blob([c], {
		type: "text/javascript"
	}))
};
try {
	URL.revokeObjectURL(durl(""))
} catch (e) {
	durl = function(c) {
		return "data:application/javascript;charset=UTF-8," + encodeURI(c)
	}
}
var u8 = Uint8Array,
	u16 = Uint16Array,
	u32 = Uint32Array,
	fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
	fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
	clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
	freb = function(eb, start) {
		for (var b = new u16(31), i = 0; i < 31; ++i) b[i] = start += 1 << eb[i - 1];
		for (var r = new u32(b[30]), i = 1; i < 30; ++i)
			for (var j = b[i]; j < b[i + 1]; ++j) r[j] = j - b[i] << 5 | i;
		return [b, r]
	},
	_a = freb(fleb, 2),
	fl = _a[0],
	revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
for (var revfd = freb(fdeb, 0)[1], rev = new u16(32768), i = 0; i < 32768; ++i) {
	var x = (43690 & i) >>> 1 | (21845 & i) << 1;
	x = (61680 & (x = (52428 & x) >>> 2 | (13107 & x) << 2)) >>> 4 | (3855 & x) << 4, rev[i] = ((65280 & x) >>> 8 | (255 & x) << 8) >>> 1
}
for (var hMap = function(cd, mb, r) {
		for (var co, s = cd.length, i = 0, l = new u16(mb); i < s; ++i) ++l[cd[i] - 1];
		var le = new u16(mb);
		for (i = 0; i < mb; ++i) le[i] = le[i - 1] + l[i - 1] << 1;
		if (r) {
			co = new u16(1 << mb);
			var rvb = 15 - mb;
			for (i = 0; i < s; ++i)
				if (cd[i])
					for (var sv = i << 4 | cd[i], r_1 = mb - cd[i], v = le[cd[i] - 1]++ << r_1, m = v | (1 << r_1) - 1; v <= m; ++v) co[rev[v] >>> rvb] = sv
		} else
			for (i = 0, co = new u16(s); i < s; ++i) cd[i] && (co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i]);
		return co
	}, flt = new u8(288), i = 0; i < 144; ++i) flt[i] = 8;
for (var i = 144; i < 256; ++i) flt[i] = 9;
for (var i = 256; i < 280; ++i) flt[i] = 7;
for (var i = 280; i < 288; ++i) flt[i] = 8;
for (var fdt = new u8(32), i = 0; i < 32; ++i) fdt[i] = 5;
var flm = hMap(flt, 9, 0),
	fdm = hMap(fdt, 5, 0),
	shft = function(p) {
		return (p / 8 | 0) + (7 & p && 1)
	},
	slc = function(v, s, e) {
		(null == s || s < 0) && (s = 0), (null == e || e > v.length) && (e = v.length);
		var n = new(v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
		return n.set(v.subarray(s, e)), n
	},
	wbits = function(d, p, v) {
		v <<= 7 & p;
		var o = p / 8 | 0;
		d[o] |= v, d[o + 1] |= v >>> 8
	},
	wbits16 = function(d, p, v) {
		v <<= 7 & p;
		var o = p / 8 | 0;
		d[o] |= v, d[o + 1] |= v >>> 8, d[o + 2] |= v >>> 16
	},
	hTree = function(d, mb) {
		for (var t = [], i = 0; i < d.length; ++i) d[i] && t.push({
			s: i,
			f: d[i]
		});
		var s = t.length,
			t2 = t.slice();
		if (!s) return [et, 0];
		if (1 == s) {
			var v = new u8(t[0].s + 1);
			return v[t[0].s] = 1, [v, 1]
		}
		t.sort(function(a, b) {
			return a.f - b.f
		}), t.push({
			s: -1,
			f: 25001
		});
		var l = t[0],
			r = t[1],
			i0 = 0,
			i1 = 1,
			i2 = 2;
		for (t[0] = {
				s: -1,
				f: l.f + r.f,
				l: l,
				r: r
			}; i1 != s - 1;) l = t[t[i0].f < t[i2].f ? i0++ : i2++], r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++], t[i1++] = {
			s: -1,
			f: l.f + r.f,
			l: l,
			r: r
		};
		for (var maxSym = t2[0].s, i = 1; i < s; ++i) t2[i].s > maxSym && (maxSym = t2[i].s);
		var tr = new u16(maxSym + 1),
			mbt = ln(t[i1 - 1], tr, 0);
		if (mbt > mb) {
			var i = 0,
				dt = 0,
				lft = mbt - mb,
				cst = 1 << lft;
			for (t2.sort(function(a, b) {
					return tr[b.s] - tr[a.s] || a.f - b.f
				}); i < s; ++i) {
				var i2_1 = t2[i].s;
				if (tr[i2_1] > mb) dt += cst - (1 << mbt - tr[i2_1]), tr[i2_1] = mb;
				else break
			}
			for (dt >>>= lft; dt > 0;) {
				var i2_2 = t2[i].s;
				tr[i2_2] < mb ? dt -= 1 << mb - tr[i2_2]++ - 1 : ++i
			}
			for (; i >= 0 && dt; --i) {
				var i2_3 = t2[i].s;
				tr[i2_3] == mb && (--tr[i2_3], ++dt)
			}
			mbt = mb
		}
		return [new u8(tr), mbt]
	},
	ln = function(n, l, d) {
		return -1 == n.s ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d
	},
	lc = function(c) {
		for (var s = c.length; s && !c[--s];);
		for (var cl = new u16(++s), cli = 0, cln = c[0], cls = 1, w = function(v) {
				cl[cli++] = v
			}, i = 1; i <= s; ++i)
			if (c[i] == cln && i != s) ++cls;
			else {
				if (!cln && cls > 2) {
					for (; cls > 138; cls -= 138) w(32754);
					cls > 2 && (w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305), cls = 0)
				} else if (cls > 3) {
					for (w(cln), --cls; cls > 6; cls -= 6) w(8304);
					cls > 2 && (w(cls - 3 << 5 | 8208), cls = 0)
				}
				for (; cls--;) w(cln);
				cls = 1, cln = c[i]
			} return [cl.subarray(0, cli), s]
	},
	clen = function(cf, cl) {
		for (var l = 0, i = 0; i < cl.length; ++i) l += cf[i] * cl[i];
		return l
	},
	wfblk = function(out, pos, dat) {
		var s = dat.length,
			o = shft(pos + 2);
		out[o] = 255 & s, out[o + 1] = s >>> 8, out[o + 2] = 255 ^ out[o], out[o + 3] = 255 ^ out[o + 1];
		for (var i = 0; i < s; ++i) out[o + i + 4] = dat[i];
		return (o + 4 + s) * 8
	},
	wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
		wbits(out, p++, final), ++lf[256];
		for (var lm, ll, dm, dl, _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1], _b = hTree(df, 15), ddt = _b[0], mdb = _b[1], _c = lc(dlt), lclt = _c[0], nlc = _c[1], _d = lc(ddt), lcdt = _d[0], ndc = _d[1], lcfreq = new u16(19), i = 0; i < lclt.length; ++i) lcfreq[31 & lclt[i]]++;
		for (var i = 0; i < lcdt.length; ++i) lcfreq[31 & lcdt[i]]++;
		for (var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1], nlcc = 19; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);
		var flen = bl + 5 << 3,
			ftlen = clen(lf, flt) + clen(df, fdt) + eb,
			dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
		if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
		if (wbits(out, p, 1 + (dtlen < ftlen)), p += 2, dtlen < ftlen) {
			lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
			var llm = hMap(lct, mlcb, 0);
			wbits(out, p, nlc - 257), wbits(out, p + 5, ndc - 1), wbits(out, p + 10, nlcc - 4), p += 14;
			for (var i = 0; i < nlcc; ++i) wbits(out, p + 3 * i, lct[clim[i]]);
			p += 3 * nlcc;
			for (var lcts = [lclt, lcdt], it = 0; it < 2; ++it)
				for (var clct = lcts[it], i = 0; i < clct.length; ++i) {
					var len = 31 & clct[i];
					wbits(out, p, llm[len]), p += lct[len], len > 15 && (wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12)
				}
		} else lm = flm, ll = flt, dm = fdm, dl = fdt;
		for (var i = 0; i < li; ++i)
			if (syms[i] > 255) {
				var len = syms[i] >>> 18 & 31;
				wbits16(out, p, lm[len + 257]), p += ll[len + 257], len > 7 && (wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len]);
				var dst = 31 & syms[i];
				wbits16(out, p, dm[dst]), p += dl[dst], dst > 3 && (wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst])
			} else wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
		return wbits16(out, p, lm[256]), p + ll[256]
	},
	deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
	et = new u8(0),
	dflt = function(dat, lvl, plvl, pre, post, lst) {
		var s = dat.length,
			o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7e3)) + post),
			w = o.subarray(pre, o.length - post),
			pos = 0;
		if (!lvl || s < 8)
			for (var i = 0; i <= s; i += 65535) {
				var e = i + 65535;
				e < s ? pos = wfblk(w, pos, dat.subarray(i, e)) : (w[i] = lst, pos = wfblk(w, pos, dat.subarray(i, s)))
			} else {
				for (var opt = deo[lvl - 1], n = opt >>> 13, c = 8191 & opt, msk_1 = (1 << plvl) - 1, prev = new u16(32768), head = new u16(msk_1 + 1), bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1, hsh = function(i) {
						return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1
					}, syms = new u32(25e3), lf = new u16(288), df = new u16(32), lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0; i < s; ++i) {
					var hv = hsh(i),
						imod = 32767 & i,
						pimod = head[hv];
					if (prev[imod] = pimod, head[hv] = imod, wi <= i) {
						var rem = s - i;
						if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
							pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos), li = lc_1 = eb = 0, bs = i;
							for (var j = 0; j < 286; ++j) lf[j] = 0;
							for (var j = 0; j < 30; ++j) df[j] = 0
						}
						var l = 2,
							d = 0,
							ch_1 = c,
							dif = imod - pimod & 32767;
						if (rem > 2 && hv == hsh(i - dif))
							for (var maxn = Math.min(n, rem) - 1, maxd = Math.min(32767, i), ml = Math.min(258, rem); dif <= maxd && --ch_1 && imod != pimod;) {
								if (dat[i + l] == dat[i + l - dif]) {
									for (var nl = 0; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);
									if (nl > l) {
										if (l = nl, d = dif, nl > maxn) break;
										for (var mmd = Math.min(dif, nl - 2), md = 0, j = 0; j < mmd; ++j) {
											var ti = i - dif + j + 32768 & 32767,
												pti = prev[ti],
												cd = ti - pti + 32768 & 32767;
											cd > md && (md = cd, pimod = ti)
										}
									}
								}
								pimod = prev[imod = pimod], dif += imod - pimod + 32768 & 32767
							}
						if (d) {
							syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
							var lin = 31 & revfl[l],
								din = 31 & revfd[d];
							eb += fleb[lin] + fdeb[din], ++lf[257 + lin], ++df[din], wi = i + l, ++lc_1
						} else syms[li++] = dat[i], ++lf[dat[i]]
					}
				}
				pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos), !lst && 7 & pos && (pos = wfblk(w, pos + 1, et))
			}
		return slc(o, 0, pre + shft(pos) + post)
	},
	crct = function() {
		for (var t = new u32(256), i = 0; i < 256; ++i) {
			for (var c = i, k = 9; --k;) c = (1 & c && 3988292384) ^ c >>> 1;
			t[i] = c
		}
		return t
	}(),
	crc = function() {
		var c = -1;
		return {
			p: function(d) {
				for (var cr = c, i = 0; i < d.length; ++i) cr = crct[255 & cr ^ d[i]] ^ cr >>> 8;
				c = cr
			},
			d: function() {
				return ~c
			}
		}
	},
	mrg = function(a, b) {
		var o = {};
		for (var k in a) o[k] = a[k];
		for (var k in b) o[k] = b[k];
		return o
	},
	wbytes = function(d, b, v) {
		for (; v; ++b) d[b] = v, v >>>= 8
	},
	fltn = function(d, p, t, o) {
		for (var k in d) {
			var val = d[k],
				n = p + k;
			val instanceof u8 ? t[n] = [val, o] : Array.isArray(val) ? t[n] = [val[0], mrg(o, val[1])] : fltn(val, n + "/", t, o)
		}
	},
	te = "undefined" != typeof TextEncoder && new TextEncoder,
	td = "undefined" != typeof TextDecoder && new TextDecoder;
try {
	td.decode(et, {
		stream: !0
	})
} catch (e) {}

function strToU8(str, latin1) {
	if (latin1) {
		for (var ar_1 = new u8(str.length), i = 0; i < str.length; ++i) ar_1[i] = str.charCodeAt(i);
		return ar_1
	}
	if (te) return te.encode(str);
	for (var l = str.length, ar = new u8(str.length + (str.length >> 1)), ai = 0, w = function(v) {
			ar[ai++] = v
		}, i = 0; i < l; ++i) {
		if (ai + 5 > ar.length) {
			var n = new u8(ai + 8 + (l - i << 1));
			n.set(ar), ar = n
		}
		var c = str.charCodeAt(i);
		c < 128 || latin1 ? w(c) : (c < 2048 ? w(192 | c >> 6) : (c > 55295 && c < 57344 ? (w(240 | (c = 65536 + (1047552 & c) | 1023 & str.charCodeAt(++i)) >> 18), w(128 | c >> 12 & 63)) : w(224 | c >> 12), w(128 | c >> 6 & 63)), w(128 | 63 & c))
	}
	return slc(ar, 0, ai)
}
var exfl = function(ex) {
		var le = 0;
		if (ex)
			for (var k in ex) {
				var l = ex[k].length;
				if (l > 65535) throw "extra field too long";
				le += l + 4
			}
		return le
	},
	wzh = function(d, b, f, fn, u, c, ce, co) {
		var fl = fn.length,
			ex = f.extra,
			col = co && co.length,
			exl = exfl(ex);
		wbytes(d, b, null != ce ? 33639248 : 67324752), b += 4, null != ce && (d[b++] = 20, d[b++] = f.os), d[b] = 20, b += 2, d[b++] = f.flag << 1 | (null == c && 8), d[b++] = u && 8, d[b++] = 255 & f.compression, d[b++] = f.compression >> 8;
		var dt = new Date(null == f.mtime ? Date.now() : f.mtime),
			y = dt.getFullYear() - 1980;
		if (y < 0 || y > 119) throw "date not in range 1980-2099";
		if (wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4, null != c && (wbytes(d, b, f.crc), wbytes(d, b + 4, c), wbytes(d, b + 8, f.size)), wbytes(d, b + 12, fl), wbytes(d, b + 14, exl), b += 16, null != ce && (wbytes(d, b, col), wbytes(d, b + 6, f.attrs), wbytes(d, b + 10, ce), b += 14), d.set(fn, b), b += fl, exl)
			for (var k in ex) {
				var exf = ex[k],
					l = exf.length;
				wbytes(d, b, +k), wbytes(d, b + 2, l), d.set(exf, b + 4), b += 4 + l
			}
		return col && (d.set(co, b), b += col), b
	},
	wzf = function(o, b, c, d, e) {
		wbytes(o, b, 101010256), wbytes(o, b + 8, c), wbytes(o, b + 10, c), wbytes(o, b + 12, d), wbytes(o, b + 16, e)
	};
class USDZExporter {
	async parse(scene, options = {}) {
		var options1;
		options = Object.assign({
			ar: {
				anchoring: {
					type: "plane"
				},
				planeAnchoring: {
					alignment: "horizontal"
				}
			},
			quickLookCompatible: !1
		}, options);
		let files = {},
			modelFileName = "model.usda";
		files[modelFileName] = null;
		let output = buildHeader();
		output += (options1 = options, `def Xform "Root"
{
	def Scope "Scenes" (
		kind = "sceneLibrary"
	)
	{
		def Xform "Scene" (
			customData = {
				bool preliminary_collidesWithEnvironment = 0
				string sceneName = "Scene"
			}
			sceneName = "Scene"
		)
		{
		token preliminary:anchoring:type = "${options1.ar.anchoring.type}"
		token preliminary:planeAnchoring:alignment = "${options1.ar.planeAnchoring.alignment}"

`);
		let materials = {},
			textures = {};
		for (let id in scene.traverseVisible(object => {
				if (object.isMesh) {
					let geometry = object.geometry,
						material = object.material;
					if (material.isMeshStandardMaterial) {
						let geometryFileName = "geometries/Geometry_" + geometry.id + ".usda";
						if (!(geometryFileName in files)) {
							var dataToInsert;
							let output;
							let meshObject = function(geometry) {
								let mesh = function(geometry) {
									var geometry1;
									let attributes = geometry.attributes,
										count = attributes.position.count;
									return `
	def Mesh "Geometry"
	{
		int[] faceVertexCounts = [${Array((null!==(geometry1=geometry).index?geometry1.index.count:geometry1.attributes.position.count)/3).fill(3).join(", ")}]
		int[] faceVertexIndices = [${function(geometry){let index=geometry.index,array=[];if(null!==index)for(let i=0;i<index.count;i++)array.push(index.getX(i));else{let length=geometry.attributes.position.count;for(let i=0;i<length;i++)array.push(i)}return array.join(", ")}(geometry)}]
		normal3f[] normals = [${buildVector3Array(attributes.normal,count)}] (
			interpolation = "vertex"
		)
		point3f[] points = [${buildVector3Array(attributes.position,count)}]
${function(attributes){let string="";for(let i=0;i<4;i++){let id=i>0?i:"",attribute=attributes["uv"+id];void 0!==attribute&&(string+=`
		texCoord2f[] primvars:st${id} = [${function(attribute){let array=[];for(let i=0;i<attribute.count;i++){let x=attribute.getX(i),y=attribute.getY(i);array.push(`(${x.toPrecision(7)}, ${1-y.toPrecision(7)})`)}return array.join(", ")}(attribute)}] (
			interpolation = "vertex"
		)`)}return string}(attributes)}
		uniform token subdivisionScheme = "none"
	}
`
								}(geometry);
								return `
def "Geometry"
{
${mesh}
}
`
							}(geometry);
							files[geometryFileName] = (dataToInsert = meshObject, strToU8(buildHeader() + dataToInsert))
						}
						material.uuid in materials || (materials[material.uuid] = material), output += function(object, geometry, material) {
							let name = "Object_" + object.id,
								transform = buildMatrix(object.matrixWorld);
							return 0 > object.matrixWorld.determinant() && console.warn("THREE.USDZExporter: USDZ does not support negative scales", object), `def Xform "${name}" (
	prepend references = @./geometries/Geometry_${geometry.id}.usda@</Geometry>
	prepend apiSchemas = ["MaterialBindingAPI"]
)
{
	matrix4d xformOp:transform = ${transform}
	uniform token[] xformOpOrder = ["xformOp:transform"]

	rel material:binding = </Materials/Material_${material.id}>
}

`
						}(object, geometry, material)
					} else console.warn("THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)", object)
				} else object.isCamera && (output += function(camera) {
					let name = camera.name ? camera.name : "Camera_" + camera.id,
						transform = buildMatrix(camera.matrixWorld);
					return (0 > camera.matrixWorld.determinant() && console.warn("THREE.USDZExporter: USDZ does not support negative scales", camera), camera.isOrthographicCamera) ? `def Camera "${name}"
		{
			matrix4d xformOp:transform = ${transform}
			uniform token[] xformOpOrder = ["xformOp:transform"]

			float2 clippingRange = (${camera.near.toPrecision(7)}, ${camera.far.toPrecision(7)})
			float horizontalAperture = ${((Math.abs(camera.left)+Math.abs(camera.right))*10).toPrecision(7)}
			float verticalAperture = ${((Math.abs(camera.top)+Math.abs(camera.bottom))*10).toPrecision(7)}
			token projection = "orthographic"
		}
	
	` : `def Camera "${name}"
		{
			matrix4d xformOp:transform = ${transform}
			uniform token[] xformOpOrder = ["xformOp:transform"]

			float2 clippingRange = (${camera.near.toPrecision(7)}, ${camera.far.toPrecision(7)})
			float focalLength = ${camera.getFocalLength().toPrecision(7)}
			float focusDistance = ${camera.focus.toPrecision(7)}
			float horizontalAperture = ${camera.getFilmWidth().toPrecision(7)}
			token projection = "perspective"
			float verticalAperture = ${camera.getFilmHeight().toPrecision(7)}
		}
	
	`
				}(object))
			}), output += `
		}
	}
}

` + function(materials, textures, quickLookCompatible = !1) {
				let array = [];
				for (let uuid in materials) {
					let material = materials[uuid];
					array.push(function(material, textures, quickLookCompatible = !1) {
						let inputs = [],
							samplers = [];

						function buildTexture(texture, mapType, color) {
							var color1;
							let id = texture.source.id + "_" + texture.flipY;
							textures[id] = texture;
							let uv = texture.channel > 0 ? "st" + texture.channel : "st",
								WRAPPINGS = {
									1e3: "repeat",
									1001: "clamp",
									1002: "mirror"
								},
								repeat = texture.repeat.clone(),
								offset = texture.offset.clone(),
								rotation = texture.rotation,
								xRotationOffset = Math.sin(rotation),
								yRotationOffset = Math.cos(rotation);
							return offset.y = 1 - offset.y - repeat.y, quickLookCompatible ? (offset.x = offset.x / repeat.x, offset.y = offset.y / repeat.y, offset.x += xRotationOffset / repeat.x, offset.y += yRotationOffset - 1) : (offset.x += xRotationOffset * repeat.x, offset.y += (1 - yRotationOffset) * repeat.y), `
		def Shader "PrimvarReader_${mapType}"
		{
			uniform token info:id = "UsdPrimvarReader_float2"
			float2 inputs:fallback = (0.0, 0.0)
			token inputs:varname = "${uv}"
			float2 outputs:result
		}

		def Shader "Transform2d_${mapType}"
		{
			uniform token info:id = "UsdTransform2d"
			token inputs:in.connect = </Materials/Material_${material.id}/PrimvarReader_${mapType}.outputs:result>
			float inputs:rotation = ${(180/Math.PI*rotation).toFixed(7)}
			float2 inputs:scale = ${buildVector2(repeat)}
			float2 inputs:translation = ${buildVector2(offset)}
			float2 outputs:result
		}

		def Shader "Texture_${texture.id}_${mapType}"
		{
			uniform token info:id = "UsdUVTexture"
			asset inputs:file = @textures/Texture_${id}.png@
			float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>
			${void 0!==color?"float4 inputs:scale = "+(color1=color,`(${color1.r}, ${color1.g}, ${color1.b}, 1.0)`):""}
			token inputs:sourceColorSpace = "${""===texture.colorSpace?"raw":"sRGB"}"
			token inputs:wrapS = "${WRAPPINGS[texture.wrapS]}"
			token inputs:wrapT = "${WRAPPINGS[texture.wrapT]}"
			float outputs:r
			float outputs:g
			float outputs:b
			float3 outputs:rgb
			${material.transparent||material.alphaTest>0?"float outputs:a":""}
		}`
						}
						return 2 === material.side && console.warn("THREE.USDZExporter: USDZ does not support double sided materials", material), null !== material.map ? (inputs.push(`			color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`), material.transparent ? inputs.push(`			float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`) : material.alphaTest > 0 && (inputs.push(`			float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`), inputs.push(`			float inputs:opacityThreshold = ${material.alphaTest}`)), samplers.push(buildTexture(material.map, "diffuse", material.color))) : inputs.push(`			color3f inputs:diffuseColor = ${buildColor(material.color)}`), null !== material.emissiveMap ? (inputs.push(`			color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`), samplers.push(buildTexture(material.emissiveMap, "emissive"))) : material.emissive.getHex() > 0 && inputs.push(`			color3f inputs:emissiveColor = ${buildColor(material.emissive)}`), null !== material.normalMap && (inputs.push(`			normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`), samplers.push(buildTexture(material.normalMap, "normal"))), null !== material.aoMap && (inputs.push(`			float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`), samplers.push(buildTexture(material.aoMap, "occlusion"))), null !== material.roughnessMap && 1 === material.roughness ? (inputs.push(`			float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`), samplers.push(buildTexture(material.roughnessMap, "roughness"))) : inputs.push(`			float inputs:roughness = ${material.roughness}`), null !== material.metalnessMap && 1 === material.metalness ? (inputs.push(`			float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`), samplers.push(buildTexture(material.metalnessMap, "metallic"))) : inputs.push(`			float inputs:metallic = ${material.metalness}`), null !== material.alphaMap ? (inputs.push(`			float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.alphaMap.id}_opacity.outputs:r>`), inputs.push(`			float inputs:opacityThreshold = 0.0001`), samplers.push(buildTexture(material.alphaMap, "opacity"))) : inputs.push(`			float inputs:opacity = ${material.opacity}`), material.isMeshPhysicalMaterial && (inputs.push(`			float inputs:clearcoat = ${material.clearcoat}`), inputs.push(`			float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`), inputs.push(`			float inputs:ior = ${material.ior}`)), `
	def Material "Material_${material.id}"
	{
		def Shader "PreviewSurface"
		{
			uniform token info:id = "UsdPreviewSurface"
${inputs.join("\n")}
			int inputs:useSpecularWorkflow = 0
			token outputs:surface
		}

		token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>

${samplers.join("\n")}

	}
`
					}(material, textures, quickLookCompatible))
				}
				return `def "Materials"
{
${array.join("")}
}

`
			}(materials, textures, options.quickLookCompatible), files[modelFileName] = strToU8(output), output = null, textures) {
			let texture = textures[id];
			!0 === texture.isCompressedTexture && (texture = decompress(texture));
			let canvas = function(image, flipY) {
					if ("undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && image instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap) {
						let scale = 1024 / Math.max(image.width, image.height),
							canvas = document.createElement("canvas");
						canvas.width = image.width * Math.min(1, scale), canvas.height = image.height * Math.min(1, scale);
						let context = canvas.getContext("2d");
						return !0 === flipY && (context.translate(0, canvas.height), context.scale(1, -1)), context.drawImage(image, 0, 0, canvas.width, canvas.height), canvas
					}
					throw Error("THREE.USDZExporter: No valid image data found. Unable to process texture.")
				}(texture.image, texture.flipY),
				blob = await new Promise(resolve => canvas.toBlob(resolve, "image/png", 1));
			files[`textures/Texture_${id}.png`] = new Uint8Array(await blob.arrayBuffer())
		}
		let offset = 0;
		for (let filename in files) {
			let file = files[filename],
				offsetMod64 = 63 & (offset += 34 + filename.length);
			if (4 !== offsetMod64) {
				let padding = new Uint8Array(64 - offsetMod64);
				files[filename] = [file, {
					extra: {
						12345: padding
					}
				}]
			}
			offset = file.length
		}
		return function(data, opts) {
			opts || (opts = {});
			var r = {},
				files = [];
			fltn(data, "", r, opts);
			var o = 0,
				tot = 0;
			for (var fn in r) {
				var _a = r[fn],
					file = _a[0],
					p = _a[1],
					compression = 0 == p.level ? 0 : 8,
					f = strToU8(fn),
					s = f.length,
					com = p.comment,
					m = com && strToU8(com),
					ms = m && m.length,
					exl = exfl(p.extra);
				if (s > 65535) throw "filename too long";
				var d = compression ? function(data, opts) {
						var opt;
						return dflt(data, null == (opt = opts || {}).level ? 6 : opt.level, null == opt.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(data.length)))) : 12 + opt.mem, 0, 0, !0)
					}(file, p) : file,
					l = d.length,
					c = crc();
				c.p(file), files.push(mrg(p, {
					size: file.length,
					crc: c.d(),
					c: d,
					f: f,
					m: m,
					u: s != fn.length || m && com.length != ms,
					o: o,
					compression: compression
				})), o += 30 + s + exl + l, tot += 76 + 2 * (s + exl) + (ms || 0) + l
			}
			for (var out = new u8(tot + 22), oe = o, cdl = tot - o, i = 0; i < files.length; ++i) {
				var f = files[i];
				wzh(out, f.o, f, f.f, f.u, f.c.length);
				var badd = 30 + f.f.length + exfl(f.extra);
				out.set(f.c, f.o + badd), wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0)
			}
			return wzf(out, o, files.length, cdl, oe), out
		}(files, {
			level: 0
		})
	}
}

function buildHeader() {
	return `#usda 1.0
(
	customLayerData = {
		string creator = "Three.js USDZExporter"
	}
	defaultPrim = "Root"
	metersPerUnit = 1
	upAxis = "Y"
)

`
}

function buildMatrix(matrix) {
	let array = matrix.elements;
	return `( ${buildMatrixRow(array,0)}, ${buildMatrixRow(array,4)}, ${buildMatrixRow(array,8)}, ${buildMatrixRow(array,12)} )`
}

function buildMatrixRow(array, offset) {
	return `(${array[offset+0]}, ${array[offset+1]}, ${array[offset+2]}, ${array[offset+3]})`
}

function buildVector3Array(attribute, count) {
	if (void 0 === attribute) return console.warn("USDZExporter: Normals missing."), Array(count).fill("(0, 0, 0)").join(", ");
	let array = [];
	for (let i = 0; i < attribute.count; i++) {
		let x = attribute.getX(i),
			y = attribute.getY(i),
			z = attribute.getZ(i);
		array.push(`(${x.toPrecision(7)}, ${y.toPrecision(7)}, ${z.toPrecision(7)})`)
	}
	return array.join(", ")
}

function buildColor(color) {
	return `(${color.r}, ${color.g}, ${color.b})`
}

function buildVector2(vector) {
	return `(${vector.x}, ${vector.y})`
}
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$2 = function(decorators, target, key, desc) {
	for (var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, i = decorators.length - 1; i >= 0; i--)(d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	return c > 3 && r && Object.defineProperty(target, key, r), r
};
let isWebXRBlocked = !1,
	isSceneViewerBlocked = !1,
	noArViewerSigil = "#model-viewer-no-ar-fallback",
	deserializeARModes = (allowedNames = ["quick-look", "scene-viewer", "webxr", "none"], valueString => {
		try {
			let expressions = parseExpressions(valueString),
				names = (expressions.length ? expressions[0].terms : []).filter(valueNode => valueNode && "ident" === valueNode.type).map(valueNode => valueNode.value).filter(name => allowedNames.indexOf(name) > -1);
			return new Set(names)
		} catch (_error) {}
		return new Set
	}),
	ARMode = {
		QUICK_LOOK: "quick-look",
		SCENE_VIEWER: "scene-viewer",
		WEBXR: "webxr",
		NONE: "none"
	},
	$arButtonContainer = Symbol("arButtonContainer"),
	$enterARWithWebXR = Symbol("enterARWithWebXR"),
	$openSceneViewer = Symbol("openSceneViewer"),
	$openIOSARQuickLook = Symbol("openIOSARQuickLook"),
	$canActivateAR = Symbol("canActivateAR"),
	$arMode = Symbol("arMode"),
	$arModes = Symbol("arModes"),
	$arAnchor = Symbol("arAnchor"),
	$preload = Symbol("preload"),
	$onARButtonContainerClick = Symbol("onARButtonContainerClick"),
	$onARStatus = Symbol("onARStatus"),
	$onARTracking = Symbol("onARTracking"),
	$onARTap = Symbol("onARTap"),
	$selectARMode = Symbol("selectARMode"),
	$triggerLoad = Symbol("triggerLoad");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate$1 = function(decorators, target, key, desc) {
	for (var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, i = decorators.length - 1; i >= 0; i--)(d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	return c > 3 && r && Object.defineProperty(target, key, r), r
};
let RevealStrategy = {
		AUTO: "auto"
	},
	LoadingStrategy = {
		AUTO: "auto",
		EAGER: "eager"
	},
	$defaultProgressBarElement = Symbol("defaultProgressBarElement"),
	$posterContainerElement = Symbol("posterContainerElement"),
	$defaultPosterElement = Symbol("defaultPosterElement"),
	$shouldDismissPoster = Symbol("shouldDismissPoster"),
	$hidePoster = Symbol("hidePoster"),
	$modelIsRevealed = Symbol("modelIsRevealed"),
	$updateProgressBar = Symbol("updateProgressBar"),
	$ariaLabelCallToAction = Symbol("ariaLabelCallToAction"),
	$onProgress = Symbol("onProgress");
/* @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __decorate = function(decorators, target, key, desc) {
	for (var d, c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, i = decorators.length - 1; i >= 0; i--)(d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
	return c > 3 && r && Object.defineProperty(target, key, r), r
};
let rotationRateIntrinsics = {
		basis: [degreesToRadians(numberNode(Math.PI / 32, "rad"))],
		keywords: {
			auto: [null]
		}
	},
	$autoRotateStartTime = Symbol("autoRotateStartTime"),
	$radiansPerSecond = Symbol("radiansPerSecond"),
	$syncRotationRate = Symbol("syncRotationRate"),
	$onCameraChange = Symbol("onCameraChange"),
	ModelViewerElement = (ModelViewerElement => {
		var _a, _b, _c;
		class AnnotationModelViewerElement extends ModelViewerElement {
			constructor() {
				super(...arguments), this[_a] = new Map, this[_b] = mutations => {
					mutations.forEach(mutation => {
						mutation instanceof MutationRecord && "childList" !== mutation.type || (mutation.addedNodes.forEach(node => {
							this[$addHotspot](node)
						}), mutation.removedNodes.forEach(node => {
							this[$removeHotspot](node)
						}), this[$needsRender]())
					})
				}, this[_c] = new MutationObserver(this[$mutationCallback])
			}
			connectedCallback() {
				super.connectedCallback();
				for (let i = 0; i < this.children.length; ++i) this[$addHotspot](this.children[i]);
				let {
					ShadyDOM
				} = self;
				null == ShadyDOM ? this[$observer].observe(this, {
					childList: !0
				}) : this[$observer] = ShadyDOM.observeChildren(this, this[$mutationCallback])
			}
			disconnectedCallback() {
				super.disconnectedCallback();
				let {
					ShadyDOM
				} = self;
				null == ShadyDOM ? this[$observer].disconnect() : ShadyDOM.unobserveChildren(this[$observer])
			} [(_a = $hotspotMap, _b = $mutationCallback, _c = $observer, $tick)](time, delta) {
				super[$tick](time, delta);
				let scene = this[$scene],
					{
						annotationRenderer
					} = scene,
					camera = scene.getCamera();
				scene.shouldRender() && (scene.updateSurfaceHotspots(), scene.updateHotspotsVisibility(camera.position), annotationRenderer.domElement.style.display = "", annotationRenderer.render(scene, camera))
			}
			updateHotspot(config) {
				let hotspot = this[$hotspotMap].get(config.name);
				null != hotspot && (hotspot.updatePosition(config.position), hotspot.updateNormal(config.normal), hotspot.surface = config.surface, this[$needsRender]())
			}
			queryHotspot(name) {
				let hotspot = this[$hotspotMap].get(name);
				if (null == hotspot) return null;
				let position = toVector3D(hotspot.position),
					normal = toVector3D(hotspot.normal),
					facingCamera = hotspot.facingCamera,
					scene = this[$scene],
					camera = scene.getCamera(),
					vector = new Vector3;
				vector.setFromMatrixPosition(hotspot.matrixWorld), vector.project(camera);
				let widthHalf = scene.width / 2,
					heightHalf = scene.height / 2;
				vector.x = vector.x * widthHalf + widthHalf, vector.y = -(vector.y * heightHalf) + heightHalf;
				let canvasPosition = toVector3D(new Vector3(vector.x, vector.y, vector.z));
				return Number.isFinite(canvasPosition.x) && Number.isFinite(canvasPosition.y) ? {
					position,
					normal,
					canvasPosition,
					facingCamera
				} : null
			}
			positionAndNormalFromPoint(pixelX, pixelY) {
				let scene = this[$scene],
					ndcPosition = scene.getNDC(pixelX, pixelY),
					hit = scene.positionAndNormalFromPoint(ndcPosition);
				if (null == hit) return null;
				worldToModel.copy(scene.target.matrixWorld).invert();
				let position = toVector3D(hit.position.applyMatrix4(worldToModel)),
					normal = toVector3D(hit.normal.transformDirection(worldToModel)),
					uv = null;
				return null != hit.uv && (uv = toVector2D(hit.uv)), {
					position: position,
					normal: normal,
					uv: uv
				}
			}
			surfaceFromPoint(pixelX, pixelY) {
				let scene = this[$scene],
					ndcPosition = scene.getNDC(pixelX, pixelY);
				return scene.surfaceFromPoint(ndcPosition)
			} [$addHotspot](node) {
				if (!(node instanceof HTMLElement && 0 === node.slot.indexOf("hotspot"))) return;
				let hotspot = this[$hotspotMap].get(node.slot);
				null != hotspot ? hotspot.increment() : (hotspot = new Hotspot({
					name: node.slot,
					position: node.dataset.position,
					normal: node.dataset.normal,
					surface: node.dataset.surface
				}), this[$hotspotMap].set(node.slot, hotspot), this[$scene].addHotspot(hotspot)), this[$scene].queueRender()
			} [$removeHotspot](node) {
				if (!(node instanceof HTMLElement)) return;
				let hotspot = this[$hotspotMap].get(node.slot);
				hotspot && (hotspot.decrement() && (this[$scene].removeHotspot(hotspot), this[$hotspotMap].delete(node.slot)), this[$scene].queueRender())
			}
		}
		return AnnotationModelViewerElement
	})((ModelViewerElement => {
		var _a, _b, _c;
		class SceneGraphModelViewerElement extends ModelViewerElement {
			constructor() {
				super(...arguments), this[_a] = void 0, this[_b] = null, this[_c] = null, this.variantName = null, this.orientation = "0 0 0", this.scale = "1 1 1"
			}
			get model() {
				return this[$model]
			}
			get availableVariants() {
				return this.model ? this.model[$availableVariants]() : []
			}
			get originalGltfJson() {
				return this[$originalGltfJson]
			} [(_a = $model, _b = $currentGLTF, _c = $originalGltfJson, $getOnUpdateMethod)]() {
				return () => {
					this[$needsRender]()
				}
			} [$buildTexture](texture) {
				return texture.colorSpace = SRGBColorSpace, texture.wrapS = 1e3, texture.wrapT = 1e3, new Texture(this[$getOnUpdateMethod](), texture)
			}
			async createTexture(uri, type = "image/png") {
				let {
					textureUtils
				} = this[$renderer], texture = await textureUtils.loadImage(uri);
				return texture.userData.mimeType = type, this[$buildTexture](texture)
			}
			async createLottieTexture(uri, quality = 1) {
				let {
					textureUtils
				} = this[$renderer], texture = await textureUtils.loadLottie(uri, quality);
				return this[$buildTexture](texture)
			}
			createVideoTexture(uri) {
				let video = document.createElement("video");
				video.crossOrigin = this.withCredentials ? "use-credentials" : "anonymous", video.src = uri, video.muted = !0, video.playsInline = !0, video.loop = !0, video.play();
				let texture = new VideoTexture(video);
				return this[$buildTexture](texture)
			}
			createCanvasTexture() {
				let texture = new CanvasTexture(document.createElement("canvas"));
				return this[$buildTexture](texture)
			}
			async updated(changedProperties) {
				if (super.updated(changedProperties), changedProperties.has("variantName")) {
					let updateVariantProgress = this[$progressTracker].beginActivity("variant-update");
					updateVariantProgress(.1);
					let model = this[$model],
						{
							variantName
						} = this;
					null != model && (await model[$switchVariant](variantName), this[$needsRender](), this.dispatchEvent(new CustomEvent("variant-applied"))), updateVariantProgress(1)
				}
				if (changedProperties.has("orientation") || changedProperties.has("scale")) {
					if (!this.loaded) return;
					let scene = this[$scene];
					scene.applyTransform(), scene.updateBoundingBox(), scene.updateShadow(), this[$renderer].arRenderer.onUpdateScene(), this[$needsRender]()
				}
			} [$onModelLoad]() {
				super[$onModelLoad]();
				let {
					currentGLTF
				} = this[$scene];
				if (null != currentGLTF) {
					let {
						correlatedSceneGraph
					} = currentGLTF;
					null != correlatedSceneGraph && currentGLTF !== this[$currentGLTF] && (this[$model] = new Model(correlatedSceneGraph, this[$getOnUpdateMethod]()), this[$originalGltfJson] = JSON.parse(JSON.stringify(correlatedSceneGraph.gltf))), "variants" in currentGLTF.userData && this.requestUpdate("variantName")
				}
				this[$currentGLTF] = currentGLTF
			}
			async exportScene(options) {
				let scene = this[$scene];
				return new Promise(async (resolve, reject) => {
					let opts = {
						binary: !0,
						onlyVisible: !0,
						maxTextureSize: 1 / 0,
						includeCustomExtensions: !1,
						forceIndices: !1
					};
					Object.assign(opts, options), opts.animations = scene.animations, opts.truncateDrawRange = !0;
					let shadow = scene.shadow,
						visible = !1;
					null != shadow && (visible = shadow.visible, shadow.visible = !1), await this[$model][$prepareVariantsForExport](), new GLTFExporter().register(writer => new GLTFExporterMaterialsVariantsExtension(writer)).parse(scene.model, gltf => resolve(new Blob([opts.binary ? gltf : JSON.stringify(gltf)], {
						type: opts.binary ? "application/octet-stream" : "application/json"
					})), () => reject("glTF export failed"), opts), null != shadow && (shadow.visible = visible)
				})
			}
			materialFromPoint(pixelX, pixelY) {
				let model = this[$model];
				if (null == model) return null;
				let scene = this[$scene],
					ndcCoords = scene.getNDC(pixelX, pixelY),
					hit = scene.hitFromPoint(ndcCoords);
				return null == hit || null == hit.face ? null : model[$materialFromPoint](hit)
			}
		}
		return __decorate$5([n$8({
			type: String,
			attribute: "variant-name"
		})], SceneGraphModelViewerElement.prototype, "variantName", void 0), __decorate$5([n$8({
			type: String,
			attribute: "orientation"
		})], SceneGraphModelViewerElement.prototype, "orientation", void 0), __decorate$5([n$8({
			type: String,
			attribute: "scale"
		})], SceneGraphModelViewerElement.prototype, "scale", void 0), SceneGraphModelViewerElement
	})((ModelViewerElement => {
		var _a, _b, _c;
		class StagingModelViewerElement extends ModelViewerElement {
			constructor() {
				super(...arguments), this.autoRotate = !1, this.autoRotateDelay = 3e3, this.rotationPerSecond = "auto", this[_a] = performance.now(), this[_b] = 0, this[_c] = event => {
					this.autoRotate && "user-interaction" === event.detail.source && (this[$autoRotateStartTime] = performance.now())
				}
			}
			connectedCallback() {
				super.connectedCallback(), this.addEventListener("camera-change", this[$onCameraChange]), this[$autoRotateStartTime] = performance.now()
			}
			disconnectedCallback() {
				super.disconnectedCallback(), this.removeEventListener("camera-change", this[$onCameraChange]), this[$autoRotateStartTime] = performance.now()
			}
			updated(changedProperties) {
				super.updated(changedProperties), changedProperties.has("autoRotate") && (this[$autoRotateStartTime] = performance.now())
			} [(_a = $autoRotateStartTime, _b = $radiansPerSecond, $syncRotationRate)](style) {
				this[$radiansPerSecond] = style[0]
			} [$tick](time, delta) {
				if (super[$tick](time, delta), !this.autoRotate || !this[$getModelIsVisible]() || this[$renderer].isPresenting) return;
				let rotationDelta = Math.min(delta, time - this[$autoRotateStartTime] - this.autoRotateDelay);
				rotationDelta > 0 && (this[$scene].yaw = this.turntableRotation + this[$radiansPerSecond] * rotationDelta * .001)
			}
			get turntableRotation() {
				return this[$scene].yaw
			}
			resetTurntableRotation(theta = 0) {
				this[$scene].yaw = theta
			}
		}
		return _c = $onCameraChange, __decorate([n$8({
			type: Boolean,
			attribute: "auto-rotate"
		})], StagingModelViewerElement.prototype, "autoRotate", void 0), __decorate([n$8({
			type: Number,
			attribute: "auto-rotate-delay"
		})], StagingModelViewerElement.prototype, "autoRotateDelay", void 0), __decorate([style({
			intrinsics: rotationRateIntrinsics,
			updateHandler: $syncRotationRate
		}), n$8({
			type: String,
			attribute: "rotation-per-second"
		})], StagingModelViewerElement.prototype, "rotationPerSecond", void 0), StagingModelViewerElement
	})((ModelViewerElement => {
		var _a, _b, _c;
		class EnvironmentModelViewerElement extends ModelViewerElement {
			constructor() {
				super(...arguments), this.environmentImage = null, this.skyboxImage = null, this.shadowIntensity = 0, this.shadowSoftness = 1, this.exposure = 1, this.toneMapping = "auto", this.skyboxHeight = "0", this[_a] = null, this[_b] = null, this[_c] = null
			}
			updated(changedProperties) {
				super.updated(changedProperties), changedProperties.has("shadowIntensity") && (this[$scene].setShadowIntensity(.5 * this.shadowIntensity), this[$needsRender]()), changedProperties.has("shadowSoftness") && (this[$scene].setShadowSoftness(this.shadowSoftness), this[$needsRender]()), changedProperties.has("exposure") && (this[$scene].exposure = this.exposure, this[$needsRender]()), changedProperties.has("toneMapping") && (this[$scene].toneMapping = "commerce" === this.toneMapping ? 5 : "agx" === this.toneMapping ? 6 : 4, this[$needsRender]()), (changedProperties.has("environmentImage") || changedProperties.has("skyboxImage")) && this[$shouldAttemptPreload]() && this[$updateEnvironment](), changedProperties.has("skyboxHeight") && (this[$scene].setGroundedSkybox(), this[$needsRender]())
			}
			hasBakedShadow() {
				return this[$scene].bakedShadows.size > 0
			}
			async [(_a = $currentEnvironmentMap, _b = $currentBackground, _c = $cancelEnvironmentUpdate, $updateEnvironment)]() {
				let {
					skyboxImage,
					environmentImage
				} = this;
				null != this[$cancelEnvironmentUpdate] && (this[$cancelEnvironmentUpdate](), this[$cancelEnvironmentUpdate] = null);
				let {
					textureUtils
				} = this[$renderer];
				if (null == textureUtils) return;
				let updateEnvProgress = this[$progressTracker].beginActivity("environment-update");
				try {
					let {
						environmentMap,
						skybox
					} = await textureUtils.generateEnvironmentMapAndSkybox(deserializeUrl(skyboxImage), environmentImage, progress => updateEnvProgress(clamp(progress, 0, 1)));
					this[$currentEnvironmentMap] !== environmentMap && (this[$currentEnvironmentMap] = environmentMap, this.dispatchEvent(new CustomEvent("environment-change"))), null != skybox ? this[$currentBackground] = skybox.name === environmentMap.name ? environmentMap : skybox : this[$currentBackground] = null, this[$scene].setEnvironmentAndSkybox(this[$currentEnvironmentMap], this[$currentBackground])
				} catch (errorOrPromise) {
					if (errorOrPromise instanceof Error) throw this[$scene].setEnvironmentAndSkybox(null, null), errorOrPromise
				} finally {
					updateEnvProgress(1)
				}
			}
		}
		return __decorate$7([n$8({
			type: String,
			attribute: "environment-image"
		})], EnvironmentModelViewerElement.prototype, "environmentImage", void 0), __decorate$7([n$8({
			type: String,
			attribute: "skybox-image"
		})], EnvironmentModelViewerElement.prototype, "skyboxImage", void 0), __decorate$7([n$8({
			type: Number,
			attribute: "shadow-intensity"
		})], EnvironmentModelViewerElement.prototype, "shadowIntensity", void 0), __decorate$7([n$8({
			type: Number,
			attribute: "shadow-softness"
		})], EnvironmentModelViewerElement.prototype, "shadowSoftness", void 0), __decorate$7([n$8({
			type: Number
		})], EnvironmentModelViewerElement.prototype, "exposure", void 0), __decorate$7([n$8({
			type: String,
			attribute: "tone-mapping"
		})], EnvironmentModelViewerElement.prototype, "toneMapping", void 0), __decorate$7([n$8({
			type: String,
			attribute: "skybox-height"
		})], EnvironmentModelViewerElement.prototype, "skyboxHeight", void 0), EnvironmentModelViewerElement
	})((ModelViewerElement => {
		var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
		class ControlsModelViewerElement extends ModelViewerElement {
			constructor() {
				super(...arguments), this.cameraControls = !1, this.cameraOrbit = DEFAULT_CAMERA_ORBIT, this.cameraTarget = "auto auto auto", this.fieldOfView = "auto", this.minCameraOrbit = "auto", this.maxCameraOrbit = "auto", this.minFieldOfView = "auto", this.maxFieldOfView = "auto", this.interactionPromptThreshold = 3e3, this.interactionPrompt = InteractionPromptStrategy.AUTO, this.interactionPromptStyle = InteractionPromptStyle.WIGGLE, this.orbitSensitivity = 1, this.zoomSensitivity = 1, this.panSensitivity = 1, this.touchAction = "none", this.disableZoom = !1, this.disablePan = !1, this.disableTap = !1, this.interpolationDecay = 50, this[_a] = this.shadowRoot.querySelector(".interaction-prompt"), this[_b] = this.shadowRoot.querySelector("#prompt"), this[_c] = [this.shadowRoot.querySelector("#finger0"), this.shadowRoot.querySelector("#finger1")], this[_d] = this.shadowRoot.querySelector(".pan-target"), this[_e] = 0, this[_f] = 1 / 0, this[_g] = !1, this[_h] = !1, this[_j] = ChangeSource.AUTOMATIC, this[_k] = new SmoothControls(this[$scene].camera, this[$userInputElement], this[$scene]), this[_l] = new Spherical, this[_m] = !1, this[_o] = !1, this[_p] = !1, this[_q] = () => {
					let source = this[$controls].changeSource;
					this[$cancellationSource] = source, source === ChangeSource.USER_INTERACTION && (this[$userHasInteracted] = !0, this[$deferInteractionPrompt]())
				}, this[_r] = () => {
					this[$updateAria](), this[$needsRender]();
					let source = this[$controls].changeSource;
					this.dispatchEvent(new CustomEvent("camera-change", {
						detail: {
							source
						}
					}))
				}, this[_s] = event => {
					this[$container].classList.toggle("pointer-tumbling", "pointer-change-start" === event.type)
				}
			}
			get inputSensitivity() {
				return this[$controls].inputSensitivity
			}
			set inputSensitivity(value) {
				this[$controls].inputSensitivity = value
			}
			getCameraOrbit() {
				let {
					theta,
					phi,
					radius
				} = this[$lastSpherical];
				return {
					theta,
					phi,
					radius,
					toString() {
						return `${this.theta}rad ${this.phi}rad ${this.radius}m`
					}
				}
			}
			getCameraTarget() {
				return toVector3D(this[$renderer].isPresenting ? this[$renderer].arRenderer.target : this[$scene].getTarget())
			}
			getFieldOfView() {
				return this[$controls].getFieldOfView()
			}
			getMinimumFieldOfView() {
				return this[$controls].options.minimumFieldOfView
			}
			getMaximumFieldOfView() {
				return this[$controls].options.maximumFieldOfView
			}
			getIdealAspect() {
				return this[$scene].idealAspect
			}
			jumpCameraToGoal() {
				this[$jumpCamera] = !0, this.requestUpdate($jumpCamera, !1)
			}
			resetInteractionPrompt() {
				this[$lastPromptOffset] = 0, this[$promptElementVisibleTime] = 1 / 0, this[$userHasInteracted] = !1, this[$waitingToPromptUser] = this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls
			}
			zoom(keyPresses) {
				let event = new WheelEvent("wheel", {
					deltaY: -30 * keyPresses
				});
				this[$userInputElement].dispatchEvent(event)
			}
			connectedCallback() {
				super.connectedCallback(), this[$controls].addEventListener("user-interaction", this[$cancelPrompts]), this[$controls].addEventListener("pointer-change-start", this[$onPointerChange]), this[$controls].addEventListener("pointer-change-end", this[$onPointerChange])
			}
			disconnectedCallback() {
				super.disconnectedCallback(), this[$controls].removeEventListener("user-interaction", this[$cancelPrompts]), this[$controls].removeEventListener("pointer-change-start", this[$onPointerChange]), this[$controls].removeEventListener("pointer-change-end", this[$onPointerChange])
			}
			updated(changedProperties) {
				super.updated(changedProperties);
				let controls = this[$controls],
					scene = this[$scene];
				if (changedProperties.has("cameraControls") && (this.cameraControls ? (controls.enableInteraction(), this.interactionPrompt === InteractionPromptStrategy.AUTO && (this[$waitingToPromptUser] = !0)) : (controls.disableInteraction(), this[$deferInteractionPrompt]()), this[$userInputElement].setAttribute("aria-label", this[$ariaLabel])), changedProperties.has("disableZoom") && (controls.disableZoom = this.disableZoom), changedProperties.has("disablePan") && (controls.enablePan = !this.disablePan), changedProperties.has("disableTap") && (controls.enableTap = !this.disableTap), (changedProperties.has("interactionPrompt") || changedProperties.has("cameraControls") || changedProperties.has("src")) && (this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls && !this[$userHasInteracted] ? this[$waitingToPromptUser] = !0 : this[$deferInteractionPrompt]()), changedProperties.has("interactionPromptStyle") && (this[$promptAnimatedContainer].style.opacity = this.interactionPromptStyle == InteractionPromptStyle.BASIC ? "1" : "0"), changedProperties.has("touchAction")) {
					let touchAction = this.touchAction;
					controls.applyOptions({
						touchAction
					}), controls.updateTouchActionStyle()
				}
				changedProperties.has("orbitSensitivity") && (controls.orbitSensitivity = this.orbitSensitivity), changedProperties.has("zoomSensitivity") && (controls.zoomSensitivity = this.zoomSensitivity), changedProperties.has("panSensitivity") && (controls.panSensitivity = this.panSensitivity), changedProperties.has("interpolationDecay") && (controls.setDamperDecayTime(this.interpolationDecay), scene.setTargetDamperDecayTime(this.interpolationDecay)), !0 === this[$jumpCamera] && Promise.resolve().then(() => {
					controls.jumpToGoal(), scene.jumpToGoal(), this[$onChange](), this[$jumpCamera] = !1
				})
			}
			async updateFraming() {
				let scene = this[$scene],
					oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);
				await scene.updateFraming();
				let newFramedFoV = scene.adjustedFoV(scene.framedFoVDeg),
					zoom = this[$controls].getFieldOfView() / oldFramedFoV;
				this[$controls].setFieldOfView(newFramedFoV * zoom), this[$maintainThetaPhi] = !0, this.requestUpdate("maxFieldOfView"), this.requestUpdate("fieldOfView"), this.requestUpdate("minCameraOrbit"), this.requestUpdate("maxCameraOrbit"), this.requestUpdate("cameraOrbit"), await this.updateComplete
			}
			interact(duration, finger0, finger1) {
				let inputElement = this[$userInputElement],
					fingerElements = this[$fingerAnimatedContainers];
				if ("1" === fingerElements[0].style.opacity) {
					console.warn("interact() failed because an existing interaction is running.");
					return
				}
				let xy = [];
				xy.push({
					x: timeline(finger0.x),
					y: timeline(finger0.y)
				});
				let positions = [{
					x: xy[0].x(0),
					y: xy[0].y(0)
				}];
				null != finger1 && (xy.push({
					x: timeline(finger1.x),
					y: timeline(finger1.y)
				}), positions.push({
					x: xy[1].x(0),
					y: xy[1].y(0)
				}));
				let startTime = performance.now(),
					{
						width,
						height
					} = this[$scene],
					rect = this.getBoundingClientRect(),
					dispatchTouches = type => {
						for (let [i, position] of positions.entries()) {
							let {
								style
							} = fingerElements[i];
							style.transform = `translateX(${width*position.x}px) translateY(${height*position.y}px)`, "pointerdown" === type ? style.opacity = "1" : "pointerup" === type && (style.opacity = "0");
							let init = {
								pointerId: i - 5678,
								pointerType: "touch",
								target: inputElement,
								clientX: width * position.x + rect.x,
								clientY: height * position.y + rect.y,
								altKey: !0
							};
							inputElement.dispatchEvent(new PointerEvent(type, init))
						}
					},
					moveTouches = () => {
						let changeSource = this[$cancellationSource];
						if (changeSource !== ChangeSource.AUTOMATIC || !inputElement.isConnected) {
							for (let fingerElement of this[$fingerAnimatedContainers]) fingerElement.style.opacity = "0";
							dispatchTouches("pointercancel"), this.dispatchEvent(new CustomEvent("interact-stopped", {
								detail: {
									source: changeSource
								}
							})), document.removeEventListener("visibilitychange", onVisibilityChange);
							return
						}
						let time = Math.min(1, (performance.now() - startTime) / duration);
						for (let [i, position] of positions.entries()) position.x = xy[i].x(time), position.y = xy[i].y(time);
						dispatchTouches("pointermove"), time < 1 ? requestAnimationFrame(moveTouches) : (dispatchTouches("pointerup"), this.dispatchEvent(new CustomEvent("interact-stopped", {
							detail: {
								source: ChangeSource.AUTOMATIC
							}
						})), document.removeEventListener("visibilitychange", onVisibilityChange))
					},
					onVisibilityChange = () => {
						let elapsed = 0;
						"hidden" === document.visibilityState ? elapsed = performance.now() - startTime : startTime = performance.now() - elapsed
					};
				document.addEventListener("visibilitychange", onVisibilityChange), dispatchTouches("pointerdown"), this[$cancellationSource] = ChangeSource.AUTOMATIC, requestAnimationFrame(moveTouches)
			} [(_a = $promptElement, _b = $promptAnimatedContainer, _c = $fingerAnimatedContainers, _d = $panElement, _e = $lastPromptOffset, _f = $promptElementVisibleTime, _g = $userHasInteracted, _h = $waitingToPromptUser, _j = $cancellationSource, _k = $controls, _l = $lastSpherical, _m = $jumpCamera, _o = $initialized, _p = $maintainThetaPhi, $syncFieldOfView)](style) {
				let controls = this[$controls],
					scene = this[$scene];
				scene.framedFoVDeg = 180 * style[0] / Math.PI, controls.changeSource = ChangeSource.NONE, controls.setFieldOfView(scene.adjustedFoV(scene.framedFoVDeg)), this[$cancelPrompts]()
			} [$syncCameraOrbit](style) {
				let controls = this[$controls];
				if (this[$maintainThetaPhi]) {
					let {
						theta,
						phi
					} = this.getCameraOrbit();
					style[0] = theta, style[1] = phi, this[$maintainThetaPhi] = !1
				}
				controls.changeSource = ChangeSource.NONE, controls.setOrbit(style[0], style[1], style[2]), this[$cancelPrompts]()
			} [$syncMinCameraOrbit](style) {
				this[$controls].applyOptions({
					minimumAzimuthalAngle: style[0],
					minimumPolarAngle: style[1],
					minimumRadius: style[2]
				}), this.jumpCameraToGoal()
			} [$syncMaxCameraOrbit](style) {
				this[$controls].applyOptions({
					maximumAzimuthalAngle: style[0],
					maximumPolarAngle: style[1],
					maximumRadius: style[2]
				}), this[$updateCameraForRadius](style[2]), this.jumpCameraToGoal()
			} [$syncMinFieldOfView](style) {
				this[$controls].applyOptions({
					minimumFieldOfView: 180 * style[0] / Math.PI
				}), this.jumpCameraToGoal()
			} [$syncMaxFieldOfView](style) {
				let fov = this[$scene].adjustedFoV(180 * style[0] / Math.PI);
				this[$controls].applyOptions({
					maximumFieldOfView: fov
				}), this.jumpCameraToGoal()
			} [$syncCameraTarget](style) {
				let [x, y, z] = style;
				this[$renderer].arRenderer.isPresenting || this[$scene].setTarget(x, y, z), this[$controls].changeSource = ChangeSource.NONE, this[$renderer].arRenderer.updateTarget(), this[$cancelPrompts]()
			} [$tick](time, delta) {
				if (super[$tick](time, delta), this[$renderer].isPresenting || !this[$getModelIsVisible]()) return;
				let controls = this[$controls],
					scene = this[$scene],
					now = performance.now();
				if (this[$waitingToPromptUser] && this.loaded && now > this[$loadedTime] + this.interactionPromptThreshold && (this[$waitingToPromptUser] = !1, this[$promptElementVisibleTime] = now, this[$promptElement].classList.add("visible")), isFinite(this[$promptElementVisibleTime]) && this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {
					let animationTime = (now - this[$promptElementVisibleTime]) / 5e3 % 1,
						offset = wiggle(animationTime),
						opacity = fade(animationTime);
					if (this[$promptAnimatedContainer].style.opacity = `${opacity}`, offset !== this[$lastPromptOffset]) {
						let xOffset = offset * scene.width * .05,
							deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;
						this[$promptAnimatedContainer].style.transform = `translateX(${xOffset}px)`, controls.changeSource = ChangeSource.AUTOMATIC, controls.adjustOrbit(deltaTheta, 0, 0), this[$lastPromptOffset] = offset
					}
				}
				let cameraMoved = controls.update(time, delta),
					targetMoved = scene.updateTarget(delta);
				(cameraMoved || targetMoved) && this[$onChange]()
			} [$deferInteractionPrompt]() {
				this[$waitingToPromptUser] = !1, this[$promptElement].classList.remove("visible"), this[$promptElementVisibleTime] = 1 / 0
			} [$updateCameraForRadius](radius) {
				let maximumRadius = Math.max(this[$scene].farRadius(), radius);
				this[$controls].updateNearFar(0, Math.abs(2 * maximumRadius))
			} [$updateAria]() {
				let {
					theta,
					phi
				} = this[$controls].getCameraSpherical(this[$lastSpherical]), azimuthalQuadrantLabel = AZIMUTHAL_QUADRANT_LABELS[(4 + Math.floor((theta % TAU + QUARTER_PI) / HALF_PI)) % 4], polarTrientLabel = POLAR_TRIENT_LABELS[Math.floor(phi / THIRD_PI)];
				this[$updateStatus](`View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`)
			}
			get[$ariaLabel]() {
				return super[$ariaLabel].replace(/\.$/, "") + (this.cameraControls ? ". Use mouse, touch or arrow keys to move." : "")
			}
			async [$onResize](event) {
				let controls = this[$controls],
					scene = this[$scene],
					oldFramedFoV = scene.adjustedFoV(scene.framedFoVDeg);
				super[$onResize](event);
				let fovRatio = scene.adjustedFoV(scene.framedFoVDeg) / oldFramedFoV,
					fov = controls.getFieldOfView() * (isFinite(fovRatio) ? fovRatio : 1);
				controls.updateAspect(this[$scene].aspect), this.requestUpdate("maxFieldOfView", this.maxFieldOfView), await this.updateComplete, this[$controls].setFieldOfView(fov), this.jumpCameraToGoal()
			} [$onModelLoad]() {
				super[$onModelLoad](), this[$initialized] ? this[$maintainThetaPhi] = !0 : this[$initialized] = !0, this.requestUpdate("maxFieldOfView", this.maxFieldOfView), this.requestUpdate("fieldOfView", this.fieldOfView), this.requestUpdate("minCameraOrbit", this.minCameraOrbit), this.requestUpdate("maxCameraOrbit", this.maxCameraOrbit), this.requestUpdate("cameraOrbit", this.cameraOrbit), this.requestUpdate("cameraTarget", this.cameraTarget), this.jumpCameraToGoal()
			}
		}
		return _q = $cancelPrompts, _r = $onChange, _s = $onPointerChange, __decorate$6([n$8({
			type: Boolean,
			attribute: "camera-controls"
		})], ControlsModelViewerElement.prototype, "cameraControls", void 0), __decorate$6([style({
			intrinsics: cameraOrbitIntrinsics,
			observeEffects: !0,
			updateHandler: $syncCameraOrbit
		}), n$8({
			type: String,
			attribute: "camera-orbit",
			hasChanged: () => !0
		})], ControlsModelViewerElement.prototype, "cameraOrbit", void 0), __decorate$6([style({
			intrinsics: cameraTargetIntrinsics,
			observeEffects: !0,
			updateHandler: $syncCameraTarget
		}), n$8({
			type: String,
			attribute: "camera-target",
			hasChanged: () => !0
		})], ControlsModelViewerElement.prototype, "cameraTarget", void 0), __decorate$6([style({
			intrinsics: fieldOfViewIntrinsics,
			observeEffects: !0,
			updateHandler: $syncFieldOfView
		}), n$8({
			type: String,
			attribute: "field-of-view",
			hasChanged: () => !0
		})], ControlsModelViewerElement.prototype, "fieldOfView", void 0), __decorate$6([style({
			intrinsics: minCameraOrbitIntrinsics,
			updateHandler: $syncMinCameraOrbit
		}), n$8({
			type: String,
			attribute: "min-camera-orbit",
			hasChanged: () => !0
		})], ControlsModelViewerElement.prototype, "minCameraOrbit", void 0), __decorate$6([style({
			intrinsics: maxCameraOrbitIntrinsics,
			updateHandler: $syncMaxCameraOrbit
		}), n$8({
			type: String,
			attribute: "max-camera-orbit",
			hasChanged: () => !0
		})], ControlsModelViewerElement.prototype, "maxCameraOrbit", void 0), __decorate$6([style({
			intrinsics: minFieldOfViewIntrinsics,
			updateHandler: $syncMinFieldOfView
		}), n$8({
			type: String,
			attribute: "min-field-of-view",
			hasChanged: () => !0
		})], ControlsModelViewerElement.prototype, "minFieldOfView", void 0), __decorate$6([style({
			intrinsics: fieldOfViewIntrinsics,
			updateHandler: $syncMaxFieldOfView
		}), n$8({
			type: String,
			attribute: "max-field-of-view",
			hasChanged: () => !0
		})], ControlsModelViewerElement.prototype, "maxFieldOfView", void 0), __decorate$6([n$8({
			type: Number,
			attribute: "interaction-prompt-threshold"
		})], ControlsModelViewerElement.prototype, "interactionPromptThreshold", void 0), __decorate$6([n$8({
			type: String,
			attribute: "interaction-prompt"
		})], ControlsModelViewerElement.prototype, "interactionPrompt", void 0), __decorate$6([n$8({
			type: String,
			attribute: "interaction-prompt-style"
		})], ControlsModelViewerElement.prototype, "interactionPromptStyle", void 0), __decorate$6([n$8({
			type: Number,
			attribute: "orbit-sensitivity"
		})], ControlsModelViewerElement.prototype, "orbitSensitivity", void 0), __decorate$6([n$8({
			type: Number,
			attribute: "zoom-sensitivity"
		})], ControlsModelViewerElement.prototype, "zoomSensitivity", void 0), __decorate$6([n$8({
			type: Number,
			attribute: "pan-sensitivity"
		})], ControlsModelViewerElement.prototype, "panSensitivity", void 0), __decorate$6([n$8({
			type: String,
			attribute: "touch-action"
		})], ControlsModelViewerElement.prototype, "touchAction", void 0), __decorate$6([n$8({
			type: Boolean,
			attribute: "disable-zoom"
		})], ControlsModelViewerElement.prototype, "disableZoom", void 0), __decorate$6([n$8({
			type: Boolean,
			attribute: "disable-pan"
		})], ControlsModelViewerElement.prototype, "disablePan", void 0), __decorate$6([n$8({
			type: Boolean,
			attribute: "disable-tap"
		})], ControlsModelViewerElement.prototype, "disableTap", void 0), __decorate$6([n$8({
			type: Number,
			attribute: "interpolation-decay"
		})], ControlsModelViewerElement.prototype, "interpolationDecay", void 0), ControlsModelViewerElement
	})((ModelViewerElement => {
		var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
		class ARModelViewerElement extends ModelViewerElement {
			constructor() {
				super(...arguments), this.ar = !1, this.arScale = "auto", this.arPlacement = "floor", this.arModes = "webxr scene-viewer quick-look", this.iosSrc = null, this.xrEnvironment = !1, this[_a] = !1, this[_b] = this.shadowRoot.querySelector(".ar-button"), this[_c] = document.createElement("a"), this[_d] = new Set, this[_e] = ARMode.NONE, this[_f] = !1, this[_g] = event => {
					event.preventDefault(), this.activateAR()
				}, this[_h] = ({
					status
				}) => {
					(status === ARStatus.NOT_PRESENTING || this[$renderer].arRenderer.presentedScene === this[$scene]) && (this.setAttribute("ar-status", status), this.dispatchEvent(new CustomEvent("ar-status", {
						detail: {
							status
						}
					})), status === ARStatus.NOT_PRESENTING ? this.removeAttribute("ar-tracking") : status === ARStatus.SESSION_STARTED && this.setAttribute("ar-tracking", ARTracking.TRACKING))
				}, this[_j] = ({
					status
				}) => {
					this.setAttribute("ar-tracking", status), this.dispatchEvent(new CustomEvent("ar-tracking", {
						detail: {
							status
						}
					}))
				}, this[_k] = event => {
					"_apple_ar_quicklook_button_tapped" == event.data && this.dispatchEvent(new CustomEvent("quick-look-button-tapped"))
				}
			}
			get canActivateAR() {
				return this[$arMode] !== ARMode.NONE
			}
			connectedCallback() {
				super.connectedCallback(), this[$renderer].arRenderer.addEventListener("status", this[$onARStatus]), this.setAttribute("ar-status", ARStatus.NOT_PRESENTING), this[$renderer].arRenderer.addEventListener("tracking", this[$onARTracking]), this[$arAnchor].addEventListener("message", this[$onARTap])
			}
			disconnectedCallback() {
				super.disconnectedCallback(), this[$renderer].arRenderer.removeEventListener("status", this[$onARStatus]), this[$renderer].arRenderer.removeEventListener("tracking", this[$onARTracking]), this[$arAnchor].removeEventListener("message", this[$onARTap])
			}
			update(changedProperties) {
				super.update(changedProperties), changedProperties.has("arScale") && (this[$scene].canScale = "fixed" !== this.arScale), changedProperties.has("arPlacement") && (this[$scene].updateShadow(), this[$needsRender]()), changedProperties.has("arModes") && (this[$arModes] = deserializeARModes(this.arModes)), (changedProperties.has("ar") || changedProperties.has("arModes") || changedProperties.has("src") || changedProperties.has("iosSrc")) && this[$selectARMode]()
			}
			async activateAR() {
				switch (this[$arMode]) {
					case ARMode.QUICK_LOOK:
						await this[$openIOSARQuickLook]();
						break;
					case ARMode.WEBXR:
						await this[$enterARWithWebXR]();
						break;
					case ARMode.SCENE_VIEWER:
						this[$openSceneViewer]();
						break;
					default:
						console.warn("No AR Mode can be activated. This is probably due to missing configuration or device capabilities")
				}
			}
			async [(_a = $canActivateAR, _b = $arButtonContainer, _c = $arAnchor, _d = $arModes, _e = $arMode, _f = $preload, _g = $onARButtonContainerClick, _h = $onARStatus, _j = $onARTracking, _k = $onARTap, $selectARMode)]() {
				let arMode = ARMode.NONE;
				if (this.ar) {
					if (null != this.src)
						for (let value of this[$arModes]) {
							if ("webxr" === value && HAS_WEBXR_HIT_TEST_API && !isWebXRBlocked && await this[$renderer].arRenderer.supportsPresentation()) {
								arMode = ARMode.WEBXR;
								break
							}
							if ("scene-viewer" === value && IS_SCENEVIEWER_CANDIDATE && !isSceneViewerBlocked) {
								arMode = ARMode.SCENE_VIEWER;
								break
							}
							if ("quick-look" === value && IS_AR_QUICKLOOK_CANDIDATE) {
								arMode = ARMode.QUICK_LOOK;
								break
							}
						}
					arMode === ARMode.NONE && null != this.iosSrc && IS_AR_QUICKLOOK_CANDIDATE && (arMode = ARMode.QUICK_LOOK)
				}
				if (arMode !== ARMode.NONE) this[$arButtonContainer].classList.add("enabled"), this[$arButtonContainer].addEventListener("click", this[$onARButtonContainerClick]);
				else if (this[$arButtonContainer].classList.contains("enabled")) {
					this[$arButtonContainer].removeEventListener("click", this[$onARButtonContainerClick]), this[$arButtonContainer].classList.remove("enabled");
					let status = ARStatus.FAILED;
					this.setAttribute("ar-status", status), this.dispatchEvent(new CustomEvent("ar-status", {
						detail: {
							status
						}
					}))
				}
				this[$arMode] = arMode
			}
			async [$enterARWithWebXR]() {
				console.log("Attempting to present in AR with WebXR..."), await this[$triggerLoad]();
				try {
					this[$arButtonContainer].removeEventListener("click", this[$onARButtonContainerClick]);
					let {
						arRenderer
					} = this[$renderer];
					arRenderer.placeOnWall = "wall" === this.arPlacement, await arRenderer.present(this[$scene], this.xrEnvironment)
				} catch (error) {
					console.warn("Error while trying to present in AR with WebXR"), console.error(error), await this[$renderer].arRenderer.stopPresenting(), isWebXRBlocked = !0, console.warn("Falling back to next ar-mode"), await this[$selectARMode](), this.activateAR()
				} finally {
					this[$selectARMode]()
				}
			}
			async [$triggerLoad]() {
				this.loaded || (this[$preload] = !0, this[$updateSource](), await waitForEvent(this, "load"), this[$preload] = !1)
			} [$shouldAttemptPreload]() {
				return super[$shouldAttemptPreload]() || this[$preload]
			} [$openSceneViewer]() {
				let location = self.location.toString(),
					locationUrl = new URL(location),
					modelUrl = new URL(this.src, location);
				modelUrl.hash && (modelUrl.hash = "");
				let params = new URLSearchParams(modelUrl.search);
				if (locationUrl.hash = noArViewerSigil, params.set("mode", "ar_preferred"), params.has("disable_occlusion") || params.set("disable_occlusion", "true"), "fixed" === this.arScale && params.set("resizable", "false"), "wall" === this.arPlacement && params.set("enable_vertical_placement", "true"), params.has("sound")) {
					let soundUrl = new URL(params.get("sound"), location);
					params.set("sound", soundUrl.toString())
				}
				if (params.has("link")) {
					let linkUrl = new URL(params.get("link"), location);
					params.set("link", linkUrl.toString())
				}
				let intent = `intent://arvr.google.com/scene-viewer/1.0?${params.toString()+"&file="+encodeURIComponent(modelUrl.toString())}#Intent;scheme=https;package=com.google.ar.core;action=android.intent.action.VIEW;S.browser_fallback_url=${encodeURIComponent(locationUrl.toString())};end;`;
				self.addEventListener("hashchange", () => {
					self.location.hash === noArViewerSigil && (isSceneViewerBlocked = !0, self.history.back(), console.warn("Error while trying to present in AR with Scene Viewer"), console.warn("Falling back to next ar-mode"), this[$selectARMode]())
				}, {
					once: !0
				}), this[$arAnchor].setAttribute("href", intent), console.log("Attempting to present in AR with Scene Viewer..."), this[$arAnchor].click()
			}
			async [$openIOSARQuickLook]() {
				let generateUsdz = !this.iosSrc;
				this[$arButtonContainer].classList.remove("enabled");
				let objectURL = generateUsdz ? await this.prepareUSDZ() : this.iosSrc,
					modelUrl = new URL(objectURL, self.location.toString());
				if (generateUsdz) {
					let locationUrl = new URL(self.location.toString()),
						srcUrl = new URL(this.src, locationUrl);
					srcUrl.hash && (modelUrl.hash = srcUrl.hash)
				}
				"fixed" === this.arScale && (modelUrl.hash && (modelUrl.hash += "&"), modelUrl.hash += "allowsContentScaling=0");
				let anchor = this[$arAnchor];
				anchor.setAttribute("rel", "ar");
				let img = document.createElement("img");
				anchor.appendChild(img), anchor.setAttribute("href", modelUrl.toString()), generateUsdz && anchor.setAttribute("download", "model.usdz"), anchor.style.display = "none", anchor.isConnected || this.shadowRoot.appendChild(anchor), console.log("Attempting to present in AR with Quick Look..."), anchor.click(), anchor.removeChild(img), generateUsdz && URL.revokeObjectURL(objectURL), this[$arButtonContainer].classList.add("enabled")
			}
			async prepareUSDZ() {
				let updateSourceProgress = this[$progressTracker].beginActivity("usdz-conversion");
				await this[$triggerLoad]();
				let {
					model,
					shadow
				} = this[$scene];
				if (null == model) return "";
				let visible = !1;
				null != shadow && (visible = shadow.visible, shadow.visible = !1), updateSourceProgress(.2);
				let exporter = new USDZExporter,
					blob = new Blob([await exporter.parse(model)], {
						type: "model/vnd.usdz+zip"
					}),
					url = URL.createObjectURL(blob);
				return updateSourceProgress(1), null != shadow && (shadow.visible = visible), url
			}
		}
		return __decorate$2([n$8({
			type: Boolean,
			attribute: "ar"
		})], ARModelViewerElement.prototype, "ar", void 0), __decorate$2([n$8({
			type: String,
			attribute: "ar-scale"
		})], ARModelViewerElement.prototype, "arScale", void 0), __decorate$2([n$8({
			type: String,
			attribute: "ar-placement"
		})], ARModelViewerElement.prototype, "arPlacement", void 0), __decorate$2([n$8({
			type: String,
			attribute: "ar-modes"
		})], ARModelViewerElement.prototype, "arModes", void 0), __decorate$2([n$8({
			type: String,
			attribute: "ios-src"
		})], ARModelViewerElement.prototype, "iosSrc", void 0), __decorate$2([n$8({
			type: Boolean,
			attribute: "xr-environment"
		})], ARModelViewerElement.prototype, "xrEnvironment", void 0), ARModelViewerElement
	})((ModelViewerElement => {
		var _a, _b, _c, _d, _e, _f, _g, _h;
		class LoadingModelViewerElement extends ModelViewerElement {
			constructor(...args) {
				super(...args), this.poster = null, this.reveal = RevealStrategy.AUTO, this.loading = LoadingStrategy.AUTO, this[_a] = !1, this[_b] = !1, this[_c] = this.shadowRoot.querySelector(".slot.poster"), this[_d] = this.shadowRoot.querySelector("#default-poster"), this[_e] = this.shadowRoot.querySelector("#default-progress-bar > .bar"), this[_f] = this[$defaultPosterElement].getAttribute("aria-label"), this[_g] = throttle(progress => {
					let parentNode = this[$defaultProgressBarElement].parentNode;
					requestAnimationFrame(() => {
						this[$defaultProgressBarElement].style.transform = `scaleX(${progress})`, 0 === progress && (parentNode.removeChild(this[$defaultProgressBarElement]), parentNode.appendChild(this[$defaultProgressBarElement])), this[$defaultProgressBarElement].classList.toggle("hide", 1 === progress)
					})
				}, 100), this[_h] = event => {
					let progress = event.detail.totalProgress;
					1 === progress && (this[$updateProgressBar].flush(), this.loaded && (this[$shouldDismissPoster] || this.reveal === RevealStrategy.AUTO) && this[$hidePoster]()), this[$updateProgressBar](progress), this.dispatchEvent(new CustomEvent("progress", {
						detail: {
							totalProgress: progress
						}
					}))
				};
				let ModelViewerElement = self.ModelViewerElement || {},
					dracoDecoderLocation = ModelViewerElement.dracoDecoderLocation || "https://www.gstatic.com/draco/versioned/decoders/1.5.6/";
				CachingGLTFLoader.setDRACODecoderLocation(dracoDecoderLocation);
				let ktx2TranscoderLocation = ModelViewerElement.ktx2TranscoderLocation || "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
				CachingGLTFLoader.setKTX2TranscoderLocation(ktx2TranscoderLocation), ModelViewerElement.meshoptDecoderLocation && CachingGLTFLoader.setMeshoptDecoderLocation(ModelViewerElement.meshoptDecoderLocation);
				let lottieLoaderLocation = ModelViewerElement.lottieLoaderLocation || "https://cdn.jsdelivr.net/npm/three@0.149.0/examples/jsm/loaders/LottieLoader.js";
				Renderer.singleton.textureUtils.lottieLoaderUrl = lottieLoaderLocation
			}
			static set dracoDecoderLocation(value) {
				CachingGLTFLoader.setDRACODecoderLocation(value)
			}
			static get dracoDecoderLocation() {
				return CachingGLTFLoader.getDRACODecoderLocation()
			}
			static set ktx2TranscoderLocation(value) {
				CachingGLTFLoader.setKTX2TranscoderLocation(value)
			}
			static get ktx2TranscoderLocation() {
				return CachingGLTFLoader.getKTX2TranscoderLocation()
			}
			static set meshoptDecoderLocation(value) {
				CachingGLTFLoader.setMeshoptDecoderLocation(value)
			}
			static get meshoptDecoderLocation() {
				return CachingGLTFLoader.getMeshoptDecoderLocation()
			}
			static set lottieLoaderLocation(value) {
				Renderer.singleton.textureUtils.lottieLoaderUrl = value
			}
			static get lottieLoaderLocation() {
				return Renderer.singleton.textureUtils.lottieLoaderUrl
			}
			static mapURLs(callback) {
				Renderer.singleton.loader[$loader].manager.setURLModifier(callback)
			}
			dismissPoster() {
				this.loaded ? this[$hidePoster]() : (this[$shouldDismissPoster] = !0, this[$updateSource]())
			}
			showPoster() {
				let posterContainerElement = this[$posterContainerElement];
				if (posterContainerElement.classList.contains("show")) return;
				posterContainerElement.classList.add("show"), this[$userInputElement].classList.remove("show");
				let defaultPosterElement = this[$defaultPosterElement];
				defaultPosterElement.removeAttribute("tabindex"), defaultPosterElement.removeAttribute("aria-hidden");
				let oldVisibility = this.modelIsVisible;
				this[$modelIsRevealed] = !1, this[$announceModelVisibility](oldVisibility)
			}
			getDimensions() {
				return toVector3D(this[$scene].size)
			}
			getBoundingBoxCenter() {
				return toVector3D(this[$scene].boundingBox.getCenter(new Vector3))
			}
			connectedCallback() {
				super.connectedCallback(), this.loaded || this.showPoster(), this[$progressTracker].addEventListener("progress", this[$onProgress])
			}
			disconnectedCallback() {
				super.disconnectedCallback(), this[$progressTracker].removeEventListener("progress", this[$onProgress])
			}
			async updated(changedProperties) {
				super.updated(changedProperties), changedProperties.has("poster") && null != this.poster && (this[$defaultPosterElement].style.backgroundImage = `url(${this.poster})`), changedProperties.has("alt") && this[$defaultPosterElement].setAttribute("aria-label", this[$altDefaulted]), (changedProperties.has("reveal") || changedProperties.has("loading")) && this[$updateSource]()
			} [(_a = $modelIsRevealed, _b = $shouldDismissPoster, _c = $posterContainerElement, _d = $defaultPosterElement, _e = $defaultProgressBarElement, _f = $ariaLabelCallToAction, _g = $updateProgressBar, _h = $onProgress, $shouldAttemptPreload)]() {
				return !!this.src && (this[$shouldDismissPoster] || this.loading === LoadingStrategy.EAGER || this.reveal === RevealStrategy.AUTO && this[$isElementInViewport])
			} [$hidePoster]() {
				this[$shouldDismissPoster] = !1;
				let posterContainerElement = this[$posterContainerElement];
				if (!posterContainerElement.classList.contains("show")) return;
				posterContainerElement.classList.remove("show"), this[$userInputElement].classList.add("show");
				let oldVisibility = this.modelIsVisible;
				this[$modelIsRevealed] = !0, this[$announceModelVisibility](oldVisibility);
				let root = this.getRootNode();
				root && root.activeElement === this && this[$userInputElement].focus();
				let defaultPosterElement = this[$defaultPosterElement];
				defaultPosterElement.setAttribute("aria-hidden", "true"), defaultPosterElement.tabIndex = -1, this.dispatchEvent(new CustomEvent("poster-dismissed"))
			} [$getModelIsVisible]() {
				return super[$getModelIsVisible]() && this[$modelIsRevealed]
			}
		}
		return __decorate$1([n$8({
			type: String
		})], LoadingModelViewerElement.prototype, "poster", void 0), __decorate$1([n$8({
			type: String
		})], LoadingModelViewerElement.prototype, "reveal", void 0), __decorate$1([n$8({
			type: String
		})], LoadingModelViewerElement.prototype, "loading", void 0), LoadingModelViewerElement
	})((ModelViewerElement => {
		var _a;
		class AnimationModelViewerElement extends ModelViewerElement {
			constructor(...args) {
				super(args), this.autoplay = !1, this.animationName = void 0, this.animationCrossfadeDuration = 300, this[_a] = !0, this[$scene].subscribeMixerEvent("loop", e => {
					let count = e.action._loopCount;
					this.dispatchEvent(new CustomEvent("loop", {
						detail: {
							count
						}
					}))
				}), this[$scene].subscribeMixerEvent("finished", () => {
					this[$paused] = !0, this.dispatchEvent(new CustomEvent("finished"))
				})
			}
			get availableAnimations() {
				return this.loaded ? this[$scene].animationNames : []
			}
			get duration() {
				return this[$scene].duration
			}
			get paused() {
				return this[$paused]
			}
			get currentTime() {
				return this[$scene].animationTime
			}
			set currentTime(value) {
				this[$scene].animationTime = value, this[$needsRender]()
			}
			get timeScale() {
				return this[$scene].animationTimeScale
			}
			set timeScale(value) {
				this[$scene].animationTimeScale = value
			}
			pause() {
				this[$paused] || (this[$paused] = !0, this.dispatchEvent(new CustomEvent("pause")))
			}
			play(options) {
				this.availableAnimations.length > 0 && (this[$paused] = !1, this[$changeAnimation](options), this.dispatchEvent(new CustomEvent("play")))
			} [(_a = $paused, $onModelLoad)]() {
				super[$onModelLoad](), this[$paused] = !0, null != this.animationName && this[$changeAnimation](), this.autoplay && this.play()
			} [$tick](_time, delta) {
				super[$tick](_time, delta), !this[$paused] && (this[$getModelIsVisible]() || this[$renderer].isPresenting) && (this[$scene].updateAnimation(delta / 1e3), this[$needsRender]())
			}
			updated(changedProperties) {
				super.updated(changedProperties), changedProperties.has("autoplay") && this.autoplay && this.play(), changedProperties.has("animationName") && this[$changeAnimation]()
			} [$changeAnimation](options = DEFAULT_PLAY_OPTIONS) {
				var _b;
				let repetitions = null !== (_b = options.repetitions) && void 0 !== _b ? _b : 1 / 0,
					mode = options.pingpong ? 2202 : 1 === repetitions ? 2200 : 2201;
				this[$scene].playAnimation(this.animationName, this.animationCrossfadeDuration / 1e3, mode, repetitions), this[$paused] && (this[$scene].updateAnimation(0), this[$needsRender]())
			}
		}
		return __decorate$3([n$8({
			type: Boolean
		})], AnimationModelViewerElement.prototype, "autoplay", void 0), __decorate$3([n$8({
			type: String,
			attribute: "animation-name"
		})], AnimationModelViewerElement.prototype, "animationName", void 0), __decorate$3([n$8({
			type: Number,
			attribute: "animation-crossfade-duration"
		})], AnimationModelViewerElement.prototype, "animationCrossfadeDuration", void 0), AnimationModelViewerElement
	})(ModelViewerElementBase))))))));
customElements.define("model-viewer", ModelViewerElement);
export {
	CanvasTexture,
	FileLoader,
	Loader,
	ModelViewerElement,
	NearestFilter
};